/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@adraffy+ens-normalize@1.10.1/node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@adraffy+ens-normalize@1.10.1/node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = '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';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp) {\r\n\tinit();\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGFkcmFmZnkrZW5zLW5vcm1hbGl6ZUAxLjEwLjEvbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3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QTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssc0NBQXNDO0FBQzNDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRWtLIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9AYWRyYWZmeStlbnMtbm9ybWFsaXplQDEuMTAuMS9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLWVucyBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IDA1NjVlZDA0OWI5Y2YxNjE0YmI5ZTExYmE3ZDhhYzZhNmZiOTZjODkzMjUzZDg5MGY3ZTJiMjg4NGI5ZGVkMzJcbnZhciBDT01QUkVTU0VEJDEgPSAnQUVFVWR3bWdEUzhCeFFLS0FQNEJPZ0RqQVRBQW5nRFVBSU1Bb0FCb0FPQUFhZ0NPQUVRQWhBQk1BSElBT3dBOUFDc0FOZ0FtQUdJQUhnQXVBQ2dBSndBWEFDMEFHZ0FqQUI4QUx3QVVBQ2tBRWdBZUFBa0FHd0FSQUJrQUZnQTVBQ2dBTFFBckFEY0FGUUFwQUJBQUhnQWlBQkFBR2dBZUFCTUFHQVVoQmU4QkZ4UkVOOHNGMndDNUFLNUhBVzhBclFrRHpRQ3VoemMzTnpjQlA2OE5FZk1BQlFkSEJ1dzVCVjhGWUFBOU16a0k5cjRaQmc3UXlRQVdBOUNlT3dMTkNqY0NqcWtDaHVBL2xtK1JBc1hUQW9QNkFTZm5FUUR5dFFGSkFqV1ZDa2VYQU9zQTZnb2RBQi9jd2RBVUUwV2xCQ04vQVFVQ1FSakZEL01SQmpIeERRU0pidzBqQnpVQXN3QnhtZSt0bkljQVl3YWJBeXNHOFFBakFFTU1teGNEcWdQS1F5RFhDTU14QTdrVVF3RDNOWE9yQUttRklBQWZCQzBEM3g0QkpRREJHZFVGQWhFZ1ZEOEpud21RSmlOV1lVenJnMG9BR3dBVUFCMEFGbk5jQUNrQUZnQlA5aDNnUGZzRE9XREtuZVkyQ2hnbFgxVURZRDMwQUJzQUZBQWRBQlp6SUdSQW53REQ4d0FqQUVFTXpSYkRxZ01CMnNBRll3WHFBdENuQXNTNEF3cFVKS1J0RkhzYWRVejlBTU1WYndMcEFCTTFOSkVYMFprQ2dZTUJFeU1BeFJWdkF1a0FFelVCVUZBdG1Vd1NBeTREQlRFUjMzRWZ0UUhmU3dCNU14Si9BamtXS1FMekw4RS9jd0JCNlFIOUxRRFBEdE85QVNOcmlRQzVEUUFOQXdDSzIxRUZJOTF6SHdDb0w5a0JxUWNIQndjSEt6VURvd0J2QVFvaFB2VTNmQVFnSHdDeUFjOENLUU1BNXpNU2V6cjdVTGdGbURwL0x6VlFCZ0VHQWk4RllRVmd0OEFGY1R0bFFocENXRW1mZTV0bVo2SUFFeHNEelE4dCtYOHJCS3RUQWx0YkFuMGpzeThCbDZ1dFBXTURUUjhFaTJrUkFOa0RCck5ITnlzREJ6RUNRV1VBY3dGcEoza0FpeVVoQUowQlViOEFMM0VmQWJmTkF6ODFLVXNGV3dGM1lRWnRBbTBBK1ZFZkF6RUpEUUJSU1FDekFRQmxBSHNBTTcwR0QvdjNJWldIQndBUktRQXhBTHNqVHdIWkFlTVBFem1YZ0lId0FCSUFHUUE4QUVVQVFEdDNnZHZJRUdjUVpBa0dUUkZNZEVJVkV3SzBENjRMN1JFZEROa3EwOVBnQURTeEIvTURXd2Z6QTFzRFd3ZnpCL01EV3dmekExc0RXd05iQTFzY0V2QWkyOGdRWnc5UUJIVUZsZ1dUQk40SWl5WlJFWWtITUFqYVZCVjBKaHhQQTAwQkJDTXRTU1E3bXpNVEpVcE1GRTBMQ0FRMlNteXZmVUFEVHpHelZQMlFxZ1BUTWxjNWRBa0dIbmtTcUFBeUQzc2tOYjFPaG5wUGNhZ0tVMCsydFlkSmFrNXZBc1k2c0VBQUNpa0ptMi9EZDFZR1JSQWZKNmtRK3d3M0Fia0JQdzN4Uzl3RTlRWS9CTTBmZ1JrZEQ5R1ZvQWlwTGVFTThTYm5McVdBWGlQNUtvY0Y4VXY0UE9FTFVWRnNEMTBMYVFubk9tZUJVZ01sQVJFaWp3cmhEVDBJY1JEM0NzMXZEZWtSU1FjOUE5bEpuZ0NwQndVTEZSMDVGYmttRkdLd0N3MDVld2IvR3ZvTGt5YXpFeTE3QUFYWEdpVUdVUUV0R3dNQTB5N3JoYlJhTlZ3Z1QyTUdCd3NwSThzVXJGQWtEU2xBdTNoTUdoOEhHU1d0QXBWRGRFcUxVVG9lbHlINlBFRU5haTRYVVlBSCtUd0pHVk1MaFR5aVJxOUZFaEhXUHBFOVRDSk5UREFFT1lNc015ZVBDZE1QaVF5OWZIWUJYUWtsQ2JVTWRSTTFFUnMzeVFnOUJ4MHhseWduR1FnbFJwbGduZ1Q3b3dQM0U5VUREd1ZEQ1VVSEZ3TzVIREVUTWhVdEJSR0JLTnNDOXpiWkxyY0NrMWFFQVJzRnp3OHBIK01RVkVma0R1MElud0pwQTRjbDd3QXhGU1VBR3lLZkNFZG5BR09QM0ZNSkxzOEl5MnB3STNnRGF4VHJaUkYzQjVVT1d3ZXJIRGNWd3h6bGNNeGVENFlNS0tlekNWOEJlUW1kQVdNRTV3Z05OVitNcENCRloxZUxYQmlmSUdWQlExNEFBalVNYVJXalJNR0hmQUtQRDI4U0h3RTVBWGNIUFEwRkFuc1I4UkZ2RUprSTc0WUlOYmt6L0RvcEJGTWhoeUFWQ2lzRFUyelNDeXNtL1F6OGJRR25FbVlERURSQmQvSm5yMkM2S0JnQkJ4MHl5VUZrSWZVTGxrL1JES0FheFJoR1ZESVo2QWZEQS9jYTl5ZnVRVnNHQXdPbkJ4YzZVVFB5Qk1FTGJRaVBDVU1BVFE2bkd3ZmJHRzRLZFl6VUFUV1BBYnVkQTF1Vmh3Snprd1k3Qnc4QWF3K0xCWDNwQUNFQ3F3aW5BQWtBMHdOYkFEMENzUWVoQUIwQWlVVUJRUU1yTXdFbDZRS1RBNWNJTmM4Qm1UTUI5eTBFSDhjTUdRRDdPMjVPQXNPMUFvQnVacVlGNFZ3Q2tnSk5PUUZSS1FRSlVrdFZBN04xNVFEZkFFOEdGK05MQVJtdlRzOGU1MGNCNDNNdkFNc0Evd0FKT1FjSlJRSFJBZmR4QUxzQll3czFDYWEzdVFGUjdTMEFod0FaYndIYkFvMEE0UUE1QUlQMUFWY0FVUVZkL1FYWEFsTk5BUlUxSEM5YlpRRy9BeU1CTndFUkFIMEd6NUdwelFzakJIRUgxd0lRSHhYbEF1OHlCN2tGQXlMakU5RkN5UUs5NGxrQU1ob0tQQXFyQ3FwZ1gyUTNDalYyUFZRQUVoK3NQc3MvVWdWVk8xYzdYRHRYTzF3N1Z6dGNPMWM3WER0WE8xd0RtOFBtdytZS2NGOUpZZThNcWczWVJNdzZUUlBmWUZWZ05oUE1MYnNVeFJYU0pWb1pRUnJBSndrbDZGVU5Ed2d0MTJZMENEQTBlUmZBQUVNcGJJTkZZNG9lTkFwUEhPdFRsVlQ4TFI4QXRVdW1NN01Oc0JzWlJFUUZTM1h4WWk0V0Vnb21BbVNGQW1KR1gxR3pBVjgzSkFLaCt3Sm9uQUptRFFLZmlEZ2ZEd0ptUHdKbUtnUnlCSU1EZnhjRGZwWTVDamw3R3ptR09pY25BbXdoQWpJNk9BNENiY3NDYmJMempnTTNhMGt2QVdzQTRnRGxBRTRKQjV3TWtRRUNEOFlBRWJrQ2R6TUNkcVpEQW5sUFJ3SjR2aUZnMzBXeVJ2Y0NmRU1DZXN3Q2ZRMENmUFJJQkVpQlp5Z0FMeGxKWEVwZkdSdEswQUxSQlFMUTBFc3JBNGhUQTRmcVJNbVJOZ0x5cFYwSEF3T3lTOUpNTVNrSDAwMVFUYk1DaTBNQ2l0ekZId3NoUjJzSnV3S09Pd0tPWUVTYmhRS08zUUtPWUh4UnVGTTVBUTVTMkZTSkFwUC9BcE1RQU8wQUlGVWlWYk5WMUFvc0h5bVppakxsZUdwRlB6MENsNk1DNzdaWUphd0FYU2tDbHBNQ2xvQ2dBSzFac0ZvTmhWRUFQd0tXdVFLV1VseElYTlVDbWM4Q21XaGN6bDBMSFFLY256bkdPcUVDbkJvQ241OENucnlPQUNFVE5TNFRBcDMxQXA2V0FMbEJZVGhoOHdLZTF3S2djZ0d0QXA2akl3S2VVcWxqekdRcktTOENKN01DSm9JQ29QOENvRkRiQXFZekFxWFNBcWdEQUlFQ3AvWm9nR2kxQUFkTmFpQnExUUtzNXdLc3NnS3Rhd0t0QmdKWElRSlY0QUt4NWRzREgxSnNtd0t5d1JFQ3N1d2JiT1J0WjIxTVl3TWwwUUsyWUQ5RGJwUURLVWtDdUdJQ3VVc1pBcmt1ZTNBNmNPVUN2UjBETGJZRE1oVUN2b3h5QmdNemRRSytIbk1tYzFNQ3c4OEN3d2h6aG5SUE9VbDA1QU04cXdFRFBKNERQY01DeFlBQ3hrc0N4aFNOQXNodFZRTElTQUxKVXdMSk1nSmtvUUxkMW5oOVpYaXllU2xMMUFNWXAyY0dBbUg0R2ZlVktIc1BYcFpldnhVQ3oyOEN6M0F6VDFmVzl4ZWpBTXF4QXM5M0FTM3VBMDRXZms4SkF0d3JBdHVPQXRKVEExSmdBMU5qQVFVRFZaQ0FqVU1FenhyeFpFbDVBNExTZzVFQzJzc0MyZUtFRklSTnAwQURocWtBTXdOa0VvWjFYZjBBV1FMZmFRTGV2SGQ3QXVJejdSZ0I4elFyQWZTZkFmTFdpd0xyOXdMcGRIMERBdXI5QXVyb0FQMUxBYjBDN28wQzY2Q1dycGNIQXU1REE0WGttSDF3NUhHbEF2TUhBRzBEamhxWmx3TDNGd09SY2dPU2l3TDNuQUw1M1FMNGFwb2dtcSsvTzVzaUE1MkhBdjcrQVI4QVBaOGdBWiszQXdXUkE2WnVBNmJkQU5YSkF3WnVvWXlpQ1EwRERFMEJFd0VqQjNFR1piMXJDUUMvQkcvREZZOGV0eEVBRzNrOUFDY0ROeEpSQTQyREFXY3JKUUNNOHdBbEFPYW5DNk9WQ0xzR0k2ZkpCZ0N2QlJuREJ2RWxSVVlGRm9BRmNEOUdTRE5DS1VLOFgza1pYOFFBbHMwRk9nQ1FWQ0did1RzdVlEb1p1dGNPTnhqT0dKSEovZ1ZmQldBRlh3VmdCV3NGWUFWZkJXQUZYd1ZnQlY4RllBVmZCV0JPSFFqZmpXOEtDZ29LYkY3eE13VFJBN2tHTjhQREFNTUVyOE1BNzBneEZyb0ZUajV4UG5oQ1IwSytYMzAvWC9BQVdCa3pzd0NOQnN4enpBU203MGFDUlM0ckRETWVMejQ5Zm5YZmNzSDVHY29zY1FGejEzWTRId1ZuQlhMSnljbkFDTmRSWXdnSUNBcUVYb1dUeGdBN1A0a0FDeGJaQnUyMUt3MEFqTXNUQXdrVkFPVnRKVVVzSjFKQ3VVTEVTVUFyWHk5Z1BpOUFLd25KUlFZS1REOUxQb0EraVQ1NFBua0NrVUxFVVVwRFg5TldWM0pWRWpRQWMxdzNBM0lCRTNZblgrZzdRaU1KYjZNS2Fpc3pSQ1V1UXJOQ3hEUE1DY3dFWDlFV0p6WVJFQkVFQndJSEtuNmwzM0pDTlZJZnliUEp0QWx0eWRQVUNtaEJady90RUtzWkFKT1ZKVTFDTFJ1eGJVSE9RQW83UDBzK2VFSkhIQThTSlZSUGRHTTBOVnJwdkJvS2hmVWxNMEpISEdVUVVoRVdPMXhMU2o4TU8wdWNOQXFKSXpWQ1J4djlFRnNxS3lBNE9RZ05qMm53WmdwNVpORmdFMkExSzNZSFMyQWhRUW9qSm1DN0RncHpHRzFXWUZVWkNRWUhaTzlnSFdDZFlJVmd1MkJUWUpsd0ZoOEd2UmJjWGJHOFlndERIck1Cd3pQVnlRb25IUWdrQ3lZQmdRSjBBamM0blZxSUF3R1NDc0JQSWdEc0szU1dFdElWQmE1TjhnR2pBbytrVndWSVp3RC9BRVVTQ0R3ZVg0SVRyUlFzSjhLM1R3QlhGRHdFQUIwVHZ6VmNBdG9UUzIwUkl3RGdWZ1o5QkJJbVlnQTVBTDRDb2k4TEZuZXpPa0NuSVFGakFZNEtCQVBoOVJjR3NnWlNCc0VBSmN0ZHNXSVJ1MmtUa1FzdFJ3N0RBY01CS2dwUEJHSUdNREF3S0NZbktUUWFMZzRBS1JTVkFGd0NkbCtZVVowSmRpY0ZEM2xQQWR0MUY5WlpLQ0d4dUUzeUJ4a0ZWR2NBL3dCRkVnaUNCd0FPTEhRU2p4T3RRRGcxejdkZUZSTUFaOFFUQUd0S2IxQXBJaVBIQURrQXZnS2lMeTFERnRZQ21CaURBbEREV05CMGVvN2ZwYU1PL2FFVlJSdjBBVEVRWkJJT0R5TUVBYzhKUWhDYkRSZ3pGRDRUQUVNQXU5WUJDZ0NzQU9rQW01STNBQndBWXh2T05uUitNaFhKQXhnS1F5eEwyK2trSmhNYmhRS0RCTWtTc3ZGMEFEOUJOUTZ1UUM3V3FTUUh3eEVBRUVJdTFoa2hBSDJ6NGlRUHd5SlBITldwZHlZQlJTcG5KQUx6b0JBRVZQUHNIMjBNeEEwQ0NFUUtSZ0FGeUF0RkFsTU53d2pFRFVRSlJBckVMdGFwTWc3RERaZ0pJdytUR3VrRUl3dkRGa01BcUF0REVNTU1CaGlvZStRQU8zTU1SQUFDcmduRUJTUFk5UTBGRG5iU0JvTUFCOE1TWXhrU3hBRUpBUElKQUFCOEZXTU9GdE1jL0hjWHd4aERBQzdEQXZPb3d3QWV3d0pkS0RLSEFBSERBQUxyRlVRVnd3QWJ3eXZ6cFdNV3Y4d0EvQUJwQXkrK2JjWURVS1BEMEtoREN3S21KMU1BQW1NQTUrVVp3eEFhZ3dpcEJSTC9lQURmdzZmREdPTUNHc09qazNsNkJ3T3BvNHNBRXNNT0d4TUFBNXNBYmNNT0FBdkRwME1KR2tNRHdnaXBuTklQQXdmSXFVTUdBT0dEQUFQekFCWERBQWNEQUFuREFHbVRBQnJEQUE3RENoakRqbkVXQXdBQll3QU9jd0F1VXlZQUJzTUFGOE1JS1FBTlVnQzZ3eTRBQThNQURxTXE4d0N5WWdBY0l3QUI4d3FwQUFYT0N4MFY0d0FIb3dCQ3d3RUtBR25EQUF1REFCM0RBQWpEQ2FrQUJkSUFicWNaM1FDWkNDa0FCZElBQUFGREFBZmpBQjJqQ0NrQUJxSUFDWU1BR3pNQWJTTUE1c09JQUFoakFBaERBQlREQkFrcEFBYlNBT09UQUFsREM2a096UHRuQUFkREFHNmtRRkFBVHdBS3d3d0FBME1BQ2JVRFB3QUhJd0FaZ3dBQ0U2Y0RBQW9qQUFwREFBb0RwL01Hd3dBSkl3QURFd0FRUXdnQUZFTUFFWE1BRDVNQURmTUFEY01BR1JNT0ZpTUFGVU1BYnFNV3V3SERBTUlBRTBNTEFHa3pFZ0RoVXdBQ1F3QUVXZ0FYZ3dVakFBYllBQmpEQlNZQmd6QmFBRUZOQUxjUUJ4VU1lZ0F3TW5nQnJBMElaZ0owS3hRSEJSRVBkMU4wWnpLUkp3YUlIQVpxTlQ0RHFRcThCd25nQUI0REF3dDJBWDU2VDFvY0tRTlhBaDFHQVRRR0MzdE94WU5hZ2tnQU1RQTVDUUFEQVFFQVd4TGpBSU9ZTkFFekFIN3RGUms2VGdsU0FGOE5BQWxZQVErUzFBQ0FRd1FvclFCaUFONGRBSjF3UHllVEFOVnp1UURYM0FJZUVNcDlleU1nWGlVQUVka0JrSml6S2x0YlZWQWFSTXFSQUFFQWh5US9TREV6NkJtZlZ3QjZBVEVzT0NsS0lSY0RPRjBFLzgzMkFGTnQ1QUJ5QW5rQ1J4R0NPczk0TmpYZEF3SU5HQm9uREJ3UEFMVzJBd0lDQWdBQUFBQUFBQVlEQlFNREFSclVBd0F0QUFBQUFnRUdCZ1lHQmdZRkJRVUZCUVVFQlFZSENBa0VCUVVGQlFRQUFBSUNBQUFBSWdDTkFKQUFsVDBBNmdDN0FOd0FwRVFBd2dDeUFLMEFxQUR1QUtZQTJnQ2pBT2NCQ0FFREFNY0FnUUJpQU5JQTFBRURBTjRBOGdDUUFLa0JNUURxQU44QTNBc0JDUTh5TzlyYTJ0cTh4dUxUMXRSSk9CMEJVZ0ZjTlUwQldnRnBBV2dCV3dGTVVVbExiaE1CVXhzTkVBczZQaE1PQUNjVUt5MHZNajVBUUVORFEwUkZGRVlHSkZkWFYxZFpXVmhaTDFwYlhWeGNJMk5uWjJab1p5cHNibloxZUhoNGVIaDRlbnA2ZW5wNmVucDZlbnA4ZkgxOGUySUFSUElBU1FDYUFIZ0FNZ0JtK0FDT0FGY0FWd0EzQW5idkFJc0FCZmo0QUdRQWsvSUFud0JQQUdJQVpQLy9zQUNGQUlVQWFRQldBTEVBSkFDMkFJTUNRQUpEQVB3QTV3RCtBUDRBNkFEL0FPa0E2UURvQU9ZQUx3SjdBVkVCUUFFK0FWUUJQZ0UrQVQ0Qk9RRTRBVGdCT0FFY0FWZ1hBREVRQ0FFQVV4OFNIZ3NkSGhZQWpnQ1dBS1lBVVFCcUlBSXhBSFlBYndDWEF4VURKeklESVVsR1R6RUFrUUpQQU1jQ1Z3S2tBTUFDbGdLV0FwWUNsZ0tXQXBZQ2l3S1dBcFlDbGdLV0FwWUNsZ0tWQXBVQ21BS2dBcGNDbGdLV0FwUUNsQUtVQXBRQ2tnS1ZBblVCMUFLWEFwOENsZ0tXQXBVZUFJRVRCUUQrRFFPZkFtRUNPaDhCVkJnOUF1SVpFak1iQVU0L0cxV1pBWHVzUkFGcFlRRUZBMEZQQVFZQW1URWVJSmR5QURGb0FIRUFOZ0NSQTV6TWsvQzJqR0lOd2pNV3lnSVpDYVhkZkRJTEJDczVkQUU3WW5RQnVnRGxob2lIaG9pR2lZcUtob3VPaklhTmtJNklqNHFRaXBHR2tvYVRocFNTbFlhV2hwZUttSWFaaHBxR200YWNpNTJRbm9xZmh1SUM0WFRwQXQ5MEFJcDBMSFNvQUlzQWRIUUVRd1JBQkVJRVJRUkRCRWtFUmdSQkJFY0VTUVJJQkVRRVJnUkpBSjV1ZEFDckE0OTBBTHh1QVExMEFORlpkSFFBMTNRQ0ZIUUEvbUowQVA0QklRRCtBUHdBL0FEOUFQd0RoR1owM0FTTUsyM0hBUDRBL0FEOEFQMEEvQ1IwZEFDUlluUUEvZ0NSQVNFQS9nQ1JBdlFBL2dDUkE0Um1kTndFakN0dHh5UjBBUDlpZEFFaEFQNEEvZ0Q4QVB3QS9RRDhBUDhBL0FEOEFQMEEvQU9FWm5UY0JJd3JiY2NrZEhRQWtXSjBBU0VBL2dDUkFQNEFrUUwwQVA0QWtRT0VablRjQkl3cmJjY2tkQUpMQVQ1MEFsSUJRWFFDVThsMGRBSmZkSFFEcGdMMEE2WURwZ09uQTZjRHB3T25BNFJtZE53RWpDdHR4eVIwZEFDUlluUUJJUU9tQUpFRHBnQ1JBdlFEcGdDUkE0Um1kTndFakN0dHh5UjBCRGgwQUpFRU9RQ1JEcFU1ZFNnQ0FEUjAzZ1YyQ3dBcmRBRUZBTTVpQ25SMEFGMWlBQVljT2dwMGRBQ1JDblFBWEFFSXdXWjBDblJtZEhRQWtXWjBDblJtZEVYZ0FGRjAzZ3AwZEVZMHRsVDJ1M1NPQVFUd3Njd2hqWlpLcmhZY0JTZkZwOVhOYktpVkRPRDJiK2NwZTQvWjE3bVFuYnR6emhhZVF0RTJHR2owSUROVGpSVVN5VHh4dy9SUEhXLyt2UzdkMU5mUnQ5ejlRUFpnNFg3UUZmaENua3ZnTlBJSXRPc0MyZVY2aFBhbm5aTkhsWjl4cndaWElNT2x1M2pTb1FTcTc4V0Vqd0xqdzFFTFNsRjFhQnZmendrNVpYN0FVdlF6alBRS2JEdVErc200d05PcDRBNkFkVnVSUzB0MXkvRFpwZzRSNm03Rk5qTTlIZ3ZXN0JpODh6YU1qT282bE04d3RCQmRqOExQNHlsdjN6Q1hQaGViTUtKYzA2Nm85c0Y3MW9GVy84Slh1ODZISmJ3RElENWx6dzVHV0xSL0xoVDBRcW5wMkpReE5aTmZjYkxJelB5K1l5cHFSbS9sQm1HbWV4KzgyK1Bpc3hVdW1TZUprQUxJVDZySmV6eE1IK0NUSm1RdHQ1dXdUVmJMM3B0bWpEVVF6bFNJdldpOFRsN25nMU5wdVJuMU5nNG4xNFFjKzNJaWw3T3drdk5Xb2dMU1BrbjNwaWhJRnl0eUlHbU1oT2UzbjF0V3N1TXk5QmRLeXFGNFozdjJTZ2dnVEw5S1Z2TVhQbkNiUmUrb091RkZQM0hlakJHL3c5Z3ZtZk5Zdmc2SnVXaWEybGNTU04xdUlqQmt0em9JYXpPSFBKWjdrS0hQejhtUldWZFczbEE4V0dGOWRRRjZCbTY3M2Jvb3YzQlVXRFUySk5jYWhSMjNHdGZIS0xPei92aVorclluWkZhSXpuWE82N0NZRUoxZlh1VFJwWmhZWmtLZTU0eGVvYWdrTkdMcytOVFpIRTByWDQ1L1h2UTJSR0FEWDZ2Y0F2ZHhJVUJWMjd3eEdtMnpqWm80WDNJTGdBbHJPRmhldVo2d3RzdmFJajR5TFk3cXFhd2xsaWFJY3J6MkcrYzN2c2NBbkNrQ3VNek1tWnZNZnU5bEx3VHZmWCszY1ZTeVBkTjlad2dEWmhmalJnTkpjTGlKNjdiOXh4OEpIc3dwcmJpRTN2OVVwaG90QVBJZ25YVklONUttTWMwcGlYaGM2Y0NoUG5OK01SaEc5YWR0ZHR0UVRUd1NJcGw4STQvai8vZDNzejEzMjZxVEJUcFBSTS9IZ2gza3pxRVhzOFpBazRFclFoTk84aHpyUTBETGtXTUEvTis5MXRuMk1kT0puV0MyRkNaZWhrUXJ3endiS09qaHZac2JNOTVRb2VMOXNrWXlNZjRzclZQVkpTZ2c3cE9MVXRyL245ZVQ5OW9lOW5MdEZScGpBOW9rVjJLajhoOWs1SGFDMG9pdlJEOFZ5WGtKODF0Y2Q0ZkhOWFBDZmxvSVFhc3hzdU8xOC80NmRSMmpndWwvVUlldDJHMGtSdm55T05NS2hIczZKMjZGRW9xU3FkK3JmWWplRUd3SFdWRHBYMWZoMWpCQmNLR01xUmVwanU5WTAwbURWSEMrWGRpai9qNDRyS2Z2ZmpHaW5OczFqTy8wRjNqQjgzWENESU5OL0hCODRheGxQKzNFL2tsa3RSbyt2bDNVL2FpeU1KYklvZEUxWFNzRG42VUF6SW9NdFVPYlkyK2svNGdZL2wrQWtaSjVTajJ2UXJreUxtM0ZveGpoRFgrMzFVWEJGZjlYckFIMzFmRnFvQm1ERVp2aHZ2cG5aODdOK29aRXU3VTlPL25uaytRV2ozeDh1eW9SYkVuZitPNVVNcjlpMG5IUDM4SUY1QXZ6ckJXOFlXQlVSMG1JQXpJdm5kUXE5TjN2L0p0bzNhUGpQWFVQbDhBU2RQUHlBcDdqRU5mOGJrN1ZNTTlvbDlYR21sQm1lRE11R3F0K1d6dUw2Q1hBeFhqSWhDUE01dkFDY2hnTUovOFhCR0xPL0QxaXNWdkdod3dISHIxRExhSTVtbjJKci9iMXBVRDkwdWNpRGFTOGNYTkR6Q1d2Tm1UL1BoUWU1ZThuVG5ubmt0OERzL1NJamliY3VtL2ZxRGhLb3B4QVk4QWtTclBuK0lHREVLT08rVTNYT1A2ZGpGczJINU45K29yaE9haGlRazVLbkVVV2ErQ3prVnpocDhiTUhSYmc4MXFoampYdUlLYkhqU0xTSUJLV3FvY2tHdEtpblkrejQvUmRCVUY2cGNjM0ptbmx4VmNOZ3JJNFNFektVWlN3Y0QyUUN5eHpLdmUrZ0FtZzZadVNSa3BQRmE2bWZUaHU3TEpOdTNINUs0MnVDcE52UEFzb2Vkb2xLVi9MSGUvZUorQmJhRzVNRzBOYVNHVlBSVW1ORk1GRlNTcFhFY1h3YlZoN1VFVE9aWnRvVk5SR09JYmJraWczTWNFdFI2OGNHMFJaQW9KZXZXWW83RGcvbFoxQ1F6YmxXZVV2VkhtcjhmWTROcWQ5SkppSC96RVgyNG1KdmlINjBmQXlGcjBBM2M0YkMxajN5WlU2MFZnSnhYbjhKZ0pYTFVJc2lCbm1LbU1Zeis3eUJRRkJ2cWIyZVludVc1OWpvWkJmNTYvd1h2V0lSNFI4d1RtVjgwaTFtWnkrUzQrQlVFUytoemprMHVYcEMvLy96L0lscUhaMW1vbnpsWHA4YUNmaEdLTXRpNzNGSTFLYkwxcTZJS080ZnVCdVo1OWdhZ2puNXhVNzltdU1wSFhnNlMrZStnRE0vVTlCS0xIYmw5bDZvOGN6UUtsNFJVa0pKaXFmdFFHMmkzQk1nL1RRbFVZRmtKRFlCT092QXVnWXV6WVNEblpiRERkL2FTZDl4ME9lNkYrYkpjSGZsOStncDZMNS9UZ0ErQmRGRm92YmZDclE0MHM1dk1Qdzg4NjZwTlg4enlGR2VGV2R4SXBQVnA5UmcxVVBPVkZiRlpydmFGcS9ZQXpIUWdxTVdwYWhNWWZxSHBtd1hmSEwxL2twWW1HdUhGd1Q1NW1RdTBkeWxmTnVxMk9xMGhUTUNQd3FmeG51QklQTFhmY2k0WTFBTnkrMUNVaXBReGxkL2l6VmgxNld5RzJRMENRUTlOcXRBbngxSENId0RqN3NZeE9TQjB3b3BaU25PenhRT2NFeG14clZURjJCa090aFZwR2Z1aGFHRUNmQ0pwSktwam5paFkreE9UMlFKeE42MSs5SzZRU3F0djJTaHI4MkkzamdKcnFCZzB3RUxGWlBqdkhwdnpUdGFKbkxLNlZiOTdZbjkzM2tvTy9zYU43ZnNqd05LenA0bDJsSlZ4Mm9yakNHekMvNFpMNHpDdmVyNmFRWXRDNXNkb3ljaHVGRTZ1Zk9pb2crVldpNVVEa2Jtdm10YWgvM2FBckVCSWkzOXM1SUxVbmxGTGdpbGNHdXo5Q1FzaEVZN2Z3Mm91b0lMQVlQVlQvZ3lBSXEzVEZBSXdWc2wra3RrUnovcUdmbkNER3JtNWdzbC9sOVFkdkNXR3NqUHozZFU3WHVxS2ZkVXJyLzZYSWdqcDRyZXk2QUpCbUNtVUpNaklUSFZkRmI1bTFwK2RMTUNMOHQ1NXpENDJjbWZ0bUxFSkMwRGEwNFlpUkNWVUJMTGE4RDA3MS9ONVVCTkJYRGgwTEZzbWhWLzVCNUV4T0I0ajNXVkcvUzNsZks1bytWNkVMSHZ5NlJSOW40YWMrVnNLNFZFNHlwaFB2VitrRzlGZWdUQkg0WlJYTDJIeXRVSENkdUphekIvS3lramZldFl4T1hUTHdzMjY3YUdPZCtJK0poS1AvLytWblhtUzkwT0QvanZMY1Z1MGFzeXFjdVlOMW1TYjZYVGxDa3F2MXZpZ1pQSVl3TkYvenBXY1QxR1IvNmFFSVJqa2gweWhnNExYSmZhR29iWUpUWTRKSTU4S2lBS2dtbWdBS1dkbDVuWUNlTHFhdlJKR1FOdVl1WnRaRkd4K0lrSTR3NE5TMnh3YmV0Tk11bk9qQnUvaG1LQ0kvdzd0ZmlpeVVkLy80cmJUZVd0NGl6Qlk4WXZHSU42dnlLWW1QLzhYOHdIS0NlTitXUmNLTTcwK3RYS05HeWV2VTlIMkRnNUJzbGpuVGY4WWJzSjFUbU1zNzRDZTJYbEhpc2xlZ3VoeWVnNDRyUU9IWnV3LzZIVGtobm51cksyZDYycTZ5UzcyMTBTc0FJYVIralhNUUErc3Zrckxwc1VZK0YzMFV3ODl1T2RHQVI2dm80RklNRTBFZlZWZUhUdTZlS2ljZmhTcU9lWEpoYmZ0Y2QwOHNXRW5OVUwxQzlmbnByVGdkODNJTXV0OG9uVlVGMGh2cXpaZkhkdVBqYmp3RVhJY29ZbXkrUDZ0Y0paSG1lT3Y2VnJ2RWRrSERKZWNqSHVIZVdBTmU3OVZHNjYycVRqQS9IQ3Z1bVZ2M3FMK0xyT2NwcUdwczJaR3dRZEZKN1BVNGl1eVJsQnJ3Zk8reG5QeXI0N3MyY1hWYld6QXl6bkRpQkdqQ00za3N4ampxTTYyR0U5QzhmNVUzOGtCM1ZqdGFiS3AvblJkdk1FU1BHREc5MGJXUkxBdDFRazVEeUx1YXpSUjFZemRDMWMraFpYdkFXVjh4QTcyUzRBOEI2N3ZqVmhiYmEzTU1vcDI5M0ZlRVhwZTd6SXRNV3JKRy9MT0g5QnlPWG1Zbk5KZmptZnVYOUticnBnTE9iYTRuWitmbDhHYmR2L2lodis2d0ZHS0hDWXJWd21oRkMwSjNWMmJuMnRJQjF3Q2MxQ1NUM2QzWDJPeXhoZ3VYY3M0c202NzlVbmd6b2Z1U2VCZXdNRkpib0lRSGJVaC9tMkpoVzJoRzlESXZHMnQ3eVpJektCVHo5d0J0bk5DKzJwQ1JZaFNJdVExajh4c3o1VnZxbnlVSXRodnVveXl1N2ZOSXJnL0tRVVZtR1FhcWtxWmsvVng1YjMzL2dzRXM4eVg3U0MxSitOVjRpY3o2YnZJRTdDNUc2TWNCYUk4clZnNTZxNVFCSld4bi84N1Exc1BLNCtzUWE4ZkxVNWdYbzRwYWFxNGNPY1E0d1IwVkJIUEdqS2grVWxQQ2JBMW5MWHlFVVg0NXFaOEo3L0xuNEZQSkUyVGR6RDBaOE1MU05RaXlrTU1tU3lPQ2lGZnk4NFJxNjBlbVlCMnZEMDlLall3c29JcGVEY0JEVEVsQmJYeE5ENzJ5aGQ5cEMvMUNNaWQvNUhVTXZBTDI3T3RjSUpEek5LcFJQTnFQT3B5dDJhUEd6OVFXSXM5aFE5TGlYNXM4bTloalRVdS9mN015SWF0ampkK3RTZlEzdWZaeFBwbUpoVGFCdFp0S0xVY2ZPQ1VxQUR1TytRb0g4Qjl2NlUrUDBIVjFHTFFtdG9ORlRiM3M3NGl2WmdqRVMwcWZLKzhSZEdnQmJjQ01TeThlQnZoOTgrZXQxS0lGcVNlMUtRUHlYVUxCTVRzSVlueXNJd2laQkpZZEkyMHZzZVYrd3VKa2NxR2VtZWhLamFBYjlMNTd4Wm0zZzJ6WDBiWjJ4ay9mVStiQ283VGxuYlc3SnVGMVlkVVJvLzJHdzdWY2xERzFXN0xPdGFzMkxYNHVwaWZaLzIzcnpwc25ZL0FMZlJncmNXUDVoWW1WOVZ4Vk9RQTFmWnZwOUYyVU5VKzdkN3hSeVZtNXdpTHAzLzBkbFY3dmR3MVBNaVpyYkRBWXpJVnFFalJZMllVMDNzSmhQbmx3SVBjWlVHNWx0TDZTOFhDeFUxZVlTNWNqcjM0dmVCbVhBdnk3eU40WmpBcklHMGRmRC81VXBCTmxYMVpQb3hKT3d5cVJpM3dRV3RPemQ0b05LaDBMa29UbThjd3FnSWZLaHFxR09od283MUkrelhuTWVtVHYyQjJBVXpBQld5Rnp0R2dHVUxqRER6V1l3SlVWQlRqS0NuNUsyUUdNSzFDUVQ3U3p6aU9qbytCaEFtcUJqenVjM3hZeW0yZWVkR2VPSVJKVnlUd0R3MzdpQ01lNGc1VmJuc2I1WkJkeE9Bbk1UN0hVNERIcHhXR3VRN0dlaVkzMENwYnZ6c3M1NSs1S20xWXNiRDVlYTNOSTlRTllJWG9sNWFwZ1N1OWRaOGY4eFM1ZHRIcGlkbzVCY2xEdUxXWTRsaGlrMHRiSmEwN3lKaEgwQk95RXV0L0dSYllUUzZSZmlUWVdHTUNrTnBmU0hpN0h2ZGlUZ2xFVkhLWlhhVmhlekg0a2tYaUl2S29wWUFsUHVzZnRwRTRhNUlad3Z3MXgvZUx2b0RJaC96cG85RmlRSW5zVGIyU0FrS0hWNDJYWUJqcEpEZzQzNzRYaVZiM3dzNHFNMHM5ZVNRNUh6c01VNE9aSkt1b3BGakJNK2RBWkVsOFJVTXg1dVUyTjQ4NktyMTQxdFZzR1FmR2pPUllNQ0pBTXN4RUxlTlQ0Um1XalJjcGRUR0J3Y3g2WE45ZHJXcVBtSnpjckdySDQrRFJjNytuMXcza1Bad3UwQmtOcjZoUXJxZ283SlRCOUE1a2RKL0g3UDRjV0JNd3NtdWl4QXpKQjN5clFwbkdJcTkwbHhBWEx6RENkbjFMUGlic1J0N3JITmpnUUJrbFJnUFo4dlRialhkZ1hyVFdRc0s1TWRyWFhRVlBwMFJpbnEzZnJ6WktKMHFENlFoYzQwVnpBcmFVWGxvYjFndmtoSzN2cG1IZ0k2RlJsUVpOeDZlUnFrcDB6eTRBUWxYODEzZkFQdEwzak1SYWl0R0ZGam8wem1FcmxvQytoK1lZZFZRNms0Ri9lcHhBb0YwQm1xRW9LTlR0Nmo0dlFaTlEyQm9xRjlWajUzVE9Jb05tRGl1OVhwMTVSa0lnUUlHY29McGZvSWJlbnpwR1VBdHFGSnA1VytMTG54MzhqSGVFQ1RKL25hdktZMU5XZk4wc1kxVDgvcEI4a0lIM0RVM0RYK3U2VzNZd3B5cEJNWU9oYlN4R2pxODRSWjg0ZldKb3c4cHlIcW40Uy85SjE1RWNDTXNYcXJmd3lkOW1oaXUzK3JFbzlwUHBvSmtkWnFIanJhNE52ekZ3dVRoTkt5Nmhhby9TbEx3M1pBRFVjVXAzdzNTUlZmVzJyaGw4MHpPZ1RZbktFMEhzMnFwMUo2SDN4cVBxSWt2VURSTUZEWXlSYnNGSTNNOU1FeW92UGs4cmx3Ny8wYTgxY0RWTG1Cc1IyemUycEJ1S2IyM2ZiZVpDMHVYb0l2RHBwZlR3SUR4azFPcTJkR2VzR2Mrb0pYV0pMR2tPaGEzQ1grRFVuemdBcDlIR0g5UnNQWk42M0huNFJNQTVlU1ZoUEhPKzlSY1JiL0lPZ3RXMzFWMVE1SVBHdG94UGpDK01FSmJWbElNWUFEZDlhSFlXVUlRS29wdVBPSG1vcVNrdWJuQUtuemdLSHFnSU9mVzVSZEFnb3RONkJOK08yWllIa3VlbUxudlE4VTlUSFZyUzFSdExtS2JjQzdQZWVEc1l6bnZxemVnNlZDTndtcjBZeXgxd25ManlUODRCWnozRUp5Q3B0RDN5ZXVlQXlEV0lzMEwycXMvVlEzSFV5cWZyamEwVjFMZER6cUFpa2VXdVY0c2M3UkxJQjY5akVJQmpDa3laZWRvVUhxQ3JPdlNoVnp5ZDczT2RySlcwaFBPdVF2MnFPb0hEYzl4VmI2WXU2dXEzWHFwMlphSDQ2QTdsemV2YnhRRW1mcnp2QVlTSnVaNFdEazFIejNRWDFMVmRpVUswRXZsQUdBWWxHM01kMzByN2RjUE42M3lxQkNJajI1cHJwdlpQMG5JNCtFZ1dvRkc5NVY1OTZDdXJYcEtSQkdSalFsSEN2eTVJYi9pVzhuWkpXd3JFVDNtZ2Q2bUVoZlA0S0N1YUxqb3BXczdoK01kWEZkSXY4ZEhRSmdnMXhpMWVZcUIwdURZanh3Vm1yaTBTdjVYS3V0L29ucWFwQytGUWlDMkMxbHZZSjlNVmNvNnlEWXNTM0FBTlVmTXR2dGJZSTJoZndaYXRpU3Nub1VlTVpkMzRHVmprTU1LQStYbmpKcFhnUlcyU0hUWnBsVm93UG1Kc3ZYeTZ3M2NmTzFBSzJkdnRaRUtUa0MvVFk5TEZpS0hDRzBEbnJNUWRHbTJsemxCSE05aUVZeW5IMlVjVk1oVUVqc2Mwb0RCVGdvMlpTUTFnemtBSGVXZUJYWUZqWUx1dWY4eXpUQ3k3L1JGUjgxV0RqWE1icTJCT0g1ZFVSbnhvNm9pdm14TDNjS3pLSW5sWmtEMzFudnBIQjlLazdHZmNmRTF0KzFWNjRiOUx0Z2VKR2xwUkZ4UUNBcVdKNURvWTc3c2tpOGdzT0VPcjJ1eXdaYW9PL05HYTBYMHkxcE5RSEJpM2IyU1VHTnBjWnhEVDdyTGJCZjFGU25ROGd1eEdXM1crMzZCVzBnQmplNERPejZCYTZTVmsweGlLZ3QrcTJKT0Z5cjRTWWZudStJYzFRWllJdXdIQnJnenI2VXZPY1NDelBUT283RDZJQzRJU2VTN3prbDRoKzJWb2VIcG5HL3VXUjMreXNOZ1BjT0lYUWJ2MG40bXIzQndRY2RLSnhnUFNleXVQL3oxSmpnNGU5blV2b1hlZ3FRVklFMzBFSHg1R0h2K0ZBVlVOVG93WURKZ3lGaGY1SXZsWW1FcVJpZjYrV04xTWtFSm1EY1FJVHg5RlgyM2E0bXh5MUFRUnNPSE8vK2VJbVg5bDhFTUpJM29QV3pWWHhTT2VIVTFkVVdZcjJ1QUE3QU1iK3ZBRVpTYlUzcW9iOWliQ3lYZXlwRU1wWjY4NjNvNlFQcWxxR0haa3VXQUJTVFZOZDRjT2g5aHYzcUVwU3gyWnkvREpNUDZjSXRFbWlCSjVQRnFRbkRFSXQzTnJBM0NPbE9TZ3o0M0Q3Z3BORk5KNU1CaDRvRnpoRFBpZ2xDMnlwc05VNElTeXdZMmVya3liMU5DM1FoL0lmV2owZURnWkk0L2xuOFdQZkJzVDNtZVRqcTFVcXQxRTdabC9xZnRxa3g2YU05S3VlTUNla1NuTXJjSGoxQ3FUV1d6RXpQc1pHY0RlM1VlNFdzK1hGWVZ4TmJPRkY4ZXprdlFHUjZaT3RPTFUybFFFbk1CU3R4NDd2RTZQYjdBWU1CUmoyT09mWlhmaXNqSm5wVGZTTmpvNnNaNnFTdk54Wk5tRGVTN0drM3lZeUNrMUh0S04yVW5oTUlqT1hVekFxRHY5MGx4OU8vcS9BVDFaTW5pdDVYUWU5d21ReG5FL1dTSDBDcVo5LzJIeStTZm1wZWc4UndzSEk1WjhrQzhIMjkzbS9MSFZWTS9CQTdIYVRKWWc1RW5rN00veFdwcTAxOTJBQ2ZCYWkyTEEvcXJDakNyNkRoMUJJTXpNWElOQm1YOTZNSjVIbjJueGxuL1JYUEZod0h4VW1TVjBFVjJWMGptODYvZHh4dVlTVTFXN3NWa0ViTjlFemtHMFFGd1BoeUhLeWIzdCtGajVXb1VVVEVyY2F6RS9ONkVXNkx2cDBkLy9TRFBqN0VWOVVkSk4rQW1uZjNXd2szQTBTbEo5WjAweXZYWjduM3o3MEc0N0hmc293OFdxMUpYY2Z3bkErWXhhNW1Gc2dWNDY0S0tQNFQzMXdxSWd6RlBkM2VDZTNqNW9yeTVmQkYyaGdDRnlWRnJMekk5ZWV0Tlh2TTdvUXF5RmdEbzRDVHAvaERWOU5NWDlKREhRL255SFRMdlpMTkxGNmZ0bjJPeGpHbTgrUHFPd2h4blBIV2lwa0UvOHdidHlyaTgwU3I3cE1Oa1FHTWZvNFpZSzlPY0NDNEVTVkZGYkxNSXZseFNvUnFXaWUwd3hxbkxmY0xTWE1TcE1NUUVKWURWT2JZc1hJUU52NFRHTndqcTFrdlQxVU9raWNUckczSWFCWjNYZFNjUzN1OHNnZVpQVnBPTGtiaUY5NDBGamJDZU5SSU5OdkRiZDAxRVBCclRDUHBtMTJtNDN6ZTFiQkI1OUlhNk92aG51ci9OdngzSXh3U1dvbCszSDJxZkNKUjhkZjZhUWY0djZXaU9OeGtLK0lxVDRwS1FyWksvTHBsZ0RJL1BKWmJPZXA4ZHRiVjdvQ3I2Q2dmcFdhOE5jek9rUHg4MWlTSGJzTmhWU0pCT3RyTElNckwzMUxLOVRxSHFBYkFIZTBSTG1tVjgwNmtSTERMTkVoVUVKZm05dTBzeHBrTDkzWmdkNnJ3K3RxQmZUTWk1OXhxWEhMWFNId1NiU0JsMEVLMCtsb0VDT1B0cmwrL25zYUZlMTk3ZGk0eVVnb2U0aktvQUpEWGM2REdEanJRT29GRFdaSjlIWHd0OHhEclFQKzdhUndXS1dJMUdGOHM4TzRLenhXQkJjd25sM3ZubDFPZXozb2g2RWExdmpSNy96N0REVHJGdHFVMlcvS0FFekF1WEROWjdNWTczTUYyMTZkemRTYldtVXA0bGNtN2tlSmZXYU1IZ3V0OXg1QzltajY2WjBsSit5aHNqVnZ5aVdyZmsxbHpQT1RkaEcxNVk3Z1FsWHRhY3ZJN3F2L1hOU3NjRHdxa2d3SFQvZ1VzRDV5QjdMZFJSdkp4UUdZSU5uOWhUcG9kS0ZWU1RQcnRHdnlRdytIbFJGWElrb2RFckFHdTlJeTFZcGZTUGMzamtGaDVDWDNsUHh2N2FxakUvSkFmVElwRWpHYi9IN01PMGUydnNWaVNXMXFhL0xtaTQvbjRERUkzZzdsWXJjYW5zcERmRXBLa2RWMU9qU0xPeTBCQ1VxVm9FQ2FCNTV2czA2clhsNGpxbUxzUHNGTS83dllKMHZyQmhEQ20vMDBBL0g4MWwxdWVrSi82TG1sM0hiOStOS2lMcUFUSm1EcHl6ZllaRkh1bUVqQzY2MkwwQndreGk3RTlVNGNRQTBYTVZEdU1ZQUllTE1QZ1FhTVZPZDhmbXQ1U2ZsRklmdUJvc3plQXc3b3c1Z1hQRTJZL3lCYy83akV4QVJVZi9CeElIUUJGNVNuM2k2MXc0ejV4SmRDeU8xRjFYMyszYXgrSlN2TWVaN1M2UVNLcDFGcC9zall6NlorVmdDWnppYkdlRW91anJ5Zk11bEg3UmFpNWtBZnQ5ZWJjVzUwRHlKcjJ1bzJ6OTdtVFdJdTQ1WXNTbk5TTXJyTlV1RzFYc1lCdEQ5VERZelFmZktCODd2V2JrTTRFYlBBRmdvQlY0R1FTK3Z0RkRVcU9GQW9pMW5UdG1JT3ZnMzhONGhUMlNuOHI4Y2xtQkNYc3BCbE1CWVRucnFGSkdCVDN3Wk96QXlKRHJlOWRISDcreDdxYWFLRE9CNFVRQUxENWVjUzBERTRvYnViUUVpdUpaMEVwQlZwTHVZY2NlOEFhNFBZZC9WNERMREFKQllLUVBDV1RjckVhWjVIWWJKaTExR2Q2aGpHb20xaWkxOFZIWW5HMjhOS3BrejJVS1ZQeGxoWVNwOHVacjM2N2lPbW95N3pzeGVoVzl3emN5MnpHMGE4MFBCTUNSUU1iMzJobmFIZU9SOGZuTkR6WmhhTlloa09kRHNCVVozbG9ETWExWVAwdVMwY2pVUDNiLzZEQmxxbVpPZU5BQkRzTGw1Qkk1UUp1cHM4dXhBdVdKZGtVQi9wTzZaYXg2dHNnN2ZONW1qakRnTUduZ08rRFBjS3FpSElEYkZJR3VkeHRQVEl5RGk5U0ZNS0JEY2ZkR1FSdjQxcTFBcW14Z2tWZkpNblA4dy9CYzdOOS9UUjZDN21HT2JGcUZrSUVvbThzS2kyeFlxSkxUQ0hLN2N4emFadnFPRG8yMmMzd2lzQkNQNEhlQWdjUmJOUEFzQmtOUmhTbUQ0OGRIdXBkQlJ3NG1JdnRTNW9lRjZ6ZVQxS01DeWhNbm1ocGtGQUdXbkdzY29Oa3d2UThaTTVsRS92Z1RIRllMOTlPdU54ZEZCeFRFRGQ1djJxTFI4eTlXa1hzV2dHNmtaTm5kRkcrcE8vVUFrT0NpcHFJaEwzaHE3Y1JTZHJDcTdZaFVzVG9jRWNuYUZhNm5Wa2huU2VSWVVBMVlPMHo1aXRGOVNseTNWbHhZRHcyMzlUSkpINmYzRVVmWU81bGI3YmNGY3o4QnA3T284UW1uc1VIT3ovZmFnVlVCdEtFdzFpVDg4aithS2t2OGNzY0tOa014allyODM0NEQxa0ZvWjcvdGQxVzZMQ05ZTjU5NDMwMXRVR1JtRmpBemVSZzV2eW9NMUY2K2JKWi9RNTRqTi9rOFNGZDNEeFBUWWFBVXNpdnNCZmdUbjdNeDhIMlNwUHQ0R09kWVJuRUpPSDZqSE0ycDZTZ0IwZ3pJUnE2Zkh4R01tU21xYVBDbWxmd3hpdWxvYVZJaXRMR044d2llMkNEV2hrekxvQ0pjT0RoN0tJT0FxYkhFdlhkVXhhUzRUVFRzMDdDbHpqLzZHbVZzOWtpWkRlck14RW5oVUI2UVFQbGNmcWtHOTg4MlJxSG9MaUhHQm9IZlF1WElzQUc4R1RBdGFvMktWd1JudnZhbThqbzFlMzEyR1FBS1dFYTRzVVZFQU1HNEc2Y2tjT05Ed1JjZzFlMkQzK29oWGdZNFVBV0Y4d0hLUU1yU256Q2dmRnBzeGgrYUhYTUd0UFFyb1Fhc1JZNFU2VWRHMHJ6MVZqYmthME1la09HUlpRRXZxUUZseHNlRm9yOHpXRmdIZWszdjI5K1dxTjZnYUs1Z1pPVE9NWnpwUUlDMTIwMUxrTUNYaWxkM3ZXWFNjNVVYOXhjRllmYlJQekdGYTFGRGNQZlBCL2pVRXEvRmVHdDQxOUNJM1ltQmxWb0hzYTRLZGN3UVA1WlN3SEhoRko3L1BoL1JhcC80dm1HOTFlRHdQUDBsRGZDRFJDTHN6VHFmek03MXhwbWlLaTJId1M0V2xxdkdOd3R2d0Y1RHFwbjZLVHE4YXgwMFVNUGt4RGNackVFRXNJdkhpVVhYRXBoZGI0R0I0RnltbFB3Qno0R3BlcnFxNXBXN1RRNi95TlJoVzhWVDVOaHVQMHVkbHhvNGdJTHE1WnhBWms4WkdoM2c0Q3F4SmxQS1k3QVF4dXBmVWNWcFdUNVZJdHAxKzMwVXFveVA0d1dzUm8zb2xSUmdrV1paMlpONlZDM09aRmVYQjhOYm5VclNkaWtOcHREMVFpR3VLa3I4RW1TUi9BSzlSdytGRjNzNXV3dVBidkhHaVBlRk9WaWx0TUs3QVVhT3NxOSt4OWNuZGszaUpFRTVMS1pSbFdKYktPWndlUk96bVBOVlBrakUzSy9UeUE1N1JzNjhUa1ozTVI4YWtLcG03Y0ZqbmpQZC9EZGtXamdZb0tIU3I1V3U1c3NvQllVNGFjUnM1ZzJESHhVbWRxOFZYT1hSYnVuRDhRTjBMaGdrc3NnYWhjZG9Zc052dVhHVUsvS1hELzdvRmIrVkdkaHFJbjAydmV1TTViTHVkSk9jMkt5MEdNYUc0Vy94V0J4SUpjTDd5bGlKT1hPcHgwQWtCcVVnemxEY3ptTFQ0aUlMWER4eHRSUjFvWmEySldGZ2lBYjQzb2JySm5HL1RaQzJLU0syd3FPelJaVFhhdlpaRk1iMWYzYlh2VmFOYUs4Mjh3OVRPNjEwZ2s4Sk5mM2dNZkVUelhYc2JjdlJHQ0c5SldRWjYrY0RQcWM0NDY2WW8yUmNLSCtQSUxlS09xdG5sYkluUjNNbUJlR0czRkgxMHl6a3lidXFFQzJIU1F3cEEwQW43ZDkrNzNCa0RVVG0zMGJabW9QL1JHYmdGTitHckNPZkFEZ3FyMFdiSTFhMW9rcEZtczhpSFl3OWhtMHpVdmxFTWl2QlJ4TW9kcmJKSis5L3AzalVkUVE5QkN0UWR4bk9HclQ1ZHpSVW13MDU5My9tYlJTZEJnMG5SdlJaTTUvRTE2bTdaSG1ERXRXaHd2ZmRaQ1o4SjhNMTJXMHlSTXN6WGFtV2ZRVHdJWjRheVlrdHJuc2NRdVdyOGlkcDNQalQyZUYvam10ZGhJZmNwTW5iK0lmWlkyRmViVzZVWS9BSzNqUDR1M1R1NHpFNHFsblFnTEZiTTE5RUJJc05mN0toamRicVEvRDZ5aURiK05sRWkyU0tEK2l2WFZVSzhpYjBvQm8zNjZnWGtSOFp4R2pwSklEY0VnWlBhOVRjWWUwVEliaVBsL3JQVVFEdTNYQko5WC9HTnEzRkFVc0tzbGw1N0R6YUdNcmpjVCtnY3RwKzlNTFlYQ3Erc3FQODFlVlEwcjlsdCtnY1FmWmJBQ1JiRWp2bE1za3p0Wkc4Z2JDOFFuOXR0MjZRN3k3bkRyYlpxL0xFejdrUjZKYzZwZzNOOXJWWDhZNU1KckdsTUw5cDlsVTRqYlRrS3FDdmVlWlVKakhCMDNtMktSS1IyVHl0b0ZrVFhPTGc3a2VVMXMxbHJQTVFKcG9PS0x1QUFDK3kxSGxKdWNVNnlzQjVoc1hodlNQUExxNUo3SnRucUhLWjR2WWpDNFZ5ODE1M1FZKzY3ODB4RHVHQVJzR2JPczFXcXpIMFFTNzY1cm5TS0ViYktsa084b0kvVkR3VWQwaXMxM3RLcHFJTHUxbURKRk55L2lKQVdjdkRnanh2dXNJVCtQR3ozU1QvSjlyOU10ZmQwanBhR2VpTFlJcVhjN0RpSFNTOFRjakZWa3NpNjZQRWt4VzF6NnVqYkxMVUdOTlluek9XcEg4QlpHSzRiQ0s3aVIrTWJJdjhuY0RBejF1NFN0TjN2VFR6ZXdyOUlRams5d3hGeG4rNk4xZGRLczB2ZmZKaVMwOE4zYTRHMVNWcmxaOTdRL00rOEc5ZmU1QVA2ZDkvUXE0V1JuT1JWaG9mUElLRWRDcjNsbHNwVWZFMG9LSUlZb0J5QlJQaCtiWDFITFMzSldHSlJoSXZFMWFXNE5UZDhlUGk0WitrWGIrWjhzbllmU05jcWlqaEFnVnN4NFJDTTU0Y1hVaVlramVCbW1DNGFqT0hyQ2hvRUxzY0pKQzcrOWpqTWp3NUJhZ1pLbGdSTWlTTll6N2g3dnZaSW9RcWJ0UW1zcGMwY1VrMUcvNzNpWHRTcFJPbDV3dExnUWkwbVcyRXg4aTNXVUxoY2dneDZFMUxNVkhVc2RjOUdISTFQSDNVMktvMFB5R2RuOUtkVk9MbTdGUEJ1aTBpOWEwSHBBNjBNc2V3VkU0ejhDQXQ1ZDQwMUd2NnpYbElUNVliaXQxVklBMEZDczd3dHZZcmVydTFmVXlXM29MQVovK2FUblpyT2NZUk5WQThzcG9SdGxSb1dmbHNSQ2xGY2d6a3FpSE9yZjAvU1Z3K0VwVmFGbEowZzRLeHExTU1PbWlRZHBNTnB0ZThsTU1RcW02Y0lGWGxuR2JmSmxseXNLRGkrMEpKTW90a3FnSXhPU1FnVTlkbi9sV2tlVmY4blVtM2l3WDJObDNXRHc5aTZBVUszdkJBYlpacmNKcERRL042NEFWd2pUMDdKZWYzMEdTU210TnUyV2xXN1lveVcyRmxXZlpGUVV3azg2N0VkTFlLazlWRzZKZ0VuQmlCeGtZN0xNbzRZTFFKSmxBbzlsL29UdkprU0FSREYvWHR5QXpNOE8ydDNlVC9pWGE2d0ROM1dld05tUUhkUGZzeENoVS9LdExHMk1uOGk0WnFLZFNsSWFCWmFkeEptUnpWUy9vNHlBNjVSVFNWaXE2MG9hMzk1THF3MHB6WTRTaXB3RTBTWFhzS1YrR1pyYUdTa3IvUlcwOHdQUnZxdlNVa1lCTUE5bFB4NG0yNGF6K0lIbUNiWEErMGZheFRSRTl3dUdlTzA2RElYYTZRbEtKM3B1SXlpdUFWZlByNzM2dnpvMnBCaXJTK1Z4ZWwzVE1tM0pLaHo5bzJab1J2YUZWcElreWtiMEhjbTRvSEZCTWNOU05qNy80R0p0NDNvZ29uWTJWZzRuc0RRSVd4QWNvcnBYQUN6Z0JxUVBqWXNFL1ZVcFhwd05NYW5FcnU0TndNQ0ZQa1h2TW9xdm9lTE4zcXl1L04xZVdFSHR0TUQ2NXYxOWwvMGtIMm1SMzVpdi9GSSt5am9ISjlnUE16NjdhZjNNcS9Cb1dYcXUzcnBoaVdNWFZrbW5QU0VrcEdwVUkyaDFNVGhpZGVHRkVPSzZZWkhQd1l6TUJ2cE5DNytaSHhQYjdlcGZlZkd5SUI0SnpPOURUTkVZbkRMVlZIZFF5dk9FVmVmcms2VXY1a1RRWVZZV1dkcXJkY0lsN3lsand3SVdkZlEveSsyUUIzZVIvcXhZT2J1WXlCNGdUYm8yaW40UHphclUxc085bkVUa21qOS9Bb3hEQStKTTNHTXFRdEpSNGp0ZHVIdG5vQ0x4ZDFnUVVzY0hSQi9Nb1JZSUVzUDJwRFo5S3ZIZ3RsazFpVGJXV2JIaG9od0ZFWVg3eTUxZlVWMm51VW1ub1VjcW5XSVFBQWdsOUxUVlgrQmMwUUdORWhDaHhIUjRZamZFNTFQVWRHZnNTRkU2Y2s3QkwzL2hUZjlqTHE0RzFJYWZJTnhPTEtlQXRPN3F1dWxZdkg1WU9CYyt6WDdDck1nV25XNDcvamZSc1duSmpZWW9FN3hNZldWMkhOMml5SXFMSSc7XG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKFtbODIxNyxcImFwb3N0cm9waGVcIl0sWzgyNjAsXCJmcmFjdGlvbiBzbGFzaFwiXSxbMTI1MzksXCJtaWRkbGUgZG90XCJdXSk7XG5jb25zdCBOU01fTUFYID0gNDtcblxuZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XHJcblx0XHJcblx0Ly8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcclxuXHRsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XHJcblx0bGV0IHRvdGFsID0gMTtcclxuXHRsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xyXG5cdFx0YWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXHJcblx0bGV0IHNraXAgPSB1MTYoKTtcclxuXHRsZXQgcG9zX3BheWxvYWQgPSBwb3M7XHJcblx0cG9zICs9IHNraXA7XHJcblxyXG5cdGxldCByZWFkX3dpZHRoID0gMDtcclxuXHRsZXQgcmVhZF9idWZmZXIgPSAwOyBcclxuXHRmdW5jdGlvbiByZWFkX2JpdCgpIHtcclxuXHRcdGlmIChyZWFkX3dpZHRoID09IDApIHtcclxuXHRcdFx0Ly8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcclxuXHRcdFx0Ly8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcclxuXHRcdFx0cmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XHJcblx0XHRcdHJlYWRfd2lkdGggPSA4O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IE4gPSAzMTtcclxuXHRjb25zdCBGVUxMID0gMioqTjtcclxuXHRjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcclxuXHRjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xyXG5cdGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcclxuXHJcblx0Ly8gZmlsbCByZWdpc3RlclxyXG5cdGxldCByZWdpc3RlciA9IDA7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcclxuXHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbG93ID0gMDtcclxuXHRsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcclxuXHRcdHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxyXG5cdFx0XHRsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuXHRcdFx0aWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcclxuXHRcdFx0XHRlbmQgPSBtaWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhcnQgPSBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChzdGFydCA9PSAwKSBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXHJcblx0XHRzeW1ib2xzLnB1c2goc3RhcnQpO1xyXG5cdFx0bGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAgIC8gdG90YWwpO1xyXG5cdFx0bGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0KzFdIC8gdG90YWwpIC0gMTtcclxuXHRcdHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpICYgTUFTSztcclxuXHRcdFx0YiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoYSAmIH5iICYgUVJUUikge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgXiBIQUxGO1xyXG5cdFx0XHRiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcclxuXHRcdH1cclxuXHRcdGxvdyA9IGE7XHJcblx0XHRyYW5nZSA9IDEgKyBiIC0gYTtcclxuXHR9XHJcblx0bGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XHJcblx0cmV0dXJuIHN5bWJvbHMubWFwKHggPT4geyAvLyBpbmRleCBpbnRvIHBheWxvYWRcclxuXHRcdHN3aXRjaCAoeCAtIG9mZnNldCkge1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcclxuXHRcdH1cclxuXHR9KTtcclxufVx0XHJcblxyXG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXHJcbmZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0cmV0dXJuICgpID0+IHZbcG9zKytdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKHMpIHtcclxuXHRyZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKHVuc2FmZV9hdG9iKHMpKSk7XHJcbn1cclxuXHJcbi8vIHVuc2FmZSBpbiB0aGUgc2Vuc2U6XHJcbi8vIGV4cGVjdGVkIHdlbGwtZm9ybWVkIEJhc2U2NCB3L28gcGFkZGluZyBcclxuLy8gMjAyMjA5MjI6IGFkZGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy80XHJcbmZ1bmN0aW9uIHVuc2FmZV9hdG9iKHMpIHtcclxuXHRsZXQgbG9va3VwID0gW107XHJcblx0Wy4uLidBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10uZm9yRWFjaCgoYywgaSkgPT4gbG9va3VwW2MuY2hhckNvZGVBdCgwKV0gPSBpKTtcclxuXHRsZXQgbiA9IHMubGVuZ3RoO1xyXG5cdGxldCByZXQgPSBuZXcgVWludDhBcnJheSgoNiAqIG4pID4+IDMpO1xyXG5cdGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCB3aWR0aCA9IDAsIGNhcnJ5ID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0Y2FycnkgPSAoY2FycnkgPDwgNikgfCBsb29rdXBbcy5jaGFyQ29kZUF0KGkpXTtcclxuXHRcdHdpZHRoICs9IDY7XHJcblx0XHRpZiAod2lkdGggPj0gOCkge1xyXG5cdFx0XHRyZXRbcG9zKytdID0gKGNhcnJ5ID4+ICh3aWR0aCAtPSA4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXHJcbmZ1bmN0aW9uIHNpZ25lZChpKSB7IFxyXG5cdHJldHVybiAoaSAmIDEpID8gKH5pID4+IDEpIDogKGkgPj4gMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcclxuXHRsZXQgdiA9IEFycmF5KG4pO1xyXG5cdGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKykgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIFsxMjNdWzVdID0+IFswIDNdIFsxIDFdIFswIDBdXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkKG5leHQsIHByZXYgPSAwKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQoKTtcclxuXHRcdGxldCBuID0gbmV4dCgpO1xyXG5cdFx0aWYgKCFuKSBicmVhaztcclxuXHRcdHByZXYgKz0geDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdHJldC5wdXNoKHByZXYgKyBpKTtcclxuXHRcdH1cclxuXHRcdHByZXYgKz0gbiArIDE7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkX2FycmF5cyhuZXh0KSB7XHJcblx0cmV0dXJuIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyBcclxuXHRcdGxldCB2ID0gcmVhZF9zb3J0ZWQobmV4dCk7XHJcblx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2O1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIG1hcCBvZiB4ID0+IHlzXHJcbmZ1bmN0aW9uIHJlYWRfbWFwcGVkKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpO1xyXG5cdFx0aWYgKHcgPT0gMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKSAtIDE7XHJcblx0XHRpZiAodyA8IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQuZmxhdCgpO1xyXG59XHJcblxyXG4vLyByZWFkIHVudGlsIG5leHQgaXMgZmFsc3lcclxuLy8gcmV0dXJuIGFycmF5IG9mIHJlYWQgdmFsdWVzXHJcbmZ1bmN0aW9uIHJlYWRfYXJyYXlfd2hpbGUobmV4dCkge1xyXG5cdGxldCB2ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCh2Lmxlbmd0aCk7XHJcblx0XHRpZiAoIXgpIGJyZWFrO1xyXG5cdFx0di5wdXNoKHgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gcmVhZCB3IGNvbHVtbnMgb2YgbGVuZ3RoIG5cclxuLy8gcmV0dXJuIGFzIG4gcm93cyBvZiBsZW5ndGggd1xyXG5mdW5jdGlvbiByZWFkX3RyYW5zcG9zZWQobiwgdywgbmV4dCkge1xyXG5cdGxldCBtID0gQXJyYXkobikuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpKyspIHtcclxuXHRcdHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XHJcblx0fVxyXG5cdHJldHVybiBtO1xyXG59XHJcbiBcclxuLy8gcmV0dXJucyBbW3gsIHlzXSwgW3grZHgsIHlzK2R5XSwgW3grMipkeCwgeXMrMipkeV0sIC4uLl1cclxuLy8gd2hlcmUgZHgvZHkgPSBzdGVwcywgbiA9IHJ1biBzaXplLCB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xyXG5cdGxldCBkeCA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IGR5ID0gbmV4dCgpO1xyXG5cdGxldCB2TiA9IHJlYWRfYXJyYXlfd2hpbGUobmV4dCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQodk4ubGVuZ3RoLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLmZsYXRNYXAoKHYsIGkpID0+IHtcclxuXHRcdGxldCBbeCwgLi4ueXNdID0gdjtcclxuXHRcdHJldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xyXG5cdFx0XHRsZXQgal9keSA9IGogKiBkeTtcclxuXHRcdFx0cmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBbW3gsIHlzLi4uXSwgLi4uXVxyXG4vLyB3aGVyZSB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7IFxyXG5cdGxldCBuID0gMSArIG5leHQoKTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZChuLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZWFkX3RyaWUobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc29ydGVkID0gcmVhZF9zb3J0ZWQobmV4dCk7IFxyXG5cdGV4cGFuZChkZWNvZGUoW10pLCBbXSk7XHJcblx0cmV0dXJuIHJldDsgLy8gbm90IHNvcnRlZFxyXG5cdGZ1bmN0aW9uIGRlY29kZShRKSB7IC8vIGNoYXJhY3RlcnMgdGhhdCBsZWFkIGludG8gdGhpcyBub2RlXHJcblx0XHRsZXQgUyA9IG5leHQoKTsgLy8gc3RhdGU6IHZhbGlkLCBzYXZlLCBjaGVja1xyXG5cdFx0bGV0IEIgPSByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgLy8gYnVja2V0cyBsZWFkaW5nIHRvIG5ldyBub2Rlc1xyXG5cdFx0XHRsZXQgY3BzID0gcmVhZF9zb3J0ZWQobmV4dCkubWFwKGkgPT4gc29ydGVkW2ldKTtcclxuXHRcdFx0aWYgKGNwcy5sZW5ndGgpIHJldHVybiBkZWNvZGUoY3BzKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtTLCBCLCBRfTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZXhwYW5kKHtTLCBCfSwgY3BzLCBzYXZlZCkge1xyXG5cdFx0aWYgKFMgJiA0ICYmIHNhdmVkID09PSBjcHNbY3BzLmxlbmd0aC0xXSkgcmV0dXJuO1xyXG5cdFx0aWYgKFMgJiAyKSBzYXZlZCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0aWYgKFMgJiAxKSByZXQucHVzaChjcHMpOyBcclxuXHRcdGZvciAobGV0IGJyIG9mIEIpIHtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgYnIuUSkge1xyXG5cdFx0XHRcdGV4cGFuZChiciwgWy4uLmNwcywgY3BdLCBzYXZlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cblxuZnVuY3Rpb24gaGV4X2NwKGNwKSB7XHJcblx0cmV0dXJuIGNwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1b3RlX2NwKGNwKSB7XHJcblx0cmV0dXJuIGB7JHtoZXhfY3AoY3ApfX1gOyAvLyByYWZmeSBjb252ZW50aW9uOiBsaWtlIFwiXFx1e1h9XCIgdy9vIHRoZSBcIlxcdVwiXHJcbn1cclxuXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBsb2RlX2NwKHMpIHtcclxuXHRyZXR1cm4gWy4uLnNdLm1hcChjID0+IGMuY29kZVBvaW50QXQoMCkpO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGV4cGxvZGVfY3AocykgeyAvLyB0aGlzIGlzIGFib3V0IDJ4IGZhc3RlclxyXG5cdGxldCBjcHMgPSBbXTtcclxuXHRmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcclxuXHRcdGxldCBjcCA9IHMuY29kZVBvaW50QXQocG9zKTtcclxuXHRcdHBvcyArPSBjcCA8IDB4MTAwMDAgPyAxIDogMjtcclxuXHRcdGNwcy5wdXNoKGNwKTtcclxuXHR9XHJcblx0cmV0dXJuIGNwcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyX2Zyb21fY3BzKGNwcykge1xyXG5cdGNvbnN0IGNodW5rID0gNDA5NjtcclxuXHRsZXQgbGVuID0gY3BzLmxlbmd0aDtcclxuXHRpZiAobGVuIDwgY2h1bmspIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMpO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XHJcblx0XHRidWYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMuc2xpY2UoaSwgaSArPSBjaHVuaykpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZV9hcnJheXMoYSwgYikge1xyXG5cdGxldCBuID0gYS5sZW5ndGg7XHJcblx0bGV0IGMgPSBuIC0gYi5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGMgPT0gMCAmJiBpIDwgbjsgaSsrKSBjID0gYVtpXSAtIGJbaV07XHJcblx0cmV0dXJuIGM7XHJcbn1cblxuLy8gY3JlYXRlZCAyMDIzLTA5LTI1VDAxOjAxOjU1LjE0OFpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IGE5NzRiNmY4NTQxZmMyOWQ5MTliYzg1MTE4YWYwYTQ0MDE1ODUxZmFiNTM0M2Y4Njc5Y2IzMWJlMmJkYjIwOWVcbnZhciBDT01QUkVTU0VEID0gJ0FFVURUQUhCQ0ZRQVRRRFJBREFBY2dBZ0FEUUFGQUFzQUJRQUh3QU9BQ1FBRFFBUkFBb0FGd0FIQUJJQUNBQVBBQVVBQ3dBRkFBd0FCQUFRQUFNQUJ3QUVBQW9BQlFBSUFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDZ0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RTQWRzREpnQzBDa01COHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ3NqMjZQVFF5eThGZkVROEFZOElQQUdjRWJ3UndCSEVFY2dSekJIUUVkUVIyQkhjRWVBUjZCSHNFZkFSK0JJQUVnZm5kQlFvQllnVUxBV0lGREFGaUJOY0UyQVRaQlJBRkVRVXZCZEFMRkFzVkRQY05CdzEzRFljT01BNHhEak1CNEJsbEhJMEIyZ3JiQU1EcEhMa1E3UUhWQVBSTlFRRm5HUlVFZzB5RUIydWFKRjhBSnBJQnBvYjVBRVJTTUFLTm9BWHFhUUxVQk1DekVpQUNud1JaRWtrVnNTN3RBTkFzQkcwUnVBUUxFUEFCdjlISUNUVUJYaWdQWndSQkFwTURPd0FhbWh0YUFCcUVBWThLdkt4M0xRNEFyQUI4VWh3RUJBVlNhZ0Q4QUVGWkFEa0JJYWRWajJVTVVneDVJbDRBTlFDOUF4SUIxQmxiRVBNQXMzMENHeGxYQWh3WktRSUVDQmM2RWJzQ294bmd6djdVelJRQThNMEJhd0w2WndrTjd3QUJBRDMzT1FSY3NnTEpDak1DanFVQ2h0dy9rbStOQXNYUEFvUDJCVDg0UHdVUkFLMFJBdnB0YjZjQXBRUy9PTU1leTVISlM4NFVkeHB4VFBrQ29nVkZJVGFUT3dFUkFLNXBBdmtOQk9WeUE3cTNCS2xPSlNBTEFnVUlCUmNFZEFTcEJYcXpBQlhGU1daT2F3TENPcXcvL0FvbENaZHZ2M2RTQmtFUUd5ZWxFUGNNTXdHMUFUc043VXZZQlBFR093VEpIMzBaR1EvTmxad0lwUzNkRE8wbTR5NmhnRm9qOVNxREJlMUw5RHpkQzAxUmFBOVpDMlVKNHpwamdVNERJUUVOSW9zSzNRMDVDRzBROHdySmF3M2xFVVVIT1FQVlNab0FwUWNCQ3hFZE5SVzFKaEJpckFzSk9YY0creHIyQzQ4bXJ4TXBldndGMHhvaEJrMEJLUnIvQU04dTU0V3dXakZjSEU5ZkJnTUxKU1BIRktoUUlBMGxRTGQ0U0JvYkJ4VWxxUUtSUTNCS2gxRTJIcE1oOWp3OURXWXVFMUY4Qi9VOEJSbFBDNEU4bmthclJRNFIwajZOUFVnaVNVd3NCRFYvTEM4bml3blBENFVNdVh4eUFWa0pJUW14REhFVE1SRVhOOFVJT1FjWkxaY2tKeFVJSVVhVllKb0U5NThEOHhQUkF3c0ZQd2xCQnhNRHRSd3RFeTRWS1FVTmdTVFhBdk0yMVM2ekFvOVdnQUVYQmNzUEpSL2ZFRkJINEE3cENKc0NaUU9ESmVzQUxSVWhBQmNpbXdoRFl3QmZqOWhUQlM3TENNZHFiQ04wQTJjVTUyRVJjd2VSRGxjSHB4d3pGYjhjNFhESVhndUdDQ2lqcndsYkFYVUptUUZmQk9NSUNUVmJqS0FnUVdkVGkxZ1lteUJoUVQ5ZC9BSXhER1VWbjBTOWgzZ0NpdzlyRWhzQk5RRnpCemtOQVFKM0VlMFJheENWQ091R0JEVzFNL2c2SlFSUElZTWdFUW9uQTA5c3pnc25KdmtNK0drQm94SmlBd3cwUFhmdVo2dGd0aVFYL1FjWk1zVkJZQ0h4QzVKUHpReWNHc0VZUWxRdUdlUUh2d1B6R3ZNbjZrRlhCZjhEb3dNVE9rMHo3Z1M5QzJrSWl3ay9BRWtPb3hjSDF4aHFDbkdNMEFFeGl3RzNtUU5Ya1lNQ2I0OEdOd2NMQUdjTGh3VjU1UUFkQXFjSW93QUZBTThEVndBNUFxMEhuUUFaQUlWQkFUMERKeThCSWVVQ2p3T1RDREhMQVpVdkFmTXBCQnZEREJVQTl6ZHVTZ0xEc1FLQWFtYWlCZDFZQW80Q1NUVUJUU1VFQlU1SFVRT3ZjZUVBMndCTEJoUGZSd0VWcTByTEd1TkRBZDl2S3dESEFQc0FCVFVIQlVFQnpRSHpiUUMzQVY4TE1RbWlzN1VCVGVrcEFJTUFGV3NCMXdLSkFOMEFOUUIvOFFGVEFFMEZXZmtGMHdKUFNRRVJNUmdyVjJFQnV3TWZBVE1CRFFCNUJzdU5wY2tISHdSdEI5TUNFQnNWNFFMdkxnZTFBUU1pM3hQTlFzVUN2ZDVWb1dBQ1pJRUNZa0piVGE5Yk55QUNvZmNDYUpnQ1pna0NuNFE0R3dzQ1pqc0NaaVlFYmdSL0EzOFRBMzZTT1FZNWR4YzVnam9qSXdKc0hRSXlOamdLQW0zSEFtMnU3NG96WjBVckFXY0EzZ0RoQUVvRkI1Z01qUUQrQzhJQURiVUNkeThDZHFJL0FubExRd0o0dWgxYzIwV3VSdGNDZkQ4Q2VzZ0NmUWtDZlBBRldRVWdTQUJJZldNa0FvRnRBb0FBQW9BRkFuK3VTVmhLV3hVWFNzd0MwUUVDME14TEp3T0lUd09INWtURmtUSUM4cUZkQXdNRHJrdk9UQzBsQTg5TlRFMnZBb3MvQW9yWXdSc0hIVU5uQmJjQ2pqY0NqbHhBbDRFQ2p0a0NqbHg0VWJSVE5RcFMxRlNGQXBQN0FwTU1BT2tBSEZVZVZhOVYwQVlzR3ltVmhqTGhlR1pGT3prQ2w1OEM3N0pZSWFnQVdTVUNsbzhDbG55Y0FLbFpyRm9KZ1UwQU93S1d0UUtXVGx4RVhORUNtY3NDbVdSY3lsMEhHUUtjbXpuQ09wMENuQllDbjVzQ25yaUtBQjBQTVNvUEFwM3hBcDZTQUxVOVlUUmg3d0tlMHdLZ2JnR3BBcDZmSHdLZVRxVmp5R1FuSlNzQ0o2OENKbjRDb1BzQ29Fd0NvdDBDb2NRQ3BpOENwYzRDcC84QWZRS244bWg4YUxFQUEwbHFIR3JSQXF6akFxeXVBcTFuQXEwQ0FsY2RBbFhjQXJIaDF3TWZUbXlYQXJLOURRS3k2QmRzNEcxamJVaGZBeVhOQXJaY096OXVrQU1wUlFLNFhnSzVSeFVDdVNwM2NEWnc0UUs5R1FLNzJuQ1dBeklSQXI2SWNnSURNM0VDdmhwekluTlBBc1BMQXNNRWM0SjBTelZGZE9BRFBLY0RQSm9EUGI4Q3hYd0N4a2NDeGhDSkFzaHBVUUxJUkFMSlR3TEpMZ0prblFMZDBuaDVZWGl1ZVNWTDBBTVlvMmNDQW1IMEdmT1ZKSHNMWHBKZXV4RUN6MnNDejJ3dlMxUFM4eE9mQU1hdEFzOXpBU25xQTA0U2Zrc0ZBdHduQXR1S0F0SlBBMUpjQTFOZkFRRURWWXlBaVQ4QXl4YnRZRVdDSElMVGdzNkRqUUxheHdMWjNvUVFoRW1uUEFPR3BRQXZBMlFPaG5GWitRQlZBdDlsQXQ2NGMzY0M0aS90RkFIek1DY0I5SnNCOHRLSEF1dnpBdWx3ZVFMcStRTHE1QUQ1UndHNUF1NkpBdXVjbHFxWEF3THVQd09GNEpoNWNPQnhvUUx6QXdCcEE0NFdtWk1DOXhNRGtXNERrb2NDOTVnQytka0MrR2FhSEpxcnV6ZWJIZ09kZ3dMKytnRWJBRG1mSEorekF3V05BNlpxQTZiWkFOSEZBd1pxb1lpaUJRa0RERWtDd0FBL0F3RGhRUmRUQVJIekEyc0hsMmNGQUpNdEs3ZXZ2ZHNCaVprVWZ4RUVPUUg3S1FVaERwMEpud0NTL1NsWHhRTDNBWjBBdHdXNUFHOExiVUV1RkNhTkxnRkRBWUQ4QWJVbUFIVUREZ1J0QUN3Q0ZneWhBQUFLQWowQ2FnUGRBMzRFa1FFZ1JRVWhmQW9BQlFCRUFCTUFOaElDZHdFQUJkVURhKzhLeFFJQTl3cWZKNyt4dCtVQmtTRkJRZ0hwRkg4Uk5NQ0pBQVFBR3dCYUFrVUNoSXNBQmpwVE9wU05iUUM0T284NjBBQ05PTUU2M0FDbEFPZ0F5d0U2Z1RvN09mdzUrVHQyaVRwYk81NkpPbTg1R0FGV0FUTUJiQVV2TlYwMW5qV3ROV1kxZFRXMk5jVTFnaldSTmRJMTRUV2VOYTAxN2pYOU5iSTF3VFlDTmhFMXhqWFZOaFkySnpYZU5lMDJMalk5Tmk0MUxTRTJPalk5Tmp3MnlUY0lCSkE4VnpZNE50MDNJRGNQTnNvZ040azNNQW9Fc0R4bk5pUTNHVGRzT28wM0lVTFVRd2RDNEVNTEhBOFBDWnNvYlNoUlZRWUE2WDhBNmJBQkZDblhBdWtCb3dDOUJiY0Fid056Qkw4TURBTU1BUWdEQUFrS0N3c0xDUW9HQkFWVkJJL0R2d0R6OWIyOWthVUNiMFF0c1JUTkx0NGVHQmNTSEFNWkZoWVpFaFlFQVJBRUJVRWNRUnhCSEVFY1FSeEJIRUVhUVJ4QkhFRkNTVHhCUEVsSVNVaEJOa00yUVRZYk5rbElTVm1CVklnQkZMV1pBdTBCaFFDakJjRUFieWtCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUFCYXZBajYyNnhRQUpQMEEzZXR6dWY0Tk5SQTdlZnkyWjlOUXJDbkMwT1N5QU56NUJCSWJKNUlGRFI2bWlJYXZZUzZ0cHJqam11S2VieG01Qzc0UTIyNVgxcGthWVlQYjZmMURLNGszeE1FQmI5UzJXTWpFaWJUTldoc1JKSUErdndOVkVpWFRFNWlYcy93ZXpWNjZvRkxmcDlOWkdZVytHazE5SjIrYkNUNlllMnc2TERZZGd6S01VYWJrNTk1ZUxCQ1hBTno5SFVwV2JBVHE5dnFYVng5WERnK1BjOVhwNCtic1MwMDVTVk0vQkpCTTQ2ODdXVXVmK1VqOWRFaThhRE5hUHh0cGJEeGNHMVRIVEltVU1acTRVQ2FhTllwc1ZxcmFOeUtMSlhEWXNGWi81amw3YkxSdE84OHQ3UDN4WmFBeGhiNU9kUE1YcXNTa3AxV0NpZUc4alhtMVU5OStibHZMbFh6UENTK005M1ZuSkNpSyswOUxmYVNhQkFWQm9teURnSnVhOGRmVXpSN2dhMzRJdlIyTnZqK0E5aGVKNmxzbDFLRzROa0kxMDMyQ25mZjFtMXdvZjJCOW9ISks0Ymk2SmtFZFNxZU5laXVvNlFvWlppbmNvYzczL1RIOVNYRjhzQ0U3WHl1WXlXOFdTZ2JHRkNqUFYwaWhMS2hkUHMwOFR4ODJmWUFrTExjNEkyd2RsNGFwWTdHVTVsSFJGelJXSmVwN1d3M3diZUEzcW1kNTkvODZQNHh1TmFxRHB5Z1h0Nk04NWdsU0JIT0NHZ0pEbnQrcE45Yks3SEFwTWd1WDYrMDZSWk5qelZtY1pKK3djVXJKOS8vYnBSTnhOdUtwTmw5dUZkcytTOXRkeDdMYU01WmtJclBqNm5JVTltbmJGdFZiczlzL3VMZ2w4TVZjekF3ZXQraU9FenpCbFlXN1JDTWdFNmd5TkxlcTYrMXRJeDRkcGdabmQwRGtzSlM1ZitKTkRwd3djUE5YYWFWc3BxMWZiUWFqT3JKZ0swb2ZLdEoxTmU5MEw2Vk80TU9sNVM4ODZwN3U2eG83T0xqRzhUR0wrSFUxSlhHSmdwcGc0bk5iTko1bmx6U3B1UFl5MjFKVUVjVUE5NFBvRmlaZmpadWUrUW55UTgwZWtPdVpWa3h4NGcrY3ZoSmZIZ05sNGh5MS9hNitSS2NLbGFyL0oyOXkvL0V6dGxiVlBIVlVlUTF6WDg2ZVFWQWpSL00zZEE5dzRXOExmYVhwNEVnTTg1d09XYXNsaTgzN1B6Vk1PbnNMelIrazNvNzUvbFJQQUpTRTF4QUtRekVpNXYxMGtlK1ZCdlJ0MWN3UVJNZCtVNW1MQ1RHVmQ2WGladGdCRzVjRGkwdzIyR0tjVk52SGl1NUxRYlpFRFZ0ejBvbm43azUraGV1S1hWc1p0U3ppbGtMUkFVbWpNWEVNQjNKOVlDNTBYQnhQaXo1M1NDK0VoblBsOVdzS0N2OTJTTS9PRkZJTUpaWWZsMFdXOHRJTzNVeFljd2RNQWo3RlNtZ3JzWjJhQVpPMDNCT2hQMWJOTlpJdHlYWVFGVHBDM1NHMVZ1UERxSDlHa2lDRG1FK0p3eHlJVlNPNXNpREVyQU9wRVhGZ2p5NlBRdE9WRGorczZlMXI4aGVXVnZtWm5UY2l1ZjRFaU5aekNBZDdTT01oWEVSSU9sc0hJTUczOTlpOWFMVHkzbTJoUkxaakpWRE5MUzUzaUdJSzExZFBxUXQwekJEeWc2cWM3WXFrRG0yTTVWZTZkQ1dDYUNiVFhYMnJUb2FJZ3o2K3poNGxZVWkvKzZucWNGTUFrUUpLSFlMSzB3WWs1TjlzelY2eGloRGJEREZyNDVsTjFLNGFDWEJxL0ZpdFBTdWQ5Z0x0NVpWbitacUdYN2N3bTJ6NUVHTWdmRnBJRnloR0d1RFBtc282VEl0VE13bnkrN3VQbkxDZjRXNmdvRlFGVjBvUVNzYzlWZk1tVkxjTHI2WmV0RFpiYVNGVExxblNPL2JJUGpBMy96QVVvcWdHRkFFUVM0SWh1TXpFcDJJM2pKemJ6a2svSUVteWF4K3JoWlR3ZDZmK0NHdHdQaXh1OEl2ekFDcXVQV1BSRXU5WnZHa1V6cFJ3dlJSdWFOTjZjcjBXMXdXaXRzOUlDZFlKN2x0YmdNaVNMM3NUUGV1ZmdOY1ZxTVZXRmtDUERINGpHMmpBMFhjVmdRajYyQ2IyOXY5Zi96LysyS2JZdkl2L3p6anBRQVBrbGlhVkR6TnJXNTdUWi9aT3laRDBubGZNbUFJQklBR0FJMEQzay9tZE40eHI5djg1WmJaYmJxZkgyakdkNWhVcU5aV3dsNVNQZm9HbWZFbG1helVJZU5MMWovbWtGN1ZOQXpUcTRqTnQ4Sm9RMTFOUU9jbWhwclhveFN4ZlJHSjlMREVPQVErZG14QVFIOTBpdGk5ZTJ1L01vZXVhR2NEVEhvQyt4c21FZVdteEVLZWZRdUl6SGJwdzVUYzVjRW9jYm9BRDA5b2lwV1FodFRPMXdpdmYvTytEUmUycnBsL0U5d2xyekJvcmpKc09lRzFCL1hQVzRFYUpFRmRObEVDRVpnYTVab0dSSFhnWW91R1J1VmttOHRERVNpRXlGTm8rM3M1TTVwdVNkVHlVTDJsbG5JTlZIRXQ5MVhVTlc0ZXdkTWdKNGJvSmZFeXQvaVk1V1hxYkErQTJGa3Q1WjBsdXRpV2hlOW5aSXlJVWp5WERDM1VzYUcxdCtlTng2ejRXL09Zb1RCN0E2eCtkTlNUT2k5QUluY3RiRVNxbTVndk9Md3c3T1dYUHJtSHdWWmFzcmw0ZUQxMTNwbStKdFQ3SlZPdm5DWHFkenpkVFJIZ0owUGlHVEZZVzVHdnQ5UjlMRDZMemZzMHYvVFpaSFNteVZOcTd2aUlIRTZEQks3UXAwN0l6NTVFTThTWXRRdlpmL29iQm5pVFdpNUMyL292SGZ3NFZuZGtFNVhZZGpPaENNUmpEZU9FZlhlTi9Dd2ZHZHVpVUlmc29GZVV4WGVRWGJhN2M3OTcyWE52OHcrZFRqalVNMFFlTkFSZVcrSjAxNGRLQUQvTWNRWVhUN2MwR1FQSWtuM0xsNlI3Z0dqdWlRb1pEMFRFZUVxUXBLb1oxNWcvME9QUUkxN1FpU3Y5QVVST2EvVi9UUU4zZHZMQXJlYzNScnNZbHZCbTFiOExXemx0ZHVnc0M1MGxOS1lMRXAyYStaWllxUGVqVUxSbE9KaDV6ai9MVk15VER2d0toTXh4d3VEa3hKMVFwb05JME9UV0xvbTRaNzFTTnpJOVRWMWlYSnJJdTlXY25kK01DYUF3OG8xalNYZDk0WVUvMWdua3JDOUJVRU90UXZFSVE3ZzBpNmgrS0wySktrOFlkbDdIcnV2Z1dNU0FtTmUrTHNoR2hWNHFuV0hoTzkvUklQUXpZMXRIUmoyVnFPeU5zRHBLMGN3dys1NkFkREM0Z3NXd1kwWHhvdWNJV0lxcy9HY3duV3FsYVQwS1ByOG1iSzVVOTQvMzAxaTFXTHQ0WUlOVFZ2Q0ZCckZaYkliWThleWNPZGVKMnRlRDVJZlBMQ1JnN2pqY0ZUd2xNRk5sOXpkaC9vM0UvaEhQd2o3QldnME1VMDlwUHJCTGJyQ2dtNTRBNkgrSTZ2Mjcrakw1Z2tqV2cvaVlka3M5amJmVlA1eS9uMGRsZ1dFTWxLYXNsN0p2RlpkNTZMZnliVzFlZWFWTzBneFRmWFp3RDhHNFNJMTE2eXg3VUtWUmd1aTZZYTFZcGl4cVhlTkxjOEl4dEF3Q1U1SWh3UWduK05xSG5SYUR2NjFDeEtoT3E0cE9YN002cGtBK1BtcGQ0ajF2bjZBQ1VBTG9MTGM0dnBYY2k4VmlkTHh6bTdxRkJlN3MrcXV1SnM2RVRZbW5wZ1MzTHdTWnhQSWx0Z0JEWHo4TTFrL1cyeVNOdjJmOS9OUGh4TEdLMkQyMWRrSGVTR21lblJUM1lxY2RsMG0vaDNPWXI4VitsWE5ZR2Y4YUNDcGQ0YldqRTRRSVBqN3ZVS040TnJmczdNTDZZMk95UzgzMEpDbm9mZy9rN2xwRnB0NFNxWmM1SEdnMUhDT3JIdk9kQzhiUDZGR0RiRS9WVjBtWDRJYWt6YmRTL29wK0t0M0cyNC84UWJCVjd5ODZzR1NRL3ZaelU4RlhzN3U2akl2d2Noc0VQMkJwSWhXM0c4dVdOd2EzSG1qZkgvWmpoaENXdmx1QWNGK25NZjE0Q2xLZzVoR2d0UExKOTh1ZU5Ba2M1SHMyV1psazJRSHZmcmVDSzFDQ0dPNm5NWlZTYjk5Vk0vYWpyOFdIVHRlOUpTbWtYcS9pL1U5NDNIRWJkelc2UmUvUzg4ZEtnZzhwR09MbEFlTmlxcmNMa1VSMy9hQ2xGcE1YY09VUDNybUVUY1dTZk1YWkUzVFVPaThpK2ZxUm5UWUxmbFZ4L1ZiLzZHSjdlSVJaVUE2azNSWVIzaUZTSzljNGlEZE53SnVaTDJGS3ovSUs1VmltY05XRXFkWGpTb3hTZ21GMFVQbERvVWxOclBjTTdmdG1BOFk5Z0tpcUtFSHVXTitBWlJJd3RWU3h5ZTJLZjhyTTNsaEo1WGNCWFU5bjR2ME95MVJVMk0rNHFNOEFRUFZ3c2U4RXJOU29iNW9GUFd4dXFablZ6bzFxQi9JQnhrTTNFVlVLRlVVbE8zZTUxMjU5R2dOY0piQ21sdnJkanRvVFc3ckNobTF3eUNLenBDVHdvelVVRU9JY1dMbmVSTGdNWGgrU2pHU0ZrQWxsemJHUzVISzdMbGZDTVJOUkRTdmJRUGpjWGFlbk5ZeEN2dTJReXpuejZTdHV4Vmo2NlNnSTBUOEI2L3NmSEFKWVphWjc4dGhqT1NJRnVtTldMUWJlWml4RENDQyt2MFlCdGt4aUJCM2plZkhxWi9kRkhVK2NyYmo2T3ZTMXgvSkREN3ZsbTd6T1ZQd3BVQzAxbmh4WnVZLzYzRTdnJztcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG5mdW5jdGlvbiBpbml0JDEoKSB7XHJcblx0Ly9jb25zb2xlLnRpbWUoJ25mJyk7XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEKTtcclxuXHRTSElGVEVEX1JBTksgPSBuZXcgTWFwKHJlYWRfc29ydGVkX2FycmF5cyhyKS5mbGF0TWFwKCh2LCBpKSA9PiB2Lm1hcCh4ID0+IFt4LCAoaSsxKSA8PCAyNF0pKSk7IC8vIHByZS1zaGlmdGVkXHJcblx0RVhDTFVTSU9OUyA9IG5ldyBTZXQocmVhZF9zb3J0ZWQocikpO1xyXG5cdERFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRSRUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0Zm9yIChsZXQgW2NwLCBjcHNdIG9mIHJlYWRfbWFwcGVkKHIpKSB7XHJcblx0XHRpZiAoIUVYQ0xVU0lPTlMuaGFzKGNwKSAmJiBjcHMubGVuZ3RoID09IDIpIHtcclxuXHRcdFx0bGV0IFthLCBiXSA9IGNwcztcclxuXHRcdFx0bGV0IGJ1Y2tldCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdFx0YnVja2V0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFJFQ09NUC5zZXQoYSwgYnVja2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWNrZXQuc2V0KGIsIGNwKTtcclxuXHRcdH1cclxuXHRcdERFQ09NUC5zZXQoY3AsIGNwcy5yZXZlcnNlKCkpOyAvLyBzdG9yZWQgcmV2ZXJzZWRcclxuXHR9XHJcblx0Ly9jb25zb2xlLnRpbWVFbmQoJ25mJyk7XHJcblx0Ly8gMjAyMzA5MDU6IDExbXNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfaGFuZ3VsKGNwKSB7XHJcblx0cmV0dXJuIGNwID49IFMwICYmIGNwIDwgUzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VfcGFpcihhLCBiKSB7XHJcblx0aWYgKGEgPj0gTDAgJiYgYSA8IEwxICYmIGIgPj0gVjAgJiYgYiA8IFYxKSB7XHJcblx0XHRyZXR1cm4gUzAgKyAoYSAtIEwwKSAqIE5fQ09VTlQgKyAoYiAtIFYwKSAqIFRfQ09VTlQ7XHJcblx0fSBlbHNlIGlmIChpc19oYW5ndWwoYSkgJiYgYiA+IFQwICYmIGIgPCBUMSAmJiAoYSAtIFMwKSAlIFRfQ09VTlQgPT0gMCkge1xyXG5cdFx0cmV0dXJuIGEgKyAoYiAtIFQwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IHJlY29tcCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdHJlY29tcCA9IHJlY29tcC5nZXQoYik7XHJcblx0XHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVjb21wO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvbXBvc2VkKGNwcykge1xyXG5cdGlmICghU0hJRlRFRF9SQU5LKSBpbml0JDEoKTtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGxldCBjaGVja19vcmRlciA9IGZhbHNlO1xyXG5cdGZ1bmN0aW9uIGFkZChjcCkge1xyXG5cdFx0bGV0IGNjID0gU0hJRlRFRF9SQU5LLmdldChjcCk7XHJcblx0XHRpZiAoY2MpIHtcclxuXHRcdFx0Y2hlY2tfb3JkZXIgPSB0cnVlO1xyXG5cdFx0XHRjcCB8PSBjYztcclxuXHRcdH1cclxuXHRcdHJldC5wdXNoKGNwKTtcclxuXHR9XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoY3AgPCAweDgwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzX2hhbmd1bChjcCkpIHtcclxuXHRcdFx0XHRsZXQgc19pbmRleCA9IGNwIC0gUzA7XHJcblx0XHRcdFx0bGV0IGxfaW5kZXggPSBzX2luZGV4IC8gTl9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHZfaW5kZXggPSAoc19pbmRleCAlIE5fQ09VTlQpIC8gVF9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHRfaW5kZXggPSBzX2luZGV4ICUgVF9DT1VOVDtcclxuXHRcdFx0XHRhZGQoTDAgKyBsX2luZGV4KTtcclxuXHRcdFx0XHRhZGQoVjAgKyB2X2luZGV4KTtcclxuXHRcdFx0XHRpZiAodF9pbmRleCA+IDApIGFkZChUMCArIHRfaW5kZXgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBtYXBwZWQgPSBERUNPTVAuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAobWFwcGVkKSB7XHJcblx0XHRcdFx0XHRidWYucHVzaCguLi5tYXBwZWQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhZGQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWJ1Zi5sZW5ndGgpIGJyZWFrO1xyXG5cdFx0XHRjcCA9IGJ1Zi5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoZWNrX29yZGVyICYmIHJldC5sZW5ndGggPiAxKSB7XHJcblx0XHRsZXQgcHJldl9jYyA9IHVucGFja19jYyhyZXRbMF0pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHRcdGlmIChjYyA9PSAwIHx8IHByZXZfY2MgPD0gY2MpIHtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGogPSBpLTE7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IHRtcCA9IHJldFtqKzFdO1xyXG5cdFx0XHRcdHJldFtqKzFdID0gcmV0W2pdO1xyXG5cdFx0XHRcdHJldFtqXSA9IHRtcDtcclxuXHRcdFx0XHRpZiAoIWopIGJyZWFrO1xyXG5cdFx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0Wy0tal0pO1xyXG5cdFx0XHRcdGlmIChwcmV2X2NjIDw9IGNjKSBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCh2KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzdGFjayA9IFtdO1xyXG5cdGxldCBwcmV2X2NwID0gLTE7XHJcblx0bGV0IHByZXZfY2MgPSAwO1xyXG5cdGZvciAobGV0IHBhY2tlZCBvZiB2KSB7XHJcblx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocGFja2VkKTtcclxuXHRcdGxldCBjcCA9IHVucGFja19jcChwYWNrZWQpO1xyXG5cdFx0aWYgKHByZXZfY3AgPT0gLTEpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPiAwICYmIHByZXZfY2MgPj0gY2MpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHJcblx0XHRcdFx0c3RhY2subGVuZ3RoID0gMDtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNvbXBvc2VkID0gY29tcG9zZV9wYWlyKHByZXZfY3AsIGNwKTtcclxuXHRcdFx0aWYgKGNvbXBvc2VkID49IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY29tcG9zZWQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocHJldl9jYyA9PSAwICYmIGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwKTtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2X2NwID49IDApIHtcclxuXHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcdFxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBub3RlOiBjcHMgY2FuIGJlIGl0ZXJhYmxlXHJcbmZ1bmN0aW9uIG5mZChjcHMpIHtcclxuXHRyZXR1cm4gZGVjb21wb3NlZChjcHMpLm1hcCh1bnBhY2tfY3ApO1xyXG59XHJcbmZ1bmN0aW9uIG5mYyhjcHMpIHtcclxuXHRyZXR1cm4gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKGRlY29tcG9zZWQoY3BzKSk7XHJcbn1cblxuY29uc3QgSFlQSEVOID0gMHgyRDtcclxuY29uc3QgU1RPUCA9IDB4MkU7XHJcbmNvbnN0IFNUT1BfQ0ggPSAnLic7XHJcbmNvbnN0IEZFMEYgPSAweEZFMEY7XHJcbmNvbnN0IFVOSVFVRV9QSCA9IDE7XHJcblxyXG4vLyAyMDIzMDkxMzogcmVwbGFjZSBbLi4udl0gd2l0aCBBcnJheV9mcm9tKHYpIHRvIGF2b2lkIGxhcmdlIHNwcmVhZHNcclxuY29uc3QgQXJyYXlfZnJvbSA9IHggPT4gQXJyYXkuZnJvbSh4KTsgLy8gQXJyYXkuZnJvbS5iaW5kKEFycmF5KTtcclxuXHJcbmZ1bmN0aW9uIGdyb3VwX2hhc19jcChnLCBjcCkge1xyXG5cdC8vIDIwMjMwOTEzOiBrZWVwIHByaW1hcnkgYW5kIHNlY29uZGFyeSBkaXN0aW5jdCBpbnN0ZWFkIG9mIGNyZWF0aW5nIHZhbGlkIHVuaW9uXHJcblx0cmV0dXJuIGcuUC5oYXMoY3ApIHx8IGcuUS5oYXMoY3ApO1xyXG59XHJcblxyXG5jbGFzcyBFbW9qaSBleHRlbmRzIEFycmF5IHtcclxuXHRnZXQgaXNfZW1vamkoKSB7IHJldHVybiB0cnVlOyB9IC8vIGZyZWUgdGFnZ2luZyBzeXN0ZW1cclxufVxyXG5cclxubGV0IE1BUFBFRCwgSUdOT1JFRCwgQ00sIE5TTSwgRVNDQVBFLCBORkNfQ0hFQ0ssIEdST1VQUywgV0hPTEVfVkFMSUQsIFdIT0xFX01BUCwgVkFMSUQsIEVNT0pJX0xJU1QsIEVNT0pJX1JPT1Q7XHJcblxyXG5mdW5jdGlvbiBpbml0KCkge1xyXG5cdGlmIChNQVBQRUQpIHJldHVybjtcclxuXHRcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQkMSk7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfYXJyYXkgPSAoKSA9PiByZWFkX3NvcnRlZChyKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9zZXQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdGNvbnN0IHNldF9hZGRfbWFueSA9IChzZXQsIHYpID0+IHYuZm9yRWFjaCh4ID0+IHNldC5hZGQoeCkpO1xyXG5cclxuXHRNQVBQRUQgPSBuZXcgTWFwKHJlYWRfbWFwcGVkKHIpKTsgXHJcblx0SUdOT1JFRCA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBpZ25vcmVkIGNoYXJhY3RlcnMgYXJlIG5vdCB2YWxpZCwgc28ganVzdCByZWFkIHJhdyBjb2RlcG9pbnRzXHJcblxyXG5cdC8qXHJcblx0Ly8gZGlyZWN0IGluY2x1ZGUgZnJvbSBwYXlsb2FkIGlzIHNtYWxsZXIgdGhhbiB0aGUgZGVjb21wcmVzc2lvbiBjb2RlXHJcblx0Y29uc3QgRkVOQ0VEID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdGxldCBjcCA9IHIoKTtcclxuXHRcdGlmIChjcCkgcmV0dXJuIFtjcCwgcmVhZF9zdHIocigpKV07XHJcblx0fSkpO1xyXG5cdCovXHJcblx0Ly8gMjAyMzAyMTc6IHdlIHN0aWxsIG5lZWQgYWxsIENNIGZvciBwcm9wZXIgZXJyb3IgZm9ybWF0dGluZ1xyXG5cdC8vIGJ1dCBub3JtIG9ubHkgbmVlZHMgTlNNIHN1YnNldCB0aGF0IGFyZSBwb3RlbnRpYWxseS12YWxpZFxyXG5cdENNID0gcmVhZF9zb3J0ZWRfYXJyYXkoKTtcclxuXHROU00gPSBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkubWFwKGkgPT4gQ01baV0pKTtcclxuXHRDTSA9IG5ldyBTZXQoQ00pO1xyXG5cdFxyXG5cdEVTQ0FQRSA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcmludGVkXHJcblx0TkZDX0NIRUNLID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIG9ubHkgbmVlZGVkIHRvIGlsbHVzdHJhdGUgZW5zX3Rva2VuaXplKCkgdHJhbnNmb3JtYXRpb25zXHJcblxyXG5cdGxldCBjaHVua3MgPSByZWFkX3NvcnRlZF9hcnJheXMocik7XHJcblx0bGV0IHVucmVzdHJpY3RlZCA9IHIoKTtcclxuXHQvL2NvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5mbGF0TWFwKGkgPT4gY2h1bmtzW2ldKS5jb25jYXQocmVhZF9zb3J0ZWRfYXJyYXkoKSkpO1xyXG5cdGNvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IHtcclxuXHRcdC8vIDIwMjMwOTIxOiBidWlsZCBzZXQgaW4gcGFydHMsIDJ4IGZhc3RlclxyXG5cdFx0bGV0IHNldCA9IG5ldyBTZXQoKTtcclxuXHRcdHJlYWRfc29ydGVkX2FycmF5KCkuZm9yRWFjaChpID0+IHNldF9hZGRfbWFueShzZXQsIGNodW5rc1tpXSkpO1xyXG5cdFx0c2V0X2FkZF9tYW55KHNldCwgcmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0XHRyZXR1cm4gc2V0OyBcclxuXHR9O1xyXG5cdEdST1VQUyA9IHJlYWRfYXJyYXlfd2hpbGUoaSA9PiB7XHJcblx0XHQvLyBtaW5pZmllciBwcm9wZXJ0eSBtYW5nbGluZyBzZWVtcyB1bnNhZmVcclxuXHRcdC8vIHNvIHRoZXNlIGFyZSBtYW51YWxseSByZW5hbWVkIHRvIHNpbmdsZSBjaGFyc1xyXG5cdFx0bGV0IE4gPSByZWFkX2FycmF5X3doaWxlKHIpLm1hcCh4ID0+IHgrMHg2MCk7XHJcblx0XHRpZiAoTi5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IFIgPSBpID49IHVucmVzdHJpY3RlZDsgLy8gdW5yZXN0cmljdGVkIHRoZW4gcmVzdHJpY3RlZFxyXG5cdFx0XHROWzBdIC09IDMyOyAvLyBjYXBpdGFsaXplXHJcblx0XHRcdE4gPSBzdHJfZnJvbV9jcHMoTik7XHJcblx0XHRcdGlmIChSKSBOPWBSZXN0cmljdGVkWyR7Tn1dYDtcclxuXHRcdFx0bGV0IFAgPSByZWFkX2NodW5rZWQoKTsgLy8gcHJpbWFyeVxyXG5cdFx0XHRsZXQgUSA9IHJlYWRfY2h1bmtlZCgpOyAvLyBzZWNvbmRhcnlcclxuXHRcdFx0bGV0IE0gPSAhcigpOyAvLyBub3Qtd2hpdGVsaXN0ZWQsIGNoZWNrIGZvciBOU01cclxuXHRcdFx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsZXQgViA9IFsuLi5QLCAuLi5RXS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBkZXJpdmU6IHNvcnRlZCB2YWxpZFxyXG5cdFx0XHRsZXQgTSA9IHIoKS0xOyAvLyBudW1iZXIgb2YgY29tYmluaW5nIG1hcmtcclxuXHRcdFx0aWYgKE0gPCAwKSB7IC8vIHdoaXRlbGlzdGVkXHJcblx0XHRcdFx0TSA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IHIoKTtcclxuXHRcdFx0XHRcdGlmIChpKSByZXR1cm4gW1ZbaS0xXSwgcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCB2ID0gcmVhZF9hcnJheV93aGlsZShyKTtcclxuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdi5tYXAoeCA9PiB4LTEpO1xyXG5cdFx0XHRcdFx0fSldO1xyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSovXHJcblx0XHRcdHJldHVybiB7TiwgUCwgUSwgTSwgUn07XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGRlY29kZSBjb21wcmVzc2VkIHdob2xlc1xyXG5cdFdIT0xFX1ZBTElEID0gcmVhZF9zb3J0ZWRfc2V0KCk7XHJcblx0V0hPTEVfTUFQID0gbmV3IE1hcCgpO1xyXG5cdGxldCB3aG9sZXMgPSByZWFkX3NvcnRlZF9hcnJheSgpLmNvbmNhdChBcnJheV9mcm9tKFdIT0xFX1ZBTElEKSkuc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gbXVzdCBiZSBzb3J0ZWRcclxuXHR3aG9sZXMuZm9yRWFjaCgoY3AsIGkpID0+IHtcclxuXHRcdGxldCBkID0gcigpOyBcclxuXHRcdGxldCB3ID0gd2hvbGVzW2ldID0gZCA/IHdob2xlc1tpLWRdIDoge1Y6IFtdLCBNOiBuZXcgTWFwKCl9O1xyXG5cdFx0dy5WLnB1c2goY3ApOyAvLyBhZGQgdG8gbWVtYmVyIHNldFxyXG5cdFx0aWYgKCFXSE9MRV9WQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIHcpOyAgLy8gcmVnaXN0ZXIgd2l0aCB3aG9sZSBtYXBcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gY29tcHV0ZSBjb25mdXNhYmxlLWV4dGVudCBjb21wbGVtZW50c1xyXG5cdC8vIHVzYWdlOiBXSE9MRV9NQVAuZ2V0KGNwKS5NLmdldChjcCkgPSBjb21wbGVtZW50IHNldFxyXG5cdGZvciAobGV0IHtWLCBNfSBvZiBuZXcgU2V0KFdIT0xFX01BUC52YWx1ZXMoKSkpIHtcclxuXHRcdC8vIGNvbm5lY3QgYWxsIGdyb3VwcyB0aGF0IGhhdmUgZWFjaCB3aG9sZSBjaGFyYWN0ZXJcclxuXHRcdGxldCByZWNzID0gW107XHJcblx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdGxldCBncyA9IEdST1VQUy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdFx0bGV0IHJlYyA9IHJlY3MuZmluZCgoe0d9KSA9PiBncy5zb21lKGcgPT4gRy5oYXMoZykpKTtcclxuXHRcdFx0aWYgKCFyZWMpIHtcclxuXHRcdFx0XHRyZWMgPSB7RzogbmV3IFNldCgpLCBWOiBbXX07XHJcblx0XHRcdFx0cmVjcy5wdXNoKHJlYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVjLlYucHVzaChjcCk7XHJcblx0XHRcdHNldF9hZGRfbWFueShyZWMuRywgZ3MpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcGVyIGNoYXJhY3RlciBjYWNoZSBncm91cHMgd2hpY2ggYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgZXh0ZW50XHJcblx0XHRsZXQgdW5pb24gPSByZWNzLmZsYXRNYXAoeCA9PiBBcnJheV9mcm9tKHguRykpOyAvLyBhbGwgb2YgdGhlIGdyb3VwcyB1c2VkIGJ5IHRoaXMgd2hvbGVcclxuXHRcdGZvciAobGV0IHtHLCBWfSBvZiByZWNzKSB7XHJcblx0XHRcdGxldCBjb21wbGVtZW50ID0gbmV3IFNldCh1bmlvbi5maWx0ZXIoZyA9PiAhRy5oYXMoZykpKTsgLy8gZ3JvdXBzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBleHRlbnRcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRcdE0uc2V0KGNwLCBjb21wbGVtZW50KTsgLy8gdGhpcyBpcyB0aGUgc2FtZSByZWZlcmVuY2VcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gY29tcHV0ZSB2YWxpZCBzZXRcclxuXHQvLyAyMDIzMDkyNDogVkFMSUQgd2FzIHVuaW9uIGJ1dCBjYW4gYmUgcmUtdXNlZFxyXG5cdFZBTElEID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMSsgZ3JvdXBzXHJcblx0bGV0IG11bHRpID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMisgZ3JvdXBzXHJcblx0Y29uc3QgYWRkX3RvX3VuaW9uID0gY3AgPT4gVkFMSUQuaGFzKGNwKSA/IG11bHRpLmFkZChjcCkgOiBWQUxJRC5hZGQoY3ApO1xyXG5cdGZvciAobGV0IGcgb2YgR1JPVVBTKSB7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlApIGFkZF90b191bmlvbihjcCk7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlEpIGFkZF90b191bmlvbihjcCk7XHJcblx0fVxyXG5cdC8vIGR1YWwgcHVycG9zZSBXSE9MRV9NQVA6IHJldHVybiBwbGFjZWhvbGRlciBpZiB1bmlxdWUgbm9uLWNvbmZ1c2FibGVcclxuXHRmb3IgKGxldCBjcCBvZiBWQUxJRCkge1xyXG5cdFx0aWYgKCFXSE9MRV9NQVAuaGFzKGNwKSAmJiAhbXVsdGkuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCBVTklRVUVfUEgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyBhZGQgYWxsIGRlY29tcG9zZWQgcGFydHNcclxuXHQvLyBzZWUgZGVyaXZlOiBcIlZhbGlkIGlzIENsb3NlZCAodmlhIEJydXRlLWZvcmNlKVwiXHJcblx0c2V0X2FkZF9tYW55KFZBTElELCBuZmQoVkFMSUQpKTtcclxuXHRcclxuXHQvLyBkZWNvZGUgZW1vamlcclxuXHQvLyAyMDIzMDcxOTogZW1vamkgYXJlIG5vdyBmdWxseS1leHBhbmRlZCB0byBhdm9pZCBxdWlyayBsb2dpYyBcclxuXHRFTU9KSV9MSVNUID0gcmVhZF90cmllKHIpLm1hcCh2ID0+IEVtb2ppLmZyb20odikpLnNvcnQoY29tcGFyZV9hcnJheXMpO1xyXG5cdEVNT0pJX1JPT1QgPSBuZXcgTWFwKCk7IC8vIHRoaXMgaGFzIGFwcHJveCA3SyBub2RlcyAoMisgcGVyIGVtb2ppKVxyXG5cdGZvciAobGV0IGNwcyBvZiBFTU9KSV9MSVNUKSB7XHJcblx0XHQvLyAyMDIzMDcxOTogY2hhbmdlIHRvICpzbGlnaHRseSogc3RyaWN0ZXIgYWxnb3JpdGhtIHdoaWNoIGRpc2FsbG93cyBcclxuXHRcdC8vIGluc2VydGlvbiBvZiBtaXNwbGFjZWQgRkUwRiBpbiBlbW9qaSBzZXF1ZW5jZXMgKG1hdGNoaW5nIEVOU0lQLTE1KVxyXG5cdFx0Ly8gZXhhbXBsZTogYmVhdXRpZmllZCBbQSBCXSAoZWcuIGZsYWcgZW1vamkpIFxyXG5cdFx0Ly8gIGJlZm9yZTogYWxsb3c6IFtBIEZFMEYgQl0sIGVycm9yOiBbQSBGRTBGIEZFMEYgQl0gXHJcblx0XHQvLyAgIGFmdGVyOiBlcnJvcjogYm90aFxyXG5cdFx0Ly8gbm90ZTogdGhpcyBjb2RlIG5vdyBtYXRjaGVzIEVOU05vcm1hbGl6ZS57Y3MsamF2YX0gbG9naWNcclxuXHRcdGxldCBwcmV2ID0gW0VNT0pJX1JPT1RdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdGxldCBuZXh0ID0gcHJldi5tYXAobm9kZSA9PiB7XHJcblx0XHRcdFx0bGV0IGNoaWxkID0gbm9kZS5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmICghY2hpbGQpIHtcclxuXHRcdFx0XHRcdC8vIHNob3VsZCB0aGlzIGJlIG9iamVjdD8gXHJcblx0XHRcdFx0XHQvLyAobW9zdCBoYXZlIDEtMiBpdGVtcywgZmV3IGhhdmUgbWFueSlcclxuXHRcdFx0XHRcdC8vIDIwMjMwNzE5OiBubywgdjggZGVmYXVsdCBtYXAgaXMgND9cclxuXHRcdFx0XHRcdGNoaWxkID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFx0bm9kZS5zZXQoY3AsIGNoaWxkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKGNwID09PSBGRTBGKSB7XHJcblx0XHRcdFx0cHJldi5wdXNoKC4uLm5leHQpOyAvLyBsZXNzIHRoYW4gMjAgZWxlbWVudHNcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwcmV2ID0gbmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChsZXQgeCBvZiBwcmV2KSB7XHJcblx0XHRcdHguViA9IGNwcztcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGlmIGVzY2FwZWQ6IHtIRVh9XHJcbi8vICAgICAgIGVsc2U6IFwieFwiIHtIRVh9XHJcbmZ1bmN0aW9uIHF1b3RlZF9jcChjcCkge1xyXG5cdHJldHVybiAoc2hvdWxkX2VzY2FwZShjcCkgPyAnJyA6IGAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoW2NwXSkpfSBgKSArIHF1b3RlX2NwKGNwKTtcclxufVxyXG5cclxuLy8gMjAyMzAyMTE6IHNvbWUgbWVzc2FnZXMgY2FuIGJlIG1peGVkLWRpcmVjdGlvbmFsIGFuZCByZXN1bHQgaW4gc3BpbGxvdmVyXHJcbi8vIHVzZSAyMDBFIGFmdGVyIGEgcXVvdGVkIHN0cmluZyB0byBmb3JjZSB0aGUgcmVtYWluZGVyIG9mIGEgc3RyaW5nIGZyb20gXHJcbi8vIGFjcXVyaW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHF1b3RlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1iaWRpLXVuaWNvZGUtY29udHJvbHMjZXhjZXB0aW9uc1xyXG5mdW5jdGlvbiBiaWRpX3FxKHMpIHtcclxuXHRyZXR1cm4gYFwiJHtzfVwiXFx1MjAwRWA7IC8vIHN0cm9uZyBMVFJcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfbGFiZWxfZXh0ZW5zaW9uKGNwcykge1xyXG5cdGlmIChjcHMubGVuZ3RoID49IDQgJiYgY3BzWzJdID09IEhZUEhFTiAmJiBjcHNbM10gPT0gSFlQSEVOKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbGFiZWwgZXh0ZW5zaW9uOiBcIiR7c3RyX2Zyb21fY3BzKGNwcy5zbGljZSgwLCA0KSl9XCJgKTsgLy8gdGhpcyBjYW4gb25seSBiZSBhc2NpaSBzbyBjYW50IGJlIGJpZGlcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKGNwcykge1xyXG5cdGNvbnN0IFVOREVSU0NPUkUgPSAweDVGO1xyXG5cdGZvciAobGV0IGkgPSBjcHMubGFzdEluZGV4T2YoVU5ERVJTQ09SRSk7IGkgPiAwOyApIHtcclxuXHRcdGlmIChjcHNbLS1pXSAhPT0gVU5ERVJTQ09SRSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuZGVyc2NvcmUgYWxsb3dlZCBvbmx5IGF0IHN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbi8vIGNoZWNrIHRoYXQgYSBmZW5jZWQgY3AgaXMgbm90IGxlYWRpbmcsIHRyYWlsaW5nLCBvciB0b3VjaGluZyBhbm90aGVyIGZlbmNlZCBjcFxyXG5mdW5jdGlvbiBjaGVja19mZW5jZWQoY3BzKSB7XHJcblx0bGV0IGNwID0gY3BzWzBdO1xyXG5cdGxldCBwcmV2ID0gRkVOQ0VELmdldChjcCk7XHJcblx0aWYgKHByZXYpIHRocm93IGVycm9yX3BsYWNlbWVudChgbGVhZGluZyAke3ByZXZ9YCk7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGxldCBsYXN0ID0gLTE7IC8vIHByZXZlbnRzIHRyYWlsaW5nIGZyb20gdGhyb3dpbmdcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xyXG5cdFx0Y3AgPSBjcHNbaV07XHJcblx0XHRsZXQgbWF0Y2ggPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRcdGlmIChtYXRjaCkge1xyXG5cdFx0XHQvLyBzaW5jZSBjcHNbMF0gaXNuJ3QgZmVuY2VkLCBjcHNbMV0gY2Fubm90IHRocm93XHJcblx0XHRcdGlmIChsYXN0ID09IGkpIHRocm93IGVycm9yX3BsYWNlbWVudChgJHtwcmV2fSArICR7bWF0Y2h9YCk7XHJcblx0XHRcdGxhc3QgPSBpICsgMTtcclxuXHRcdFx0cHJldiA9IG1hdGNoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobGFzdCA9PSBuKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYHRyYWlsaW5nICR7cHJldn1gKTtcclxufVxyXG5cclxuLy8gY3JlYXRlIGEgc2FmZSB0byBwcmludCBzdHJpbmcgXHJcbi8vIGludmlzaWJsZXMgYXJlIGVzY2FwZWRcclxuLy8gbGVhZGluZyBjbSB1c2VzIHBsYWNlaG9sZGVyXHJcbi8vIGlmIGNwcyBleGNlZWQgbWF4LCBtaWRkbGUgdHJ1bmNhdGUgd2l0aCBlbGxpcHNpc1xyXG4vLyBxdW90ZXIoY3ApID0+IHN0cmluZywgZWcuIDMwMDAgPT4gXCJ7MzAwMH1cIlxyXG4vLyBub3RlOiBpbiBodG1sLCB5b3UnZCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiByZXBsYWNlIFs8PiZdIHdpdGggZW50aXRpZXNcclxuZnVuY3Rpb24gc2FmZV9zdHJfZnJvbV9jcHMoY3BzLCBtYXggPSBJbmZpbml0eSwgcXVvdGVyID0gcXVvdGVfY3ApIHtcclxuXHQvL2lmIChOdW1iZXIuaXNJbnRlZ2VyKGNwcykpIGNwcyA9IFtjcHNdO1xyXG5cdC8vaWYgKCFBcnJheS5pc0FycmF5KGNwcykpIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGNvZGVwb2ludHNgKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0aWYgKGlzX2NvbWJpbmluZ19tYXJrKGNwc1swXSkpIGJ1Zi5wdXNoKCfil4wnKTtcclxuXHRpZiAoY3BzLmxlbmd0aCA+IG1heCkge1xyXG5cdFx0bWF4ID4+PSAxO1xyXG5cdFx0Y3BzID0gWy4uLmNwcy5zbGljZSgwLCBtYXgpLCAweDIwMjYsIC4uLmNwcy5zbGljZSgtbWF4KV07XHJcblx0fVxyXG5cdGxldCBwcmV2ID0gMDtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpXTtcclxuXHRcdGlmIChzaG91bGRfZXNjYXBlKGNwKSkge1xyXG5cdFx0XHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIGkpKSk7XHJcblx0XHRcdGJ1Zi5wdXNoKHF1b3RlcihjcCkpO1xyXG5cdFx0XHRwcmV2ID0gaSArIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgbikpKTtcclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG4vLyBub3RlOiBzZXQocykgY2Fubm90IGJlIGV4cG9zZWQgYmVjYXVzZSB0aGV5IGNhbiBiZSBtb2RpZmllZFxyXG4vLyBub3RlOiBPYmplY3QuZnJlZXplKCkgZG9lc24ndCB3b3JrXHJcbmZ1bmN0aW9uIGlzX2NvbWJpbmluZ19tYXJrKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIGFycmF5X3JlcGxhY2Uob3V0cHV0LCAweDNCRSwgMHgzOUUpO1xyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvYmlkaS1sYWJlbC1vcmRlcmluZy1zcG9vZi8xNTgyNFxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKGxhYmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5X3JlcGxhY2UodiwgYSwgYikge1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IG5leHQgPSB2LmluZGV4T2YoYSwgcHJldik7XHJcblx0XHRpZiAobmV4dCA8IDApIGJyZWFrO1xyXG5cdFx0dltuZXh0XSA9IGI7IFxyXG5cdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0cmV0dXJuIHNwbGl0KG5hbWUsIG5mYywgcHJlc2VydmVfZW1vamkgPyB4ID0+IHguc2xpY2UoKSA6IGZpbHRlcl9mZTBmKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChuYW1lLCBuZiwgZWYpIHtcclxuXHRpZiAoIW5hbWUpIHJldHVybiBbXTsgLy8gMjAyMzA3MTk6IGVtcHR5IG5hbWUgYWxsb3dhbmNlXHJcblx0aW5pdCgpO1xyXG5cdGxldCBvZmZzZXQgPSAwO1xyXG5cdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdC8vIDQuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cIlxyXG5cdHJldHVybiBuYW1lLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiB7XHJcblx0XHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKGxhYmVsKTtcclxuXHRcdGxldCBpbmZvID0ge1xyXG5cdFx0XHRpbnB1dCxcclxuXHRcdFx0b2Zmc2V0LCAvLyBjb2RlcG9pbnQsIG5vdCBzdWJzdHJpbmchXHJcblx0XHR9O1xyXG5cdFx0b2Zmc2V0ICs9IGlucHV0Lmxlbmd0aCArIDE7IC8vICsgc3RvcFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpO1xyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vbm9ybSA9IFtdO1xyXG5cdFx0XHRcdC8vdHlwZSA9ICdOb25lJzsgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBuZXh0IG1hdGNoLCBcIkFTQ0lJXCJcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IFxyXG5cdFx0XHRsZXQgbm9ybSA9IGluZm8ub3V0cHV0ID0gdG9rZW5zLmZsYXQoKTtcclxuXHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRsZXQgZW1vamkgPSBpbmZvLmVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IHRva2Vuc1swXS5pc19lbW9qaTsgLy8gc2FtZSBhczogdG9rZW5zLnNvbWUoeCA9PiB4LmlzX2Vtb2ppKTtcclxuXHRcdFx0aWYgKCFlbW9qaSAmJiBub3JtLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkpIHsgLy8gc3BlY2lhbCBjYXNlIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRjaGVja19sYWJlbF9leHRlbnNpb24obm9ybSk7IC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgY21cclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0dHlwZSA9ICdBU0NJSSc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdGlmICghY2hhcnMubGVuZ3RoKSB7IC8vIHRoZXJlcyBubyB0ZXh0LCBqdXN0IGVtb2ppXHJcblx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gNS4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5fY291bnQ7IGkrKykgeyAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIGZpcnN0IHRva2VuXHJcblx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0Ly8gYmlkaV9xcSgpIG5vdCBuZWVkZWQgc2luY2UgZW1vamkgaXMgTFRSIGFuZCBjcHMgaXMgYSBDTVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdGxldCB1bmlxdWUgPSBBcnJheV9mcm9tKG5ldyBTZXQoY2hhcnMpKTtcclxuXHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHQvLyBhbHRlcm5hdGl2ZTogY291bGQgZm9ybSBhIGh5YnJpZCB0eXBlOiBMYXRpbi9KYXBhbmVzZS8uLi5cdFxyXG5cdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHR0eXBlID0gZy5OO1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0Ly8gb3IgZXZlbiBiZXR0ZXI6IHR5cGUuZW5kc1dpdGgoJ10nKVxyXG5cdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogQXJyYXlfZnJvbShzZXQpO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYWluaW5nIGdyb3Vwc1xyXG5cdFx0Ly8gY29udGFpbiB0aGUgc2hhcmVkIGNoYXJhY3RlcnMgdG9vXHJcblx0XHRmb3IgKGxldCBnIG9mIG1ha2VyKSB7XHJcblx0XHRcdGlmIChzaGFyZWQuZXZlcnkoY3AgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKCFHUk9VUFMuc29tZShnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7IFxyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdC8vIDIwMjMwNzE2OiBjaGFuZ2UgdG8gbW9yZSBleGFjdCBzdGF0ZW1lbnQsIHNlZTogRU5TTm9ybWFsaXplLntjcyxqYXZhfVxyXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGEgY29tcG9zaXRpb25cclxuXHRcdFx0XHQvLyAyMDIzMDcyMDogY2hhbmdlIHRvIGZ1bGwgY2hlY2tcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTsgLy8gdGhpcyBzaG91bGQgYmUgcmFyZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIGdyb3VwIHRoYXQgY29udGFpbnMgYWxsIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRcdFx0XHQvLyB0aHJvdyB1c2luZyB0aGUgaGlnaGVzdCBwcmlvcml0eSBncm91cCB0aGF0IG1hdGNoZWRcclxuXHRcdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihncm91cHNbMF0sIGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Z3JvdXBzID0gZ3M7XHJcblx0XHRpZiAoZ3MubGVuZ3RoID09IDEpIGJyZWFrOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSBncm91cCBsZWZ0XHJcblx0fVxyXG5cdC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAxIGdyb3VwKHMpIHdpdGggYWxsIG9mIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRyZXR1cm4gZ3JvdXBzO1xyXG59XHJcblxyXG4vLyB0aHJvdyBvbiBmaXJzdCBlcnJvclxyXG5mdW5jdGlvbiBmbGF0dGVuKHNwbGl0KSB7XHJcblx0cmV0dXJuIHNwbGl0Lm1hcCgoe2lucHV0LCBlcnJvciwgb3V0cHV0fSkgPT4ge1xyXG5cdFx0aWYgKGVycm9yKSB7XHJcblx0XHRcdC8vIGRvbid0IHByaW50IGxhYmVsIGFnYWluIGlmIGp1c3QgYSBzaW5nbGUgbGFiZWxcclxuXHRcdFx0bGV0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcblx0XHRcdC8vIGJpZGlfcXEoKSBvbmx5IG5lY2Vzc2FyeSBpZiBtc2cgaXMgZGlnaXRzXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihzcGxpdC5sZW5ndGggPT0gMSA/IG1zZyA6IGBJbnZhbGlkIGxhYmVsICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhpbnB1dCwgNjMpKX06ICR7bXNnfWApOyBcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHJfZnJvbV9jcHMob3V0cHV0KTtcclxuXHR9KS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvcl9kaXNhbGxvd2VkKGNwKSB7XHJcblx0Ly8gVE9ETzogYWRkIGNwIHRvIGVycm9yP1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZF9jcChjcCl9YCk7IFxyXG59XHJcbmZ1bmN0aW9uIGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCkge1xyXG5cdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdGxldCBnZyA9IEdST1VQUy5maW5kKGcgPT4gZy5QLmhhcyhjcCkpOyAvLyBvbmx5IGNoZWNrIHByaW1hcnlcclxuXHRpZiAoZ2cpIHtcclxuXHRcdHF1b3RlZCA9IGAke2dnLk59ICR7cXVvdGVkfWA7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgbWl4dHVyZTogJHtnLk59ICsgJHtxdW90ZWR9YCk7XHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfcGxhY2VtZW50KHdoZXJlKSB7XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBwbGFjZW1lbnQ6ICR7d2hlcmV9YCk7XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IGNwcy5sZW5ndGggPiAwXHJcbi8vIGFzc3VtcHRpb246IGNwc1swXSBpc24ndCBhIENNXHJcbi8vIGFzc3VtcHRpb246IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXNuJ3QgYW4gZW1vamlcclxuZnVuY3Rpb24gY2hlY2tfZ3JvdXAoZywgY3BzKSB7XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRpZiAoIWdyb3VwX2hhc19jcChnLCBjcCkpIHtcclxuXHRcdFx0Ly8gZm9yIHdoaXRlbGlzdGVkIHNjcmlwdHMsIHRoaXMgd2lsbCB0aHJvdyBpbGxlZ2FsIG1peHR1cmUgb24gaW52YWxpZCBjbSwgZWcuIFwiZXszMDB9ezMwMH1cIlxyXG5cdFx0XHQvLyBhdCB0aGUgbW9tZW50LCBpdCdzIHVubmVjZXNzYXJ5IHRvIGludHJvZHVjZSBhbiBleHRyYSBlcnJvciB0eXBlXHJcblx0XHRcdC8vIHVudGlsIHRoZXJlIGV4aXN0cyBhIHdoaXRlbGlzdGVkIG11bHRpLWNoYXJhY3RlclxyXG5cdFx0XHQvLyAgIGVnLiBpZiAoTSA8IDAgJiYgaXNfY29tYmluaW5nX21hcmsoY3ApKSB7IC4uLiB9XHJcblx0XHRcdC8vIHRoZXJlIGFyZSAzIGNhc2VzOlxyXG5cdFx0XHQvLyAgIDEuIGlsbGVnYWwgY20gZm9yIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0Ly8gICAyLiBpbGxlZ2FsIGNtIGZvciBzYW1lIGdyb3VwID0+IGNtIGVycm9yXHJcblx0XHRcdC8vICAgICAgIHJlcXVpcmVzIHNldCBvZiB3aGl0ZWxpc3QgY20gcGVyIGdyb3VwOiBcclxuXHRcdFx0Ly8gICAgICAgIGVnLiBuZXcgU2V0KFsuLi5nLlAsIC4uLmcuUV0uZmxhdE1hcChuZmMpLmZpbHRlcihjcCA9PiBDTS5oYXMoY3ApKSlcclxuXHRcdFx0Ly8gICAzLiB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vaWYgKE0gPj0gMCkgeyAvLyB3ZSBoYXZlIGEga25vd24gZml4ZWQgY20gY291bnRcclxuXHRpZiAoZy5NKSB7IC8vIHdlIG5lZWQgdG8gY2hlY2sgZm9yIE5TTVxyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gc2VlOiBhc3N1bXB0aW9uXHJcblx0XHRcdC8vIDIwMjMwMjEwOiBidWdmaXg6IHVzaW5nIGNwcyBpbnN0ZWFkIG9mIGRlY29tcG9zZWQgaC90IENhcmJvbjIyNVxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6ICR7Zy5OfSAke2JpZGlfcXEoc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHRcdCovXHJcblx0XHRcdC8vIDIwMjMwMjE3OiBzd2l0Y2ggdG8gTlNNIGNvdW50aW5nXHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jT3B0aW9uYWxfRGV0ZWN0aW9uXHJcblx0XHRcdGlmIChOU00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHRmb3IgKGxldCBjcDsgaiA8IGUgJiYgTlNNLmhhcyhjcCA9IGRlY29tcG9zZWRbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdC8vIGEuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbm9uc3BhY2luZyBtYXJrLlxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IGk7IGsgPCBqOyBrKyspIHsgLy8gTyhuXjIpIGJ1dCBuIDwgMTAwXHJcblx0XHRcdFx0XHRcdGlmIChkZWNvbXBvc2VkW2tdID09IGNwKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUgbm9uLXNwYWNpbmcgbWFya3M6ICR7cXVvdGVkX2NwKGNwKX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBwYXJzZSB0byBlbmQgc28gd2UgaGF2ZSBmdWxsIG5zbSBjb3VudFxyXG5cdFx0XHRcdC8vIGIuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgbW9yZSB0aGFuIDQgbm9uc3BhY2luZyBtYXJrcyAoZ2M9TW4gb3IgZ2M9TWUpLlxyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE5TTV9NQVgpIHtcclxuXHRcdFx0XHRcdC8vIG5vdGU6IHRoaXMgc2xpY2Ugc3RhcnRzIHdpdGggYSBiYXNlIGNoYXIgb3Igc3BhY2luZy1tYXJrIGNtXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGV4Y2Vzc2l2ZSBub24tc3BhY2luZyBtYXJrczogJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TlNNX01BWH0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHQvKlxyXG5cdGxldCBjbV93aGl0ZWxpc3QgPSBNIGluc3RhbmNlb2YgTWFwO1xyXG5cdGZvciAobGV0IGkgPSAwLCBlID0gY3BzLmxlbmd0aDsgaSA8IGU7ICkge1xyXG5cdFx0bGV0IGNwID0gY3BzW2krK107XHJcblx0XHRsZXQgc2VxcyA9IGNtX3doaXRlbGlzdCAmJiBNLmdldChjcCk7XHJcblx0XHRpZiAoc2VxcykgeyBcclxuXHRcdFx0Ly8gbGlzdCBvZiBjb2RlcG9pbnRzIHRoYXQgY2FuIGZvbGxvd1xyXG5cdFx0XHQvLyBpZiB0aGlzIGV4aXN0cywgdGhpcyB3aWxsIGFsd2F5cyBiZSAxK1xyXG5cdFx0XHRsZXQgaiA9IGk7XHJcblx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoY3BzW2pdKSkgaisrO1xyXG5cdFx0XHRsZXQgY21zID0gY3BzLnNsaWNlKGksIGopO1xyXG5cdFx0XHRsZXQgbWF0Y2ggPSBzZXFzLmZpbmQoc2VxID0+ICFjb21wYXJlX2FycmF5cyhzZXEsIGNtcykpO1xyXG5cdFx0XHRpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY29tYmluaW5nIG1hcmsgc2VxdWVuY2U6IFwiJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3AsIC4uLmNtc10pfVwiYCk7XHJcblx0XHRcdGkgPSBqO1xyXG5cdFx0fSBlbHNlIGlmICghVi5oYXMoY3ApKSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0XHRsZXQgdSA9IFVOSVFVRS5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmICh1ICYmIHUgIT09IGcpIHtcclxuXHRcdFx0XHRcdC8vIGlmIGJvdGggc2NyaXB0cyBhcmUgcmVzdHJpY3RlZCB0aGlzIGVycm9yIGlzIGNvbmZ1c2luZ1xyXG5cdFx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCBkaWZmZXJlbnRpYXRlIFJlc3RyaWN0ZWRBIGZyb20gUmVzdHJpY3RlZEIgXHJcblx0XHRcdFx0XHRpZiAoIXUuUikgcXVvdGVkID0gYCR7cXVvdGVkfSBpcyAke3UuTn1gO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCAke2cuTn0gY2hhcmFjdGVyOiAke3F1b3RlZH1gKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZH0gKGV4cGVjdGVkICR7Zy5OfSlgKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYCR7Zy5OfSBkb2VzIG5vdCBhbGxvdzogJHtxdW90ZWR9YCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICghY21fd2hpdGVsaXN0KSB7XHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyB3ZSBrbm93IGl0IGNhbid0IGJlIGNtIGxlYWRpbmdcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiBcIiR7c3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSl9XCIgKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQqL1xyXG59XHJcblxyXG4vLyBnaXZlbiBhIGxpc3Qgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIGEgbGlzdCBvZiBsaXN0cywgd2hlcmUgZW1vamkgYXJlIGEgZnVsbHktcXVhbGlmaWVkIChhcyBBcnJheSBzdWJjbGFzcylcclxuLy8gZWcuIGV4cGxvZGVfY3AoXCJhYmPwn5KpZFwiKSA9PiBbWzYxLCA2MiwgNjNdLCBFbW9qaVsxRjRBOSwgRkUwRl0sIFs2NF1dXHJcbi8vIDIwMjMwODE4OiByZW5hbWUgZm9yICdwcm9jZXNzJyBuYW1lIGNvbGxpc2lvbiBoL3QgSmF2YXJvbWVcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvMjNcclxuZnVuY3Rpb24gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGNoYXJzID0gW107XHJcblx0aW5wdXQgPSBpbnB1dC5zbGljZSgpLnJldmVyc2UoKTsgLy8gZmxpcCBzbyB3ZSBjYW4gcG9wXHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0XHRcdFx0Y2hhcnMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXQucHVzaChlZihlbW9qaSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0Y2hhcnMucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdGNoYXJzLnB1c2goLi4uY3BzKTsgLy8gbGVzcyB0aGFuIDEwIGVsZW1lbnRzXHJcblx0XHRcdFx0fSBlbHNlIGlmICghSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0XHQvLyAyMDIzMDkxMjogdW5pY29kZSAxNS4xIGNoYW5nZWQgdGhlIG9yZGVyIG9mIHByb2Nlc3Npbmcgc3VjaCB0aGF0XHJcblx0XHRcdFx0XHQvLyBkaXNhbGxvd2VkIHBhcnRzIGFyZSBvbmx5IHJlamVjdGVkIGFmdGVyIE5GQ1xyXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0XHRcdFx0XHQvLyB0aGlzIGRvZXNuJ3QgaW1wYWN0IG5vcm1hbGl6YXRpb24gYXMgb2YgdG9kYXlcclxuXHRcdFx0XHRcdC8vIHRlY2huaWNhbGx5LCB0aGlzIGVycm9yIGNhbiBiZSByZW1vdmVkIGFzIHRoZSBncm91cCBsb2dpYyB3aWxsIGFwcGx5IHNpbWlsYXIgbG9naWNcclxuXHRcdFx0XHRcdC8vIGhvd2V2ZXIgdGhlIGVycm9yIHR5cGUgbWlnaHQgYmUgbGVzcyBjbGVhclxyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcl9mZTBmKGNwcykge1xyXG5cdHJldHVybiBjcHMuZmlsdGVyKGNwID0+IGNwICE9IEZFMEYpO1xyXG59XHJcblxyXG4vLyBnaXZlbiBhcnJheSBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgdGhlIGxvbmdlc3QgdmFsaWQgZW1vamkgc2VxdWVuY2UgKG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaClcclxuLy8gKk1VVEFURVMqIHRoZSBzdXBwbGllZCBhcnJheVxyXG4vLyBkaXNhbGxvd3MgaW50ZXJsZWF2ZWQgaWdub3JlZCBjaGFyYWN0ZXJzXHJcbi8vIGZpbGxzIChvcHRpb25hbCkgZWF0ZW4gYXJyYXkgd2l0aCBtYXRjaGVkIGNvZGVwb2ludHNcclxuZnVuY3Rpb24gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChjcHMsIGVhdGVuKSB7XHJcblx0bGV0IG5vZGUgPSBFTU9KSV9ST09UO1xyXG5cdGxldCBlbW9qaTtcclxuXHRsZXQgcG9zID0gY3BzLmxlbmd0aDtcclxuXHR3aGlsZSAocG9zKSB7XHJcblx0XHRub2RlID0gbm9kZS5nZXQoY3BzWy0tcG9zXSk7XHJcblx0XHRpZiAoIW5vZGUpIGJyZWFrO1xyXG5cdFx0bGV0IHtWfSA9IG5vZGU7XHJcblx0XHRpZiAoVikgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcclxuXHRcdFx0ZW1vamkgPSBWO1xyXG5cdFx0XHRpZiAoZWF0ZW4pIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gKG9wdGlvbmFsKSBjb3B5IGlucHV0LCB1c2VkIGZvciBlbnNfdG9rZW5pemUoKVxyXG5cdFx0XHRjcHMubGVuZ3RoID0gcG9zOyAvLyB0cnVuY2F0ZVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZW1vamk7XHJcbn1cclxuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyB0b2tlbml6ZXIgXHJcblxyXG5jb25zdCBUWV9WQUxJRCA9ICd2YWxpZCc7XHJcbmNvbnN0IFRZX01BUFBFRCA9ICdtYXBwZWQnO1xyXG5jb25zdCBUWV9JR05PUkVEID0gJ2lnbm9yZWQnO1xyXG5jb25zdCBUWV9ESVNBTExPV0VEID0gJ2Rpc2FsbG93ZWQnO1xyXG5jb25zdCBUWV9FTU9KSSA9ICdlbW9qaSc7XHJcbmNvbnN0IFRZX05GQyA9ICduZmMnO1xyXG5jb25zdCBUWV9TVE9QID0gJ3N0b3AnO1xyXG5cclxuZnVuY3Rpb24gZW5zX3Rva2VuaXplKG5hbWUsIHtcclxuXHRuZiA9IHRydWUsIC8vIGNvbGxhcHNlIHVubm9ybWFsaXplZCBydW5zIGludG8gYSBzaW5nbGUgdG9rZW5cclxufSA9IHt9KSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobmFtZSkucmV2ZXJzZSgpO1xyXG5cdGxldCBlYXRlbiA9IFtdO1xyXG5cdGxldCB0b2tlbnMgPSBbXTtcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0LCBlYXRlbik7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0dG9rZW5zLnB1c2goe1xyXG5cdFx0XHRcdHR5cGU6IFRZX0VNT0pJLFxyXG5cdFx0XHRcdGVtb2ppOiBlbW9qaS5zbGljZSgpLCAvLyBjb3B5IGVtb2ppXHJcblx0XHRcdFx0aW5wdXQ6IGVhdGVuLFxyXG5cdFx0XHRcdGNwczogZmlsdGVyX2ZlMGYoZW1vamkpXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRlYXRlbiA9IFtdOyAvLyByZXNldCBidWZmZXJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoY3AgPT0gU1RPUCkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9TVE9QLCBjcH0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfVkFMSUQsIGNwczogW2NwXX0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKElHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9JR05PUkVELCBjcH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfTUFQUEVELCBjcCwgY3BzOiBjcHMuc2xpY2UoKX0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfRElTQUxMT1dFRCwgY3B9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG5mKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAtMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgdG9rZW4gPSB0b2tlbnNbaV07XHJcblx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodG9rZW4udHlwZSkpIHtcclxuXHRcdFx0XHRpZiAocmVxdWlyZXNfY2hlY2sodG9rZW4uY3BzKSkgeyAvLyBub3JtYWxpemF0aW9uIG1pZ2h0IGJlIG5lZWRlZFxyXG5cdFx0XHRcdFx0bGV0IGVuZCA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgcG9zID0gZW5kOyBwb3MgPCB0b2tlbnMubGVuZ3RoOyBwb3MrKykgeyAvLyBmaW5kIGFkamFjZW50IHRleHRcclxuXHRcdFx0XHRcdFx0bGV0IHt0eXBlLCBjcHN9ID0gdG9rZW5zW3Bvc107XHJcblx0XHRcdFx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodHlwZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlcXVpcmVzX2NoZWNrKGNwcykpIGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHBvcyArIDE7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyB8fCB0eXBlICE9PSBUWV9ESVNBTExPV0VEKSB7IFxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoc3RhcnQgPCAwKSBzdGFydCA9IGk7XHJcblx0XHRcdFx0XHRsZXQgc2xpY2UgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblx0XHRcdFx0XHRsZXQgY3BzMCA9IHNsaWNlLmZsYXRNYXAoeCA9PiBpc192YWxpZF9vcl9tYXBwZWQoeC50eXBlKSA/IHguY3BzIDogW10pOyAvLyBzdHJpcCBqdW5rIHRva2Vuc1xyXG5cdFx0XHRcdFx0bGV0IGNwcyA9IG5mYyhjcHMwKTtcclxuXHRcdFx0XHRcdGlmIChjb21wYXJlX2FycmF5cyhjcHMsIGNwczApKSB7IC8vIGJ1bmRsZSBpbnRvIGFuIG5mYyB0b2tlblxyXG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCwge1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFRZX05GQywgXHJcblx0XHRcdFx0XHRcdFx0aW5wdXQ6IGNwczAsIC8vIHRoZXJlIGFyZSAzIHN0YXRlczogdG9rZW5zMCA9PShwcm9jZXNzKT0+IGlucHV0ID09KG5mYyk9PiB0b2tlbnMvY3BzXHJcblx0XHRcdFx0XHRcdFx0Y3BzLCBcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnMwOiBjb2xsYXBzZV92YWxpZF90b2tlbnMoc2xpY2UpLFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczogZW5zX3Rva2VuaXplKHN0cl9mcm9tX2NwcyhjcHMpLCB7bmY6IGZhbHNlfSlcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdGkgPSBzdGFydDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7IFxyXG5cdFx0XHRcdFx0XHRpID0gZW5kIC0gMTsgLy8gc2tpcCB0byBlbmQgb2Ygc2xpY2VcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gaTsgLy8gcmVtZW1iZXIgbGFzdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIDIwMjIxMDI0OiBpcyB0aGlzIGNvcnJlY3Q/XHJcblx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSB7XHJcblx0cmV0dXJuIHR5cGUgPT0gVFlfVkFMSUQgfHwgdHlwZSA9PSBUWV9NQVBQRUQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVzX2NoZWNrKGNwcykge1xyXG5cdHJldHVybiBjcHMuc29tZShjcCA9PiBORkNfQ0hFQ0suaGFzKGNwKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpIHtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHRva2Vuc1tpXS50eXBlID09IFRZX1ZBTElEKSB7XHJcblx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdHdoaWxlIChqIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbal0udHlwZSA9PSBUWV9WQUxJRCkgaisrO1xyXG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksIGogLSBpLCB7dHlwZTogVFlfVkFMSUQsIGNwczogdG9rZW5zLnNsaWNlKGksIGopLmZsYXRNYXAoeCA9PiB4LmNwcyl9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRva2VucztcclxufVxuXG5leHBvcnQgeyBlbnNfYmVhdXRpZnksIGVuc19lbW9qaSwgZW5zX25vcm1hbGl6ZSwgZW5zX25vcm1hbGl6ZV9mcmFnbWVudCwgZW5zX3NwbGl0LCBlbnNfdG9rZW5pemUsIGlzX2NvbWJpbmluZ19tYXJrLCBuZmMsIG5mZCwgc2FmZV9zdHJfZnJvbV9jcHMsIHNob3VsZF9lc2NhcGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@adraffy+ens-normalize@1.10.1/node_modules/@adraffy/ens-normalize/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@metamask+detect-provider@2.0.0/node_modules/@metamask/detect-provider/dist/index.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+detect-provider@2.0.0/node_modules/@metamask/detect-provider/dist/index.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Returns a Promise that resolves to the value of window.ethereum if it is\n * set within the given timeout, or null.\n * The Promise will not reject, but an error will be thrown if invalid options\n * are provided.\n *\n * @param options - Options bag.\n * @param options.mustBeMetaMask - Whether to only look for MetaMask providers.\n * Default: false\n * @param options.silent - Whether to silence console errors. Does not affect\n * thrown errors. Default: false\n * @param options.timeout - Milliseconds to wait for 'ethereum#initialized' to\n * be dispatched. Default: 3000\n * @returns A Promise that resolves with the Provider if it is detected within\n * given timeout, otherwise null.\n */\nfunction detectEthereumProvider({ mustBeMetaMask = false, silent = false, timeout = 3000, } = {}) {\n    _validateInputs();\n    let handled = false;\n    return new Promise((resolve) => {\n        if (window.ethereum) {\n            handleEthereum();\n        }\n        else {\n            window.addEventListener('ethereum#initialized', handleEthereum, { once: true });\n            setTimeout(() => {\n                handleEthereum();\n            }, timeout);\n        }\n        function handleEthereum() {\n            if (handled) {\n                return;\n            }\n            handled = true;\n            window.removeEventListener('ethereum#initialized', handleEthereum);\n            const { ethereum } = window;\n            if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {\n                resolve(ethereum);\n            }\n            else {\n                const message = mustBeMetaMask && ethereum\n                    ? 'Non-MetaMask window.ethereum detected.'\n                    : 'Unable to detect window.ethereum.';\n                !silent && console.error('@metamask/detect-provider:', message);\n                resolve(null);\n            }\n        }\n    });\n    function _validateInputs() {\n        if (typeof mustBeMetaMask !== 'boolean') {\n            throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);\n        }\n        if (typeof silent !== 'boolean') {\n            throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);\n        }\n        if (typeof timeout !== 'number') {\n            throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);\n        }\n    }\n}\nmodule.exports = detectEthereumProvider;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWdCQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxTQUFTLHNCQUFzQixDQUErQixFQUM1RCxjQUFjLEdBQUcsS0FBSyxFQUN0QixNQUFNLEdBQUcsS0FBSyxFQUNkLE9BQU8sR0FBRyxJQUFJLEdBQ2YsR0FBRyxFQUFFO0lBRUosZUFBZSxFQUFFLENBQUM7SUFFbEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBRXBCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtRQUM3QixJQUFLLE1BQWlCLENBQUMsUUFBUSxFQUFFO1lBRS9CLGNBQWMsRUFBRSxDQUFDO1NBRWxCO2FBQU07WUFFTCxNQUFNLENBQUMsZ0JBQWdCLENBQ3JCLHNCQUFzQixFQUN0QixjQUFjLEVBQ2QsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQ2YsQ0FBQztZQUVGLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2QsY0FBYyxFQUFFLENBQUM7WUFDbkIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2I7UUFFRCxTQUFTLGNBQWM7WUFFckIsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTzthQUNSO1lBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQztZQUVmLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxzQkFBc0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUVuRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBZ0IsQ0FBQztZQUV0QyxJQUFJLFFBQVEsSUFBSSxDQUFDLENBQUMsY0FBYyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDeEQsT0FBTyxDQUFDLFFBQXdCLENBQUMsQ0FBQzthQUNuQztpQkFBTTtnQkFFTCxNQUFNLE9BQU8sR0FBRyxjQUFjLElBQUksUUFBUTtvQkFDeEMsQ0FBQyxDQUFDLHdDQUF3QztvQkFDMUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDO2dCQUV4QyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNoRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDZjtRQUNILENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsZUFBZTtRQUN0QixJQUFJLE9BQU8sY0FBYyxLQUFLLFNBQVMsRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLDhFQUE4RSxDQUFDLENBQUM7U0FDakc7UUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7UUFDRCxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQWxGRCxpQkFBUyxzQkFBc0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBNZXRhTWFza0V0aGVyZXVtUHJvdmlkZXIge1xuICBpc01ldGFNYXNrPzogYm9vbGVhbjtcbiAgb25jZShldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgbGlzdGVuZXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nIHwgc3ltYm9sLCBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdGhpcztcbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nIHwgc3ltYm9sLCBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdGhpcztcbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcgfCBzeW1ib2wsIGxpc3RlbmVyOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpOiB0aGlzO1xuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgbGlzdGVuZXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXM7XG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudD86IHN0cmluZyB8IHN5bWJvbCk6IHRoaXM7XG59XG5cbmludGVyZmFjZSBXaW5kb3cge1xuICBldGhlcmV1bT86IE1ldGFNYXNrRXRoZXJldW1Qcm92aWRlcjtcbn1cblxuZXhwb3J0ID0gZGV0ZWN0RXRoZXJldW1Qcm92aWRlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXRoZXJldW0gaWYgaXQgaXNcbiAqIHNldCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQsIG9yIG51bGwuXG4gKiBUaGUgUHJvbWlzZSB3aWxsIG5vdCByZWplY3QsIGJ1dCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBpbnZhbGlkIG9wdGlvbnNcbiAqIGFyZSBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMubXVzdEJlTWV0YU1hc2sgLSBXaGV0aGVyIHRvIG9ubHkgbG9vayBmb3IgTWV0YU1hc2sgcHJvdmlkZXJzLlxuICogRGVmYXVsdDogZmFsc2VcbiAqIEBwYXJhbSBvcHRpb25zLnNpbGVudCAtIFdoZXRoZXIgdG8gc2lsZW5jZSBjb25zb2xlIGVycm9ycy4gRG9lcyBub3QgYWZmZWN0XG4gKiB0aHJvd24gZXJyb3JzLiBEZWZhdWx0OiBmYWxzZVxuICogQHBhcmFtIG9wdGlvbnMudGltZW91dCAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciAnZXRoZXJldW0jaW5pdGlhbGl6ZWQnIHRvXG4gKiBiZSBkaXNwYXRjaGVkLiBEZWZhdWx0OiAzMDAwXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBQcm92aWRlciBpZiBpdCBpcyBkZXRlY3RlZCB3aXRoaW5cbiAqIGdpdmVuIHRpbWVvdXQsIG90aGVyd2lzZSBudWxsLlxuICovXG5mdW5jdGlvbiBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyPFQgPSBNZXRhTWFza0V0aGVyZXVtUHJvdmlkZXI+KHtcbiAgbXVzdEJlTWV0YU1hc2sgPSBmYWxzZSxcbiAgc2lsZW50ID0gZmFsc2UsXG4gIHRpbWVvdXQgPSAzMDAwLFxufSA9IHt9KTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuXG4gIF92YWxpZGF0ZUlucHV0cygpO1xuXG4gIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKCh3aW5kb3cgYXMgV2luZG93KS5ldGhlcmV1bSkge1xuXG4gICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdldGhlcmV1bSNpbml0aWFsaXplZCcsXG4gICAgICAgIGhhbmRsZUV0aGVyZXVtLFxuICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICk7XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXRoZXJldW0oKSB7XG5cbiAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXRoZXJldW0jaW5pdGlhbGl6ZWQnLCBoYW5kbGVFdGhlcmV1bSk7XG5cbiAgICAgIGNvbnN0IHsgZXRoZXJldW0gfSA9IHdpbmRvdyBhcyBXaW5kb3c7XG5cbiAgICAgIGlmIChldGhlcmV1bSAmJiAoIW11c3RCZU1ldGFNYXNrIHx8IGV0aGVyZXVtLmlzTWV0YU1hc2spKSB7XG4gICAgICAgIHJlc29sdmUoZXRoZXJldW0gYXMgdW5rbm93biBhcyBUKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG11c3RCZU1ldGFNYXNrICYmIGV0aGVyZXVtXG4gICAgICAgICAgPyAnTm9uLU1ldGFNYXNrIHdpbmRvdy5ldGhlcmV1bSBkZXRlY3RlZC4nXG4gICAgICAgICAgOiAnVW5hYmxlIHRvIGRldGVjdCB3aW5kb3cuZXRoZXJldW0uJztcblxuICAgICAgICAhc2lsZW50ICYmIGNvbnNvbGUuZXJyb3IoJ0BtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6JywgbWVzc2FnZSk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBfdmFsaWRhdGVJbnB1dHMoKSB7XG4gICAgaWYgKHR5cGVvZiBtdXN0QmVNZXRhTWFzayAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAnbXVzdEJlTWV0YU1hc2snIHRvIGJlIGEgYm9vbGVhbi5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzaWxlbnQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBAbWV0YW1hc2svZGV0ZWN0LXByb3ZpZGVyOiBFeHBlY3RlZCBvcHRpb24gJ3NpbGVudCcgdG8gYmUgYSBib29sZWFuLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAndGltZW91dCcgdG8gYmUgYSBudW1iZXIuYCk7XG4gICAgfVxuICB9XG59XG4iXX0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK2RldGVjdC1wcm92aWRlckAyLjAuMC9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMERBQTBELElBQUk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsWUFBWTtBQUMxRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK2RldGVjdC1wcm92aWRlckAyLjAuMC9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXRoZXJldW0gaWYgaXQgaXNcbiAqIHNldCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQsIG9yIG51bGwuXG4gKiBUaGUgUHJvbWlzZSB3aWxsIG5vdCByZWplY3QsIGJ1dCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBpbnZhbGlkIG9wdGlvbnNcbiAqIGFyZSBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMubXVzdEJlTWV0YU1hc2sgLSBXaGV0aGVyIHRvIG9ubHkgbG9vayBmb3IgTWV0YU1hc2sgcHJvdmlkZXJzLlxuICogRGVmYXVsdDogZmFsc2VcbiAqIEBwYXJhbSBvcHRpb25zLnNpbGVudCAtIFdoZXRoZXIgdG8gc2lsZW5jZSBjb25zb2xlIGVycm9ycy4gRG9lcyBub3QgYWZmZWN0XG4gKiB0aHJvd24gZXJyb3JzLiBEZWZhdWx0OiBmYWxzZVxuICogQHBhcmFtIG9wdGlvbnMudGltZW91dCAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciAnZXRoZXJldW0jaW5pdGlhbGl6ZWQnIHRvXG4gKiBiZSBkaXNwYXRjaGVkLiBEZWZhdWx0OiAzMDAwXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBQcm92aWRlciBpZiBpdCBpcyBkZXRlY3RlZCB3aXRoaW5cbiAqIGdpdmVuIHRpbWVvdXQsIG90aGVyd2lzZSBudWxsLlxuICovXG5mdW5jdGlvbiBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyKHsgbXVzdEJlTWV0YU1hc2sgPSBmYWxzZSwgc2lsZW50ID0gZmFsc2UsIHRpbWVvdXQgPSAzMDAwLCB9ID0ge30pIHtcbiAgICBfdmFsaWRhdGVJbnB1dHMoKTtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2V0aGVyZXVtI2luaXRpYWxpemVkJywgaGFuZGxlRXRoZXJldW0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUV0aGVyZXVtKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVFdGhlcmV1bSgpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXRoZXJldW0jaW5pdGlhbGl6ZWQnLCBoYW5kbGVFdGhlcmV1bSk7XG4gICAgICAgICAgICBjb25zdCB7IGV0aGVyZXVtIH0gPSB3aW5kb3c7XG4gICAgICAgICAgICBpZiAoZXRoZXJldW0gJiYgKCFtdXN0QmVNZXRhTWFzayB8fCBldGhlcmV1bS5pc01ldGFNYXNrKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXRoZXJldW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IG11c3RCZU1ldGFNYXNrICYmIGV0aGVyZXVtXG4gICAgICAgICAgICAgICAgICAgID8gJ05vbi1NZXRhTWFzayB3aW5kb3cuZXRoZXJldW0gZGV0ZWN0ZWQuJ1xuICAgICAgICAgICAgICAgICAgICA6ICdVbmFibGUgdG8gZGV0ZWN0IHdpbmRvdy5ldGhlcmV1bS4nO1xuICAgICAgICAgICAgICAgICFzaWxlbnQgJiYgY29uc29sZS5lcnJvcignQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjonLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlSW5wdXRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIG11c3RCZU1ldGFNYXNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjogRXhwZWN0ZWQgb3B0aW9uICdtdXN0QmVNZXRhTWFzaycgdG8gYmUgYSBib29sZWFuLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2lsZW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjogRXhwZWN0ZWQgb3B0aW9uICdzaWxlbnQnIHRvIGJlIGEgYm9vbGVhbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAndGltZW91dCcgdG8gYmUgYSBudW1iZXIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRldGVjdEV0aGVyZXVtUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZhVzVrWlhndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRV2RDUVRzN096czdPenM3T3pzN096czdPMGRCWlVjN1FVRkRTQ3hUUVVGVExITkNRVUZ6UWl4RFFVRXJRaXhGUVVNMVJDeGpRVUZqTEVkQlFVY3NTMEZCU3l4RlFVTjBRaXhOUVVGTkxFZEJRVWNzUzBGQlN5eEZRVU5rTEU5QlFVOHNSMEZCUnl4SlFVRkpMRWRCUTJZc1IwRkJSeXhGUVVGRk8wbEJSVW9zWlVGQlpTeEZRVUZGTEVOQlFVTTdTVUZGYkVJc1NVRkJTU3hQUVVGUExFZEJRVWNzUzBGQlN5eERRVUZETzBsQlJYQkNMRTlCUVU4c1NVRkJTU3hQUVVGUExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNSVUZCUlR0UlFVTTNRaXhKUVVGTExFMUJRV2xDTEVOQlFVTXNVVUZCVVN4RlFVRkZPMWxCUlM5Q0xHTkJRV01zUlVGQlJTeERRVUZETzFOQlJXeENPMkZCUVUwN1dVRkZUQ3hOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUTNKQ0xITkNRVUZ6UWl4RlFVTjBRaXhqUVVGakxFVkJRMlFzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRU5CUTJZc1EwRkJRenRaUVVWR0xGVkJRVlVzUTBGQlF5eEhRVUZITEVWQlFVVTdaMEpCUTJRc1kwRkJZeXhGUVVGRkxFTkJRVU03V1VGRGJrSXNRMEZCUXl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xTkJRMkk3VVVGRlJDeFRRVUZUTEdOQlFXTTdXVUZGY2tJc1NVRkJTU3hQUVVGUExFVkJRVVU3WjBKQlExZ3NUMEZCVHp0aFFVTlNPMWxCUTBRc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF6dFpRVVZtTEUxQlFVMHNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eHpRa0ZCYzBJc1JVRkJSU3hqUVVGakxFTkJRVU1zUTBGQlF6dFpRVVZ1UlN4TlFVRk5MRVZCUVVVc1VVRkJVU3hGUVVGRkxFZEJRVWNzVFVGQlowSXNRMEZCUXp0WlFVVjBReXhKUVVGSkxGRkJRVkVzU1VGQlNTeERRVUZETEVOQlFVTXNZMEZCWXl4SlFVRkpMRkZCUVZFc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJUdG5Ra0ZEZUVRc1QwRkJUeXhEUVVGRExGRkJRWGRDTEVOQlFVTXNRMEZCUXp0aFFVTnVRenRwUWtGQlRUdG5Ra0ZGVEN4TlFVRk5MRTlCUVU4c1IwRkJSeXhqUVVGakxFbEJRVWtzVVVGQlVUdHZRa0ZEZUVNc1EwRkJReXhEUVVGRExIZERRVUYzUXp0dlFrRkRNVU1zUTBGQlF5eERRVUZETEcxRFFVRnRReXhEUVVGRE8yZENRVVY0UXl4RFFVRkRMRTFCUVUwc1NVRkJTU3hQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETERSQ1FVRTBRaXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzJkQ1FVTm9SU3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdZVUZEWmp0UlFVTklMRU5CUVVNN1NVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEZOQlFWTXNaVUZCWlR0UlFVTjBRaXhKUVVGSkxFOUJRVThzWTBGQll5eExRVUZMTEZOQlFWTXNSVUZCUlR0WlFVTjJReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERoRlFVRTRSU3hEUVVGRExFTkJRVU03VTBGRGFrYzdVVUZEUkN4SlFVRkpMRTlCUVU4c1RVRkJUU3hMUVVGTExGTkJRVk1zUlVGQlJUdFpRVU12UWl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExITkZRVUZ6UlN4RFFVRkRMRU5CUVVNN1UwRkRla1k3VVVGRFJDeEpRVUZKTEU5QlFVOHNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRaUVVNdlFpeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSE5GUVVGelJTeERRVUZETEVOQlFVTTdVMEZEZWtZN1NVRkRTQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRV3hHUkN4cFFrRkJVeXh6UWtGQmMwSXNRMEZCUXlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltbHVkR1Z5Wm1GalpTQk5aWFJoVFdGemEwVjBhR1Z5WlhWdFVISnZkbWxrWlhJZ2UxeHVJQ0JwYzAxbGRHRk5ZWE5yUHpvZ1ltOXZiR1ZoYmp0Y2JpQWdiMjVqWlNobGRtVnVkRTVoYldVNklITjBjbWx1WnlCOElITjViV0p2YkN3Z2JHbHpkR1Z1WlhJNklDZ3VMaTVoY21kek9pQmhibmxiWFNrZ1BUNGdkbTlwWkNrNklIUm9hWE03WEc0Z0lHOXVLR1YyWlc1MFRtRnRaVG9nYzNSeWFXNW5JSHdnYzNsdFltOXNMQ0JzYVhOMFpXNWxjam9nS0M0dUxtRnlaM002SUdGdWVWdGRLU0E5UGlCMmIybGtLVG9nZEdocGN6dGNiaUFnYjJabUtHVjJaVzUwVG1GdFpUb2djM1J5YVc1bklId2djM2x0WW05c0xDQnNhWE4wWlc1bGNqb2dLQzR1TG1GeVozTTZJR0Z1ZVZ0ZEtTQTlQaUIyYjJsa0tUb2dkR2hwY3p0Y2JpQWdZV1JrVEdsemRHVnVaWElvWlhabGJuUk9ZVzFsT2lCemRISnBibWNnZkNCemVXMWliMndzSUd4cGMzUmxibVZ5T2lBb0xpNHVZWEpuY3pvZ1lXNTVXMTBwSUQwK0lIWnZhV1FwT2lCMGFHbHpPMXh1SUNCeVpXMXZkbVZNYVhOMFpXNWxjaWhsZG1WdWRFNWhiV1U2SUhOMGNtbHVaeUI4SUhONWJXSnZiQ3dnYkdsemRHVnVaWEk2SUNndUxpNWhjbWR6T2lCaGJubGJYU2tnUFQ0Z2RtOXBaQ2s2SUhSb2FYTTdYRzRnSUhKbGJXOTJaVUZzYkV4cGMzUmxibVZ5Y3lobGRtVnVkRDg2SUhOMGNtbHVaeUI4SUhONWJXSnZiQ2s2SUhSb2FYTTdYRzU5WEc1Y2JtbHVkR1Z5Wm1GalpTQlhhVzVrYjNjZ2UxeHVJQ0JsZEdobGNtVjFiVDg2SUUxbGRHRk5ZWE5yUlhSb1pYSmxkVzFRY205MmFXUmxjanRjYm4xY2JseHVaWGh3YjNKMElEMGdaR1YwWldOMFJYUm9aWEpsZFcxUWNtOTJhV1JsY2p0Y2JseHVMeW9xWEc0Z0tpQlNaWFIxY201eklHRWdVSEp2YldselpTQjBhR0YwSUhKbGMyOXNkbVZ6SUhSdklIUm9aU0IyWVd4MVpTQnZaaUIzYVc1a2IzY3VaWFJvWlhKbGRXMGdhV1lnYVhRZ2FYTmNiaUFxSUhObGRDQjNhWFJvYVc0Z2RHaGxJR2RwZG1WdUlIUnBiV1Z2ZFhRc0lHOXlJRzUxYkd3dVhHNGdLaUJVYUdVZ1VISnZiV2x6WlNCM2FXeHNJRzV2ZENCeVpXcGxZM1FzSUdKMWRDQmhiaUJsY25KdmNpQjNhV3hzSUdKbElIUm9jbTkzYmlCcFppQnBiblpoYkdsa0lHOXdkR2x2Ym5OY2JpQXFJR0Z5WlNCd2NtOTJhV1JsWkM1Y2JpQXFYRzRnS2lCQWNHRnlZVzBnYjNCMGFXOXVjeUF0SUU5d2RHbHZibk1nWW1GbkxseHVJQ29nUUhCaGNtRnRJRzl3ZEdsdmJuTXViWFZ6ZEVKbFRXVjBZVTFoYzJzZ0xTQlhhR1YwYUdWeUlIUnZJRzl1YkhrZ2JHOXZheUJtYjNJZ1RXVjBZVTFoYzJzZ2NISnZkbWxrWlhKekxseHVJQ29nUkdWbVlYVnNkRG9nWm1Gc2MyVmNiaUFxSUVCd1lYSmhiU0J2Y0hScGIyNXpMbk5wYkdWdWRDQXRJRmRvWlhSb1pYSWdkRzhnYzJsc1pXNWpaU0JqYjI1emIyeGxJR1Z5Y205eWN5NGdSRzlsY3lCdWIzUWdZV1ptWldOMFhHNGdLaUIwYUhKdmQyNGdaWEp5YjNKekxpQkVaV1poZFd4ME9pQm1ZV3h6WlZ4dUlDb2dRSEJoY21GdElHOXdkR2x2Ym5NdWRHbHRaVzkxZENBdElFMXBiR3hwYzJWamIyNWtjeUIwYnlCM1lXbDBJR1p2Y2lBblpYUm9aWEpsZFcwamFXNXBkR2xoYkdsNlpXUW5JSFJ2WEc0Z0tpQmlaU0JrYVhOd1lYUmphR1ZrTGlCRVpXWmhkV3gwT2lBek1EQXdYRzRnS2lCQWNtVjBkWEp1Y3lCQklGQnliMjFwYzJVZ2RHaGhkQ0J5WlhOdmJIWmxjeUIzYVhSb0lIUm9aU0JRY205MmFXUmxjaUJwWmlCcGRDQnBjeUJrWlhSbFkzUmxaQ0IzYVhSb2FXNWNiaUFxSUdkcGRtVnVJSFJwYldWdmRYUXNJRzkwYUdWeWQybHpaU0J1ZFd4c0xseHVJQ292WEc1bWRXNWpkR2x2YmlCa1pYUmxZM1JGZEdobGNtVjFiVkJ5YjNacFpHVnlQRlFnUFNCTlpYUmhUV0Z6YTBWMGFHVnlaWFZ0VUhKdmRtbGtaWEkrS0h0Y2JpQWdiWFZ6ZEVKbFRXVjBZVTFoYzJzZ1BTQm1ZV3h6WlN4Y2JpQWdjMmxzWlc1MElEMGdabUZzYzJVc1hHNGdJSFJwYldWdmRYUWdQU0F6TURBd0xGeHVmU0E5SUh0OUtUb2dVSEp2YldselpUeFVJSHdnYm5Wc2JENGdlMXh1WEc0Z0lGOTJZV3hwWkdGMFpVbHVjSFYwY3lncE8xeHVYRzRnSUd4bGRDQm9ZVzVrYkdWa0lEMGdabUZzYzJVN1hHNWNiaUFnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0NoeVpYTnZiSFpsS1NBOVBpQjdYRzRnSUNBZ2FXWWdLQ2gzYVc1a2IzY2dZWE1nVjJsdVpHOTNLUzVsZEdobGNtVjFiU2tnZTF4dVhHNGdJQ0FnSUNCb1lXNWtiR1ZGZEdobGNtVjFiU2dwTzF4dVhHNGdJQ0FnZlNCbGJITmxJSHRjYmx4dUlDQWdJQ0FnZDJsdVpHOTNMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9YRzRnSUNBZ0lDQWdJQ2RsZEdobGNtVjFiU05wYm1sMGFXRnNhWHBsWkNjc1hHNGdJQ0FnSUNBZ0lHaGhibVJzWlVWMGFHVnlaWFZ0TEZ4dUlDQWdJQ0FnSUNCN0lHOXVZMlU2SUhSeWRXVWdmU3hjYmlBZ0lDQWdJQ2s3WEc1Y2JpQWdJQ0FnSUhObGRGUnBiV1Z2ZFhRb0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNCb1lXNWtiR1ZGZEdobGNtVjFiU2dwTzF4dUlDQWdJQ0FnZlN3Z2RHbHRaVzkxZENrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWm5WdVkzUnBiMjRnYUdGdVpHeGxSWFJvWlhKbGRXMG9LU0I3WEc1Y2JpQWdJQ0FnSUdsbUlDaG9ZVzVrYkdWa0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHaGhibVJzWldRZ1BTQjBjblZsTzF4dVhHNGdJQ0FnSUNCM2FXNWtiM2N1Y21WdGIzWmxSWFpsYm5STWFYTjBaVzVsY2lnblpYUm9aWEpsZFcwamFXNXBkR2xoYkdsNlpXUW5MQ0JvWVc1a2JHVkZkR2hsY21WMWJTazdYRzVjYmlBZ0lDQWdJR052Ym5OMElIc2daWFJvWlhKbGRXMGdmU0E5SUhkcGJtUnZkeUJoY3lCWGFXNWtiM2M3WEc1Y2JpQWdJQ0FnSUdsbUlDaGxkR2hsY21WMWJTQW1KaUFvSVcxMWMzUkNaVTFsZEdGTllYTnJJSHg4SUdWMGFHVnlaWFZ0TG1selRXVjBZVTFoYzJzcEtTQjdYRzRnSUNBZ0lDQWdJSEpsYzI5c2RtVW9aWFJvWlhKbGRXMGdZWE1nZFc1cmJtOTNiaUJoY3lCVUtUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNWNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2JXVnpjMkZuWlNBOUlHMTFjM1JDWlUxbGRHRk5ZWE5ySUNZbUlHVjBhR1Z5WlhWdFhHNGdJQ0FnSUNBZ0lDQWdQeUFuVG05dUxVMWxkR0ZOWVhOcklIZHBibVJ2ZHk1bGRHaGxjbVYxYlNCa1pYUmxZM1JsWkM0blhHNGdJQ0FnSUNBZ0lDQWdPaUFuVlc1aFlteGxJSFJ2SUdSbGRHVmpkQ0IzYVc1a2IzY3VaWFJvWlhKbGRXMHVKenRjYmx4dUlDQWdJQ0FnSUNBaGMybHNaVzUwSUNZbUlHTnZibk52YkdVdVpYSnliM0lvSjBCdFpYUmhiV0Z6YXk5a1pYUmxZM1F0Y0hKdmRtbGtaWEk2Snl3Z2JXVnpjMkZuWlNrN1hHNGdJQ0FnSUNBZ0lISmxjMjlzZG1Vb2JuVnNiQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOUtUdGNibHh1SUNCbWRXNWpkR2x2YmlCZmRtRnNhV1JoZEdWSmJuQjFkSE1vS1NCN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCdGRYTjBRbVZOWlhSaFRXRnpheUFoUFQwZ0oySnZiMnhsWVc0bktTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1lFQnRaWFJoYldGemF5OWtaWFJsWTNRdGNISnZkbWxrWlhJNklFVjRjR1ZqZEdWa0lHOXdkR2x2YmlBbmJYVnpkRUpsVFdWMFlVMWhjMnNuSUhSdklHSmxJR0VnWW05dmJHVmhiaTVnS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0hSNWNHVnZaaUJ6YVd4bGJuUWdJVDA5SUNkaWIyOXNaV0Z1SnlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0dCQWJXVjBZVzFoYzJzdlpHVjBaV04wTFhCeWIzWnBaR1Z5T2lCRmVIQmxZM1JsWkNCdmNIUnBiMjRnSjNOcGJHVnVkQ2NnZEc4Z1ltVWdZU0JpYjI5c1pXRnVMbUFwTzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JSFJwYldWdmRYUWdJVDA5SUNkdWRXMWlaWEluS1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWUVCdFpYUmhiV0Z6YXk5a1pYUmxZM1F0Y0hKdmRtbGtaWEk2SUVWNGNHVmpkR1ZrSUc5d2RHbHZiaUFuZEdsdFpXOTFkQ2NnZEc4Z1ltVWdZU0J1ZFcxaVpYSXVZQ2s3WEc0Z0lDQWdmVnh1SUNCOVhHNTlYRzRpWFgwPSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@metamask+detect-provider@2.0.0/node_modules/@metamask/detect-provider/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuMi4wL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztB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O0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuMi4wL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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OlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/secp256k1.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/secp256k1.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuMi4wL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuMy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuMy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/crypto.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/crypto.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuMy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVTtBQUNsQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEIsUUFBUSxpREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/pbkdf2.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBFO0FBQ3pDO0FBQ3NDO0FBQ3ZFO0FBQ0E7QUFDQSxJQUFJLGdEQUFVO0FBQ2QsaUJBQWlCLG9EQUFTLEdBQUcsMEJBQTBCO0FBQ3ZELFlBQVksc0JBQXNCO0FBQ2xDLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQU87QUFDNUIsaUJBQWlCLGtEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBSTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSx3Q0FBd0M7QUFDcEQsY0FBYztBQUNkO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQVM7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuMy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBudW1iZXIgYXMgYXNzZXJ0TnVtYmVyIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhtYWMgfSBmcm9tICcuL2htYWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xuICAgIGFzc2VydE51bWJlcihka0xlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IHRvQnl0ZXMoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWMuY3JlYXRlKGhhc2gsIHBhc3N3b3JkKTtcbiAgICBjb25zdCBQUkZTYWx0ID0gUFJGLl9jbG9uZUludG8oKS51cGRhdGUoc2FsdCk7XG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuZnVuY3Rpb24gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpIHtcbiAgICBQUkYuZGVzdHJveSgpO1xuICAgIFBSRlNhbHQuZGVzdHJveSgpO1xuICAgIGlmIChwcmZXKVxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcbiAgICB1LmZpbGwoMCk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/pbkdf2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS4zLjIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha3.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha3.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDSztBQUM0QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhDQUFLO0FBQ3hEO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsaURBQUs7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQWU7QUFDckQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUCxrREFBa0QscUVBQTBCLFdBQVc7QUFDaEY7QUFDQTtBQUNQIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuMy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha512.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha512.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDaUI7QUFDN0M7QUFDQTtBQUNBLHNEQUFzRCxxREFBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6Rix3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2Rix3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2RjtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx5QkFBeUIscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHdCQUF3QixxREFBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSxtREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVM7QUFDakMsaUJBQWlCLHFEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsbUNBQW1DLDBEQUFlO0FBQ2xELG1DQUFtQywwREFBZTtBQUNsRCwrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS4zLjIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjMuMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nconst version = \"6.15.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        }\n        else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        }\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [reason]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            }\n            catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        }\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\"uint256\"], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [code]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            }\n            catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        }\n        else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: (tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */\nclass AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n        switch (param.baseType) {\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types) {\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = (new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\"));\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types, data, loose) {\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (value) === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RTtBQUNaO0FBQ1Q7QUFDSjtBQUNJO0FBQ0o7QUFDVztBQUNiO0FBQ0k7QUFDQTtBQUNGO0FBQ0o7QUFDTTtBQUNnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFRO0FBQzlCLGVBQWUsd0RBQU87QUFDdEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsaUJBQWlCLHdEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLGlCQUFpQix3REFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9DQUFvQyxHQUFHLEtBQUs7QUFDckYsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFVO0FBQ3JDO0FBQ0EsV0FBVywwREFBUztBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFVO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCLDREQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCLDBEQUFXO0FBQ3RDO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0EsMkJBQTJCLHNEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCLHVCQUF1QiwyREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQix1QkFBdUIsb0VBQWU7QUFDdEM7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscURBQVM7QUFDbkUsMEJBQTBCLHdEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFtQjtBQUMzQiwwREFBMEQscURBQVM7QUFDbkUsMkJBQTJCLHdEQUFVO0FBQ3JDLDJCQUEyQiw4REFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFEQUFTO0FBQ25FLDBCQUEwQix3REFBVTtBQUNwQyxnQ0FBZ0MsOERBQU07QUFDdEM7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXG4gKlxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXG4gKlxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXG4gKi9cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9FdGhlcmV1bS1Db250cmFjdC1BQklcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSZWFkZXIsIFdyaXRlciB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQWRkcmVzc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FkZHJlc3MuanNcIjtcbmltcG9ydCB7IEFycmF5Q29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYXJyYXkuanNcIjtcbmltcG9ydCB7IEJvb2xlYW5Db2RlciB9IGZyb20gXCIuL2NvZGVycy9ib29sZWFuLmpzXCI7XG5pbXBvcnQgeyBCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2J5dGVzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIjtcbmltcG9ydCB7IE51bGxDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udWxsLmpzXCI7XG5pbXBvcnQgeyBOdW1iZXJDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udW1iZXIuanNcIjtcbmltcG9ydCB7IFN0cmluZ0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3N0cmluZy5qc1wiO1xuaW1wb3J0IHsgVHVwbGVDb2RlciB9IGZyb20gXCIuL2NvZGVycy90dXBsZS5qc1wiO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWxcbmNvbnN0IFBhbmljUmVhc29ucyA9IG5ldyBNYXAoKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMCwgXCJHRU5FUklDX1BBTklDXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDAxLCBcIkFTU0VSVF9GQUxTRVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMSwgXCJPVkVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMiwgXCJESVZJREVfQllfWkVST1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMSwgXCJFTlVNX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIyLCBcIkJBRF9TVE9SQUdFX0RBVEFcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzEsIFwiU1RBQ0tfVU5ERVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMyLCBcIkFSUkFZX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDQxLCBcIk9VVF9PRl9NRU1PUllcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NTEsIFwiVU5JTklUSUFMSVpFRF9GVU5DVElPTl9DQUxMXCIpO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5sZXQgZGVmYXVsdENvZGVyID0gbnVsbDtcbmxldCBkZWZhdWx0TWF4SW5mbGF0aW9uID0gMTAyNDtcbmZ1bmN0aW9uIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIGFiaUNvZGVyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBcIm1pc3NpbmcgcmV2ZXJ0IGRhdGFcIjtcbiAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gbnVsbDtcbiAgICBsZXQgcmV2ZXJ0ID0gbnVsbDtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXNzYWdlID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWRcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XG4gICAgICAgICAgICByZWFzb24gPSBcInJlcXVpcmUoZmFsc2UpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIGRhdGEgbGVuZ3RoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xuICAgICAgICAgICAgLy8gRXJyb3Ioc3RyaW5nKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBhYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBieXRlcy5zbGljZSg0KSlbMF07XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZWFzb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7SlNPTi5zdHJpbmdpZnkocmVhc29uKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgc3RyaW5nIGRhdGEpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHg0ZTQ4N2I3MVwiKSB7XG4gICAgICAgICAgICAvLyBQYW5pYyh1aW50MjU2KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gTnVtYmVyKGFiaUNvZGVyLmRlY29kZShbXCJ1aW50MjU2XCJdLCBieXRlcy5zbGljZSg0KSlbMF0pO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvZGVdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBgUGFuaWMgZHVlIHRvICR7UGFuaWNSZWFzb25zLmdldChjb2RlKSB8fCBcIlVOS05PV05cIn0oJHtjb2RlfSlgO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtyZWFzb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcGFuaWMgY29kZSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0bzogKHR4LnRvID8gZ2V0QWRkcmVzcyh0eC50bykgOiBudWxsKSxcbiAgICAgICAgZGF0YTogKHR4LmRhdGEgfHwgXCIweFwiKVxuICAgIH07XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlRXJyb3IobWVzc2FnZSwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgIGFjdGlvbiwgZGF0YSwgcmVhc29uLCB0cmFuc2FjdGlvbiwgaW52b2NhdGlvbiwgcmV2ZXJ0XG4gICAgfSk7XG59XG4vKipcbiAqICBUaGUgKipBYmlDb2RlcioqIGlzIGEgbG93LWxldmVsIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNvZGluZyBKYXZhU2NyaXB0XG4gKiAgdmFsdWVzIGludG8gYmluYXJ5IGRhdGEgYW5kIGRlY29kaW5nIGJpbmFyeSBkYXRhIGludG8gSmF2YVNjcmlwdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYmlDb2RlciB7XG4gICAgI2dldENvZGVyKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGVDb2RlcihwYXJhbS5jb21wb25lbnRzLm1hcCgoYykgPT4gdGhpcy4jZ2V0Q29kZXIoYykpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHU/aW50WzAtOV0qXG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBieXRlc1swLTldK1xuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byBBQkkgZGF0YS5cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gICAgICovXG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnRDb3VudCh2YWx1ZXMubGVuZ3RoLCB0eXBlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIHRoZSBBQkkgJSVkYXRhJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJWxvb3NlJSUgZGVjb2RpbmcgaXMgZW5hYmxlZCwgdGhlbiBzdHJpY3QgcGFkZGluZyBpc1xuICAgICAqICBub3QgZW5mb3JjZWQuIFNvbWUgb2xkZXIgdmVyc2lvbnMgb2YgU29saWRpdHkgaW5jb3JyZWN0bHlcbiAgICAgKiAgcGFkZGVkIGV2ZW50IGRhdGEgZW1pdHRlZCBmcm9tIGBgZXh0ZXJuYWxgYCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgZGVjb2RlKHR5cGVzLCBkYXRhLCBsb29zZSkge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IFJlYWRlcihkYXRhLCBsb29zZSwgZGVmYXVsdE1heEluZmxhdGlvbikpO1xuICAgIH1cbiAgICBzdGF0aWMgX3NldERlZmF1bHRNYXhJbmZsYXRpb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwiaW52YWxpZCBkZWZhdWx0TWF4SW5mbGF0aW9uIGZhY3RvclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdE1heEluZmxhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2hhcmVkIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGRlZmF1bHQgW1tBYmlDb2Rlcl1dLlxuICAgICAqXG4gICAgICogIE9uIHRoZSBmaXJzdCBjYWxsLCB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0QWJpQ29kZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdENvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLWNvbXBhdGlibGUgW1tDYWxsRXhjZXB0aW9uRXJyb3JdXSBFcnJvciBmb3IgdGhlIGdpdmVuXG4gICAgICogIHJlc3VsdCAlJWRhdGElJSBmb3IgdGhlIFtbQ2FsbEV4Y2VwdGlvbkFjdGlvbl1dICUlYWN0aW9uJSUgYWdhaW5zdFxuICAgICAqICB0aGUgVHJhbnNhY3Rpb24gJSV0eCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */\nconst WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index) => {\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index) => {\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nclass Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void (this.#names);\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(deep) {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([Padding.slice(bytes.length % WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */\nclass Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */\nclass Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, { allowLoose: !!allowLoose });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() { return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sd0RBQU87QUFDL0IsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxzSUFBc0ksb0JBQW9CO0FBQ3hLLG9CQUFvQiw2REFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFNO0FBQ3RCLDRCQUE0Qiw2REFBWTtBQUN4QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLHlEQUFRO0FBQ3ZCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudFxuLyosIGlzRXJyb3IqL1xuIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBfaWdub3JlOlxuICovXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShXb3JkU2l6ZSk7XG4vLyBQcm9wZXJ0aWVzIHVzZWQgdG8gaW1tZWRpYXRlIHBhc3MgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBvYmplY3Rcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IHJlc3VsdE5hbWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE5hbWVzKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHROYW1lcy5nZXQocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHNldE5hbWVzKHJlc3VsdCwgbmFtZXMpIHtcbiAgICByZXN1bHROYW1lcy5zZXQocmVzdWx0LCBuYW1lcyk7XG59XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbmZ1bmN0aW9uIHRvT2JqZWN0KG5hbWVzLCBpdGVtcywgZGVlcCkge1xuICAgIGlmIChuYW1lcy5pbmRleE9mKG51bGwpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBpdGVtID0gaXRlbXMuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxuICogIG9mIGl0cyB2YWx1ZXMgZWl0aGVyIHBvc2l0aW9uYWxseSBieSBpdHMgaW5kZXggb3IsIGlmIGtleXMgYXJlXG4gKiAgcHJvdmlkZWQgYnkgaXRzIG5hbWUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvYWJpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgLy8gTm8gbG9uZ2VyIHVzZWQ7IGJ1dCBjYW5ub3QgYmUgcmVtb3ZlZCBhcyBpdCB3aWxsIHJlbW92ZSB0aGVcbiAgICAvLyAjcHJpdmF0ZSBmaWVsZCBmcm9tIHRoZSAuZC50cyB3aGljaCBtYXkgYnJlYWsgYmFja3dhcmRzXG4gICAgLy8gY29tcGF0aWJpbGl0eVxuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICBzZXROYW1lcyh0aGlzLCBPYmplY3QuZnJlZXplKGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpbmRleF07XG4gICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIG5hbWVDb3VudHMuZ2V0KG5hbWUpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgLy8gRHVtbXkgb3BlcmF0aW9ucyB0byBwcmV2ZW50IFR5cGVTY3JpcHQgZnJvbSBjb21wbGFpbmluZ1xuICAgICAgICB0aGlzLiNuYW1lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy4jbmFtZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdm9pZCAodGhpcy4jbmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKHByb3AsIFwiJWluZGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJlc3VsdCByYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5I25vX3ByaXZhdGVfcHJvcGVydHlfZm9yd2FyZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIG5hbWUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0VmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0TmFtZXMocHJveHksIGdldE5hbWVzKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LiBJZiAlJWRlZXAlJSwgYW55IGNoaWxkcmVuXG4gICAgICogIHdoaWNoIGFyZSBSZXN1bHQgb2JqZWN0cyBhcmUgYWxzbyBjb252ZXJ0ZWQgdG8gYSBub3JtYWwgQXJyYXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcbiAgICAgKiAgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvQXJyYXkoZGVlcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9BcnJheShkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhbiBPYmplY3Qgd2l0aCBlYWNoIG5hbWUtdmFsdWUgcGFpci4gSWZcbiAgICAgKiAgJSVkZWVwJSUsIGFueSBjaGlsZHJlbiB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc29cbiAgICAgKiAgY29udmVydGVkIHRvIGFuIE9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxuICAgICAqICBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWQgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvT2JqZWN0KGRlZXApIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBgdmFsdWUgYXQgaW5kZXggJHtpbmRleH0gdW5uYW1lZGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChuYW1lcywgdGhpcywgZGVlcCk7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChfbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldE5hbWVzKHRoaXMpLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIFNpbmNlIGNlcnRhaW4gZXJyb3JzIGVuY291bnRlcmVkIHdoZW4gY3JlYXRpbmcgYSBbW1Jlc3VsdF1dIGRvXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXG4gKiAgZGVmZXJyZWQgdW50aWwgdGhleSBhcmUgYWN0dWFsbHkgYWNjZXNzZWQuIEhlbmNlIGEgZmF1bHR5IHN0cmluZ1xuICogIGluIGFuIEV2ZW50IHRoYXQgaXMgbmV2ZXIgdXNlZCBkb2VzIG5vdCBpbXBhY3QgdGhlIHByb2dyYW0gZmxvdy5cbiAqXG4gKiAgSG93ZXZlciwgc29tZXRpbWVzIGl0IG1heSBiZSB1c2VmdWwgdG8gYWNjZXNzLCBpZGVudGlmeSBvclxuICogIHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgQF9kb2Nsb2MgYXBpL2FiaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA8PSBXb3JkU2l6ZSwgXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IFdvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW1BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxuICAgICN3cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldEJ5dGVzQ29weSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtieXRlcywgUGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBJbnNlcnRzIGEgbnVtZXJpYyBwbGFjZS1ob2xkZXIsIHJldHVybmluZyBhIGNhbGxiYWNrIHRoYXQgY2FuXG4gICAgLy8gYmUgdXNlZCB0byBhc2p1c3QgdGhlIHZhbHVlIGxhdGVyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy4jZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChQYWRkaW5nKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIC8vIEFsbG93cyBpbmNvbXBsZXRlIHVucGFkZGVkIGRhdGEgdG8gYmUgcmVhZDsgb3RoZXJ3aXNlIGFuIGVycm9yXG4gICAgLy8gaXMgcmFpc2VkIGlmIGF0dGVtcHRpbmcgdG8gb3ZlcnJ1biB0aGUgYnVmZmVyLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXG4gICAgLy8gZXh0ZXJuYWwgKG5vdCBwdWJsaWMgdGhvZ3VoKSB3YXMgdGlnaHRseSBwYWNrZWQuXG4gICAgYWxsb3dMb29zZTtcbiAgICAjZGF0YTtcbiAgICAjb2Zmc2V0O1xuICAgICNieXRlc1JlYWQ7XG4gICAgI3BhcmVudDtcbiAgICAjbWF4SW5mbGF0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGFsbG93TG9vc2UsIG1heEluZmxhdGlvbikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xuICAgICAgICB0aGlzLiNkYXRhID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xuICAgICAgICB0aGlzLiNieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhJbmZsYXRpb24gPSAobWF4SW5mbGF0aW9uICE9IG51bGwpID8gbWF4SW5mbGF0aW9uIDogMTAyNDtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuI2RhdGEpOyB9XG4gICAgZ2V0IGRhdGFMZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2RhdGEpOyB9XG4gICAgI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCkge1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50LiNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCArPSBjb3VudDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4Y2Vzc2l2ZSBpbmZsYXRpb24gKHNlZTogIzQ1MzcpXG4gICAgICAgIGFzc2VydCh0aGlzLiNtYXhJbmZsYXRpb24gPCAxIHx8IHRoaXMuI2J5dGVzUmVhZCA8PSB0aGlzLiNtYXhJbmZsYXRpb24gKiB0aGlzLmRhdGFMZW5ndGgsIGBjb21wcmVzc2VkIEFCSSBkYXRhIGV4Y2VlZHMgaW5mbGF0aW9uIHJhdGlvIG9mICR7dGhpcy4jbWF4SW5mbGF0aW9ufSAoIHNlZTogaHR0cHM6L1xcL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9pc3N1ZXMvNDUzNyApYCwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGg6IGNvdW50LCBpbmZvOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiB0aGlzLiNieXRlc1JlYWQsXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjcGVla0J5dGVzKG9mZnNldCwgbGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyBXb3JkU2l6ZSkgKiBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLiNvZmZzZXQgKyBsZW5ndGggPD0gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy4jZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHN1Yi1yZWFkZXIgd2l0aCB0aGUgc2FtZSB1bmRlcmx5aW5nIGRhdGEsIGJ1dCBvZmZzZXRcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UsIHRoaXMuI21heEluZmxhdGlvbik7XG4gICAgICAgIHJlYWRlci4jcGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG4gICAgLy8gUmVhZCBieXRlc1xuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuI3BlZWtCeXRlcygwLCBsZW5ndGgsICEhbG9vc2UpO1xuICAgICAgICB0aGlzLiNpbmNyZW1lbnRCeXRlc1JlYWQobGVuZ3RoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nclass AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        }\n        catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0w7QUFDWDtBQUNRO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixxREFBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBSztBQUN6QjtBQUNBLG9CQUFvQiw2REFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQVUsQ0FBQyx3REFBTztBQUNqQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nclass AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    coder;\n    constructor(coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixxREFBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/anonymous.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nfunction pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */\nfunction unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */\nclass ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    coder;\n    length;\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { coder, length });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize, length: reader.dataLength });\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n}\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RztBQUMxRTtBQUNrQztBQUN0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFNLHNGQUFzRiw0QkFBNEIsT0FBTyxpQkFBaUI7QUFDNUosWUFBWSx1REFBTSxpR0FBaUcsNEJBQTRCLE9BQU8saUJBQWlCO0FBQ3ZLO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCLDJCQUEyQixzREFBTTtBQUNqQyw0QkFBNEIsc0RBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsc0RBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIscURBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQW1CO0FBQzNCO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU0sU0FBUyx3REFBUSx1RUFBdUUsc0NBQXNDLHdEQUFRLDZCQUE2QjtBQUNyTDtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsNEJBQTRCLHlEQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgaXNFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0QXJndW1lbnRDb3VudCB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBSZXN1bHQsIFdvcmRTaXplLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQW5vbnltb3VzQ29kZXIgfSBmcm9tIFwiLi9hbm9ueW1vdXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIGFycmF5VmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZXMgJiYgdHlwZW9mICh2YWx1ZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB1bmlxdWUgPSB7fTtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGFzc2VydChuYW1lLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICBhc3NlcnQoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29kZXJzLmxlbmd0aCA9PT0gYXJyYXlWYWx1ZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBsZXQgZHluYW1pY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBsZXQgdXBkYXRlRnVuY3MgPSBbXTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPZmZzZXQgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmMgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG4gICAgbGV0IGxlbmd0aCA9IHdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtcbiAgICBsZW5ndGggKz0gd3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXN0aWdhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICBrZXlzLnB1c2goY29kZXIubG9jYWxOYW1lIHx8IG51bGwpO1xuICAgIH0pO1xuICAgIHJldHVybiBSZXN1bHQuZnJvbUl0ZW1zKHZhbHVlcywga2V5cyk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBsZW5ndGg7XG4gICAgY29uc3RydWN0b3IoY29kZXIsIGxlbmd0aCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoY29kZXIudHlwZSArIFwiW1wiICsgKGxlbmd0aCA+PSAwID8gbGVuZ3RoIDogXCJcIikgKyBcIl1cIik7XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgc3VwZXIoXCJhcnJheVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29kZXIsIGxlbmd0aCB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImFycmF5XCIpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnRDb3VudCh2YWx1ZS5sZW5ndGgsIGNvdW50LCBcImNvZGVyIGFycmF5XCIgKyAodGhpcy5sb2NhbE5hbWUgPyAoXCIgXCIgKyB0aGlzLmxvY2FsTmFtZSkgOiBcIlwiKSk7XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2godGhpcy5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHN0cmF5IHJhbmRvbSBkYXRhIGlzIG5vdCBiZWluZyByZWFkIGFzIGEgbGVuZ3RoLiBFYWNoXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcbiAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuICAgICAgICAgICAgLy8gdGlnaHRlciBib3VuZCwgYnV0IHdlIGFyZSBlcnJvcmluZyBvbiB0aGUgc2lkZSBvZiBzYWZldHkuXG4gICAgICAgICAgICBhc3NlcnQoY291bnQgKiBXb3JkU2l6ZSA8PSByZWFkZXIuZGF0YUxlbmd0aCwgXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogcmVhZGVyLmJ5dGVzLCBvZmZzZXQ6IGNvdW50ICogV29yZFNpemUsIGxlbmd0aDogcmVhZGVyLmRhdGFMZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKG5ldyBBbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIGNvZGVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/array.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */\nclass BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n}\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNRO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixxREFBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/boolean.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */\nclass DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2pCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxxREFBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2REFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/bytes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */\nclass FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    size;\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size }, { size: \"number\" });\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUMzQztBQUNRO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QixxREFBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsTUFBTSxJQUFJLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFZLENBQUMsNENBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzQ29weShUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/null.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */\nclass NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n}\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoW10pO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoRW1wdHkpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZWFkQnl0ZXMoMCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/null.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */\nclass NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    size;\n    signed;\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        }\n        else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkY7QUFDdkQ7QUFDa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLHFEQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLGNBQWMsSUFBSSxtQ0FBbUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBUyxDQUFDLDRDQUFLO0FBQ25DO0FBQ0EsMkJBQTJCLHFEQUFJLGlCQUFpQix3REFBUTtBQUN4RDtBQUNBLHlCQUF5QixxREFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU0sWUFBWSx3REFBUTtBQUM5QztBQUNBLHlDQUF5QyxxREFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFJO0FBQ3hCO0FBQ0Esb0JBQW9CLHlEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGZyb21Ud29zLCBnZXRCaWdJbnQsIG1hc2ssIHRvVHdvcyB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBXb3JkU2l6ZSB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgc2lnbmVkO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2RpbmdcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIFdvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1hc2sobWF4VWludFZhbHVlLCAodGhpcy5zaXplICogOCkgLSAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB0b1R3b3ModmFsdWUsIDggKiBXb3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBCTl8wIHx8IHZhbHVlID4gbWFzayhtYXhVaW50VmFsdWUsIHRoaXMuc2l6ZSAqIDgpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFzayhyZWFkZXIucmVhZFZhbHVlKCksIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/number.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */\nclass StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUM1QjtBQUNXO0FBQy9DO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQix3REFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkRBQVcsQ0FBQyw0Q0FBSztBQUNyRDtBQUNBO0FBQ0EsZUFBZSw0REFBWTtBQUMzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/string.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nclass TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    coders;\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { coders: Object.freeze(coders.slice()) });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n}\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUN6QjtBQUNRO0FBQ0Y7QUFDMUM7QUFDQTtBQUNBO0FBQ08seUJBQXlCLHFEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxzRUFBZ0IsU0FBUyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSztBQUMzQixlQUFlLCtDQUFJO0FBQ25CO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXJzO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29kZXJzOiBPYmplY3QuZnJlZXplKGNvZGVycy5zbGljZSgpKSB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwidHVwbGVcIik7XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgdGhpcy5jb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/tuple.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/fragments.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/fragments.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\", \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() { return this.#offset; }\n    get length() { return this.#tokens.length - this.#offset; }\n    constructor(tokens) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() { return new TokenString(this.#tokens); }\n    reset() { this.#offset = 0; }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({}, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while (this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return (top.type === type) ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while (offset < text.length) {\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            }\n            else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                (tokens[token.match]).match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n            }\n            else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            }\n            else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            }\n            else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    (tokens[tokens.length - 1]).value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (tokens[tokens.length - 1]).text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    }\n    else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nclass ParamType {\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    name;\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    type;\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    baseType;\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    indexed;\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    components;\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayLength;\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayChildren;\n    /**\n     *  @private\n     */\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n        }\n        else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray() {\n        return (this.baseType === \"array\");\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple() {\n        return (this.baseType === \"tuple\");\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable() {\n        return (this.indexed != null);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            }\n            else {\n                if (value == null || typeof (value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param) => {\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function () { setValue(await result); })());\n        }\n        else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value, process) {\n        const promises = [];\n        const result = [value];\n        this.#walkAsync(promises, value, process, (value) => {\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\n            }\n            else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value) {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nclass Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    type;\n    /**\n     *  The inputs for the fragment.\n     */\n    inputs;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { type, inputs });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            }\n            catch (e) { }\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n        }\n        else if (typeof (obj) === \"object\") {\n            // JSON ABI\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nclass NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    name;\n    /**\n     *  @private\n     */\n    constructor(guard, type, name, inputs) {\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { name });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nclass ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n    /**\n     *  The Custom Error selector.\n     */\n    get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */\nclass EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    anonymous;\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs, anonymous) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { anonymous });\n    }\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nclass ConstructorFragment extends Fragment {\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    payable;\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs, payable, gas) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { payable, gas });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [`constructor${joinParams(format, this.inputs)}`];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\"constructor\"]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nclass FallbackFragment extends Fragment {\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    constructor(guard, inputs, payable) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { payable });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format) {\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\"payable\"]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            else {\n                inputs = [ParamType.from(\"bytes\")];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [ParamType.from(\"bytes\")];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nclass FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    constant;\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    outputs;\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    stateMutability;\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });\n    }\n    /**\n     *  The Function selector.\n     */\n    get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof (obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            }\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */\nclass StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrSDtBQUM1RTtBQUN0QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sTUFBTSxVQUFVLEVBQUUseUJBQXlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBdUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUF1RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQkFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGZyYWdtZW50IGlzIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBBQkksIHdoaWNoIG1heSByZXByZXNlbnQgYW55IG9mOlxuICpcbiAqICAtIFtGdW5jdGlvbnNdKEZ1bmN0aW9uRnJhZ21lbnQpXG4gKiAgLSBbRXZlbnRzXShFdmVudEZyYWdtZW50KVxuICogIC0gW0NvbnN0cnVjdG9yc10oQ29uc3RydWN0b3JGcmFnbWVudClcbiAqICAtIEN1c3RvbSBbRXJyb3JzXShFcnJvckZyYWdtZW50KVxuICogIC0gW0ZhbGxiYWNrIG9yIFJlY2VpdmVdKEZhbGxiYWNrRnJhZ21lbnQpIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6RnJhZ21lbnRzICBbYWJvdXQtZnJhZ21lbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgYXNzZXJ0LCBhc3NlcnRQcml2YXRlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuO1xuLy8gWyBcImFcIiwgXCJiXCIgXSA9PiB7IFwiYVwiOiAxLCBcImJcIjogMSB9XG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgaXRlbXMuZm9yRWFjaCgoaykgPT4gcmVzdWx0LmFkZChrKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbn1cbmNvbnN0IF9rd1Zpc2liRGVwbG95ID0gXCJleHRlcm5hbCBwdWJsaWMgcGF5YWJsZSBvdmVycmlkZVwiO1xuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xuY29uc3QgX2t3VmlzaWIgPSBcImNvbnN0YW50IGV4dGVybmFsIGludGVybmFsIHBheWFibGUgcHJpdmF0ZSBwdWJsaWMgcHVyZSB2aWV3IG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcbmNvbnN0IEt3VHlwZXMgPSBzZXRpZnkoX2t3VHlwZXMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd090aGVyID0gXCJ0dXBsZSByZXR1cm5zXCI7XG4vLyBBbGwgS2V5d29yZHNcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xuY29uc3QgS2V5d29yZHMgPSBzZXRpZnkoX2tleXdvcmRzLnNwbGl0KFwiIFwiKSk7XG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xuICAgIFwiKFwiOiBcIk9QRU5fUEFSRU5cIiwgXCIpXCI6IFwiQ0xPU0VfUEFSRU5cIixcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcbn07XG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xuY29uc3QgcmVnZXhOdW1iZXJQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbMC05XSspXCIpO1xuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XG5jb25zdCByZWdleElkID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKSRcIik7XG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICAgICNvZmZzZXQ7XG4gICAgI3Rva2VucztcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3Rva2Vucy5sZW5ndGggLSB0aGlzLiNvZmZzZXQ7IH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy4jdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cbiAgICByZXNldCgpIHsgdGhpcy4jb2Zmc2V0ID0gMDsgfVxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rTmV4dDogKHQubGlua05leHQgLSBmcm9tKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9OyBnb3QgJHt0b3AudHlwZX0gJHtKU09OLnN0cmluZ2lmeSh0b3AudGV4dCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyBhIFwiKFwiIFRPS0VOUyBcIilcIlxuICAgIHBvcFBhcmVuKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIHRvcC5tYXRjaCArIDEpO1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSBpdGVtcyB3aXRoaW4gXCIoXCIgSVRFTTEgXCIsXCIgSVRFTTIgXCIsXCIgLi4uIFwiKVwiXG4gICAgcG9wUGFyYW1zKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy4jb2Zmc2V0IDwgdG9wLm1hdGNoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMucGVlaygpLmxpbmtOZXh0O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgbGluaykpO1xuICAgICAgICAgICAgdGhpcy4jb2Zmc2V0ID0gbGluaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB0b3AgVG9rZW4sIHRocm93aW5nIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ID49IHRoaXMuI3Rva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3Rva2Vuc1t0aGlzLiNvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYGFsbG93ZWRgXG4gICAgcGVla0tleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgcmV0dXJuICh0b3AgIT0gbnVsbCAmJiBhbGxvd2VkLmhhcyh0b3ApKSA/IHRvcCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYFxuICAgIHBlZWtUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgcmV0dXJuICh0b3AudHlwZSA9PT0gdHlwZSkgPyB0b3AudGV4dCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdG9rZW47IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI29mZnNldDsgaSA8IHRoaXMuI3Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLiN0b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbnMucHVzaChgJHt0b2tlbi50eXBlfToke3Rva2VuLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGA8VG9rZW5TdHJpbmcgJHt0b2tlbnMuam9pbihcIiBcIil9PmA7XG4gICAgfVxufVxuZnVuY3Rpb24gbGV4KHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkodGV4dFtvZmZzZXRdKSA6IFwiJEVPSVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdG9rZW4gJHt0b2tlbn0gYXQgJHtvZmZzZXR9OiAke21lc3NhZ2V9YCk7XG4gICAgfTtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY29tbWFzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIFN0cmlwIG9mZiBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhXaGl0ZXNwYWNlUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHsgZGVwdGg6IGJyYWNrZXRzLmxlbmd0aCwgbGlua0JhY2s6IC0xLCBsaW5rTmV4dDogLTEsIG1hdGNoOiAtMSwgdHlwZTogXCJcIiwgdGV4dDogXCJcIiwgb2Zmc2V0LCB2YWx1ZTogLTEgfTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsZXQgdHlwZSA9IChTaW1wbGVUb2tlbnNbY3VyWzBdXSB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IGN1clswXTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIkNMT1NFX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJubyBtYXRjaGluZyBvcGVuIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoID0gYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5tYXRjaF0pLm1hdGNoID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdG9rZW4uZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ09NTUFcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT1BFTl9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJCUkFDS0VUXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNMT1NFX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQ0xPU0VfQlJBQ0tFVFxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlID09PSBcIk5VTUJFUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHZhbHVlICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudmFsdWUgPSBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwiQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3BlbmluZyBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudGV4dCArPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleElkUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoS2V5d29yZHMuaGFzKHRva2VuLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiS0VZV09SRFwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQubWF0Y2gocmVnZXhUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIlRZUEVcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleE51bWJlclByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiTlVNQkVSXCI7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW4gJHtKU09OLnN0cmluZ2lmeShjdXJbMF0pfSBhdCBwb3NpdGlvbiAke29mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0b2tlbnMubWFwKCh0KSA9PiBPYmplY3QuZnJlZXplKHQpKSk7XG59XG4vLyBDaGVjayBvbmx5IG9uZSBvZiBgYWxsb3dlZGAgaXMgaW4gYHNldGBcbmZ1bmN0aW9uIGFsbG93U2luZ2xlKHNldCwgYWxsb3dlZCkge1xuICAgIGxldCBpbmNsdWRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93ZWQua2V5cygpKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0aW5nIHR5cGVzOiAke2luY2x1ZGVkLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG4vLyBGdW5jdGlvbnMgdG8gcHJvY2VzcyBhIFNvbGlkaXR5IFNpZ25hdHVyZSBUb2tlblN0cmluZyBmcm9tIGxlZnQtdG8tcmlnaHQgZm9yLi4uXG4vLyAuLi50aGUgbmFtZSB3aXRoIGFuIG9wdGlvbmFsIHR5cGUsIHJldHVybmluZyB0aGUgbmFtZVxuZnVuY3Rpb24gY29uc3VtZU5hbWUodHlwZSwgdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrS2V5d29yZChLd1R5cGVzKSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgIGlmIChrZXl3b3JkICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX0sIGdvdCAke2tleXdvcmR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5wb3BUeXBlKFwiSURcIik7XG59XG4vLyAuLi5hbGwga2V5d29yZHMgbWF0Y2hpbmcgYWxsb3dlZCwgcmV0dXJuaW5nIHRoZSBrZXl3b3Jkc1xuZnVuY3Rpb24gY29uc3VtZUtleXdvcmRzKHRva2VucywgYWxsb3dlZCkge1xuICAgIGNvbnN0IGtleXdvcmRzID0gbmV3IFNldCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PSBudWxsIHx8IChhbGxvd2VkICYmICFhbGxvd2VkLmhhcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUga2V5d29yZHM6ICR7SlNPTi5zdHJpbmdpZnkoa2V5d29yZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZHMuYWRkKGtleXdvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShrZXl3b3Jkcyk7XG59XG4vLyAuLi5hbGwgdmlzaWJpbGl0eSBrZXl3b3JkcywgcmV0dXJuaW5nIHRoZSBjb2FsZXNjZWQgbXV0YWJpbGl0eVxuZnVuY3Rpb24gY29uc3VtZU11dGFiaWxpdHkodG9rZW5zKSB7XG4gICAgbGV0IG1vZGlmaWVycyA9IGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIEt3VmlzaWIpO1xuICAgIC8vIERldGVjdCBjb25mbGljdGluZyBtb2RpZmllcnNcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcImNvbnN0YW50IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwicHVyZSB2aWV3IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIC8vIFByb2Nlc3MgbXV0YWJpbGl0eSBzdGF0ZXNcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInZpZXdcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInB1cmVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicHVyZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcIm5vbnBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGxlZ2FjeSBgY29uc3RhbnRgIGxhc3RcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcImNvbnN0YW50XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xufVxuLy8gLi4uYSBwYXJhbWV0ZXIgbGlzdCwgcmV0dXJuaW5nIHRoZSBQYXJhbVR5cGUgbGlzdFxuZnVuY3Rpb24gY29uc3VtZVBhcmFtcyh0b2tlbnMsIGFsbG93SW5kZXhlZCkge1xuICAgIHJldHVybiB0b2tlbnMucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0LCBhbGxvd0luZGV4ZWQpKTtcbn1cbi8vIC4uLmEgZ2FzIGxpbWl0LCByZXR1cm5pbmcgYSBCaWdOdW1iZXIgb3IgbnVsbCBpZiBub25lXG5mdW5jdGlvbiBjb25zdW1lR2FzKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJBVFwiKSkge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJOVU1CRVJcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodG9rZW5zLnBvcCgpLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2FzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVFb2kodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VucyBhdCBvZmZzZXQgJHt0b2tlbnMub2Zmc2V0fTogJHt0b2tlbnMudG9TdHJpbmcoKX1gKTtcbiAgICB9XG59XG5jb25zdCByZWdleEFycmF5VHlwZSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5mdW5jdGlvbiB2ZXJpZnlCYXNpY1R5cGUodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleFR5cGUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwidWludFwiKSB7XG4gICAgICAgIHJldHVybiBcInVpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50MjU2XCI7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAvLyBieXRlc1hYXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIC8vIGludFhYIG9yIHVpbnRYWFxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBNYWtlIHRoZSBGcmFnbWVudCBjb25zdHJ1Y3RvcnMgZWZmZWN0aXZlbHkgcHJpdmF0ZVxuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX2ludGVybmFsXCIpO1xuY29uc3QgUGFyYW1UeXBlSW50ZXJuYWwgPSBcIl9QYXJhbVR5cGVJbnRlcm5hbFwiO1xuY29uc3QgRXJyb3JGcmFnbWVudEludGVybmFsID0gXCJfRXJyb3JJbnRlcm5hbFwiO1xuY29uc3QgRXZlbnRGcmFnbWVudEludGVybmFsID0gXCJfRXZlbnRJbnRlcm5hbFwiO1xuY29uc3QgQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsID0gXCJfQ29uc3RydWN0b3JJbnRlcm5hbFwiO1xuY29uc3QgRmFsbGJhY2tGcmFnbWVudEludGVybmFsID0gXCJfRmFsbGJhY2tJbnRlcm5hbFwiO1xuY29uc3QgRnVuY3Rpb25GcmFnbWVudEludGVybmFsID0gXCJfRnVuY3Rpb25JbnRlcm5hbFwiO1xuY29uc3QgU3RydWN0RnJhZ21lbnRJbnRlcm5hbCA9IFwiX1N0cnVjdEludGVybmFsXCI7XG4vKipcbiAqICBFYWNoIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBbW0ZyYWdtZW50XV0gaXMgYW4gQXJyYXkgb2YgKipQYXJhbVR5cGUqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgKG9yIGBgXCJcImBgIGlmIHVuYm91bmQpXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlKGFkZHJlc3MpXCJgYCxcbiAgICAgKiAgYGBcInVpbnQyNTZbM11bXVwiYGApXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZVwiYGAsIGBgXCJhcnJheVwiYGApXG4gICAgICovXG4gICAgYmFzZVR5cGU7XG4gICAgLyoqXG4gICAgICogIFRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaXMgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWluZGV4YWJsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGluZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wb25lbnRzIGZvciB0aGUgdHVwbGUuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi10dXBsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGNvbXBvbmVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcnJheSBsZW5ndGgsIG9yIGBgLTFgYCBmb3IgZHluYW1pYy1sZW5ndGhlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5TGVuZ3RoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiBlYWNoIGNoaWxkIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlDaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJQYXJhbVR5cGVcIik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogUGFyYW1UeXBlSW50ZXJuYWwgfSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJyYXlMZW5ndGggIT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiAgYGBzaWdoYXNoXCIgPT4gXCIodWludDI1NixhZGRyZXNzKVwiYGBcbiAgICAgKlxuICAgICAqICBgYFwibWluaW1hbFwiID0+IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJmdWxsXCIgPT4gXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJgYFxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjKSA9PiBKU09OLnBhcnNlKGMuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiICsgdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gY29tcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJmdWxsXCIgJiYgdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gQXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbYXJyYXlDaGlsZHJlbl1dXG4gICAgICogIGFuZCBbW2FycmF5TGVuZ3RoXV0gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhIFR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2NvbXBvbmVudHNdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1R1cGxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gSW5kZXhhYmxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2luZGV4ZWRdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0luZGV4YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4ZWQgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgY2FsbGluZyAlJXByb2Nlc3MlJVxuICAgICAqICBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICovXG4gICAgd2Fsayh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IChfdGhpcy5hcnJheUNoaWxkcmVuLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IChfdGhpcy5jb21wb25lbnRzW2ldLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsIHNldFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5hcnJheUNoaWxkcmVuO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFR5cGUuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mICh2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcG9uZW50cy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBvYmplY3QgdmFsdWUgd2l0aCB1bm5hbWVkIGNvbXBvbmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW0ubmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgY29tcG9uZW50ICR7cGFyYW0ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgc2V0VmFsdWUoYXdhaXQgcmVzdWx0KTsgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgYXN5bmNocm9ub3VzbHkgY2FsbGluZ1xuICAgICAqICAlJXByb2Nlc3MlJSBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgdXNlZCB0byByZXNvbHZlIEVOUyBuYW1lcyBieSB3YWxraW5nIGFuZCByZXNvbHZpbmcgZWFjaFxuICAgICAqICBgYFwiYWRkcmVzc1wiYGAgdHlwZS5cbiAgICAgKi9cbiAgICBhc3luYyB3YWxrQXN5bmModmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3ZhbHVlXTtcbiAgICAgICAgdGhpcy4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlBhcmFtVHlwZSoqIGZvciAlJW9iaiUlLlxuICAgICAqXG4gICAgICogIElmICUlYWxsb3dJbmRleGVkJSUgdGhlbiB0aGUgYGBpbmRleGVkYGAga2V5d29yZCBpcyBwZXJtaXR0ZWQsXG4gICAgICogIG90aGVyd2lzZSB0aGUgYGBpbmRleGVkYGAga2V5d29yZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaiwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbShsZXgob2JqKSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGFyYW0gdHlwZVwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiXCIsIGJhc2VUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGxldCBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInR1cGxlXCJdKSkuaGFzKFwidHVwbGVcIikgfHwgb2JqLnBlZWtUeXBlKFwiT1BFTl9QQVJFTlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcInR1cGxlXCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBvYmoucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0KSk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGB0dXBsZSgke2NvbXBzLm1hcCgoYykgPT4gYy5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxcbiAgICAgICAgICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai5wb3BUeXBlKFwiVFlQRVwiKSk7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEFycmF5XG4gICAgICAgICAgICBsZXQgYXJyYXlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyYXlMZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKG9iai5sZW5ndGggJiYgb2JqLnBlZWtUeXBlKFwiQlJBQ0tFVFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXQgPSBvYmoucG9wKCk7IC8vYXJyYXlzW2ldO1xuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW4gPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgXCJcIiwgdHlwZSwgYmFzZVR5cGUsIG51bGwsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggPSBicmFja2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gYnJhY2tldC50ZXh0O1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleGVkID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzID0gY29uc3VtZUtleXdvcmRzKG9iaiwgS3dNb2RpZmllcnMpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhcImluZGV4ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IChvYmoucGVla1R5cGUoXCJJRFwiKSA/IG9iai5wb3AoKS50ZXh0IDogXCJcIik7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRvdmVyIHRva2Vuc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IG9iai5uYW1lO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghbmFtZSB8fCAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpKSwgXCJpbnZhbGlkIG5hbWVcIiwgXCJvYmoubmFtZVwiLCBuYW1lKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSBvYmouaW5kZXhlZDtcbiAgICAgICAgaWYgKGluZGV4ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWxsb3dJbmRleGVkLCBcInBhcmFtZXRlciBjYW5ub3QgYmUgaW5kZXhlZFwiLCBcIm9iai5pbmRleGVkXCIsIG9iai5pbmRleGVkKTtcbiAgICAgICAgICAgIGluZGV4ZWQgPSAhIWluZGV4ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSBvYmoudHlwZTtcbiAgICAgICAgbGV0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXlUeXBlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoYXJyYXlNYXRjaFsyXSB8fCBcIi0xXCIpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXlDaGlsZHJlbiA9IFBhcmFtVHlwZS5mcm9tKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcnJheU1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9iai5jb21wb25lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcImFycmF5XCIsIGluZGV4ZWQsIG51bGwsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHR5cGUuc3RhcnRzV2l0aChcInR1cGxlKFwiIC8qIGZpeDogKSAqLykgfHwgdHlwZS5zdGFydHNXaXRoKFwiKFwiIC8qIGZpeDogKSAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG9iai5jb21wb25lbnRzICE9IG51bGwpID8gb2JqLmNvbXBvbmVudHMubWFwKChjKSA9PiBQYXJhbVR5cGUuZnJvbShjKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdHVwbGUgPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcInR1cGxlXCIsIGluZGV4ZWQsIGNvbXBzLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB1c2UgbGV4ZXIgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHVwbGU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoudHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCB0eXBlLCBpbmRleGVkLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSAqKlBhcmFtVHlwZSoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gUGFyYW1UeXBlSW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50IGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5wdXRzIGZvciB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgaW5wdXRzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkZyYWdtZW50XCIpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHR5cGUsIGlucHV0cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGcmFnbWVudCoqIGZvciAlJW9iaiUlLCB3aWNoIGNhbiBiZSBhbnkgc3VwcG9ydGVkXG4gICAgICogIEFCSSBmcmdhbWVudCB0eXBlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBKU09OLi4uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZyYWdtZW50LmZyb20oSlNPTi5wYXJzZShvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSwgdXNlIHRoZSBodW1hbi1yZWFkYWJsZSBsZXhlclxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgLy8gSHVtYW4tcmVhZGFibGUgQUJJIChhbHJlYWR5IGxleGVkKVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wZWVrS2V5d29yZChLd1R5cGVzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIEpTT04gQUJJXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHtvYmoudHlwZX1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkZyYWdtZW50LmZyb21cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgZnJnYW1lbnQgb2JqZWN0XCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tDb25zdHJ1Y3RvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXJyb3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0V2ZW50RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0Z1bmN0aW9uRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW1N0cnVjdEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzU3RydWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudFxuICogIHdoaWNoIGhhcyBhIG5hbWUgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSwgXCJpbnZhbGlkIGlkZW50aWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pblBhcmFtcyhmb3JtYXQsIHBhcmFtcykge1xuICAgIHJldHVybiBcIihcIiArIHBhcmFtcy5tYXAoKHApID0+IHAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSAvL0N1c3RvbSBFcnJvci8vLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXJyb3JcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFcnJvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQ3VzdG9tIEVycm9yIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkVycm9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJlcnJvclwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFcnJvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEVycm9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGFuIEV2ZW50LlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoaXMgZXZlbnQgaXMgYW5vbnltb3VzLlxuICAgICAqL1xuICAgIGFub255bW91cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXZlbnRcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFdmVudEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbm9ueW1vdXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRXZlbnQgdG9waWMgaGFzaC5cbiAgICAgKi9cbiAgICBnZXQgdG9waWNIYXNoKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiICYmIHRoaXMuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImFub255bW91c1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0b3BpYyBoYXNoIGZvciBhbiBldmVudCB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb3BpY0hhc2gobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXZlbnRGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXZlbnQgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXZlbnRcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFub255bW91cyA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImFub255bW91c1wiXSkpLmhhcyhcImFub255bW91c1wiKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwLCB0cnVlKSkgOiBbXSwgISFvYmouYW5vbnltb3VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFdmVudEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvciBjYW4gcmVjZWl2ZSBhbiBlbmRvd21lbnQuXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCBmb3IgZGVwbG95bWVudCBvciBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cywgcGF5YWJsZSwgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUsIGdhcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3RvciBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgYXNzZXJ0KGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIsIFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiIH0pO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcInVuZGVmaW5lZFwiKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW2Bjb25zdHJ1Y3RvciR7am9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKX1gXTtcbiAgICAgICAgaWYgKHRoaXMucGF5YWJsZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGNvbnN0dWN0b3IgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBLd1Zpc2liRGVwbG95KS5oYXMoXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBpbnB1dHMsIHBheWFibGUsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqQ29uc3RydWN0b3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZhbGxiYWNrRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZmFsbGJhY2tcIiwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZhbGxiYWNrIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBjb25zdCB0eXBlID0gKCh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApID8gXCJyZWNlaXZlXCIgOiBcImZhbGxiYWNrXCIpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVNdXRhYmlsaXR5ID0gKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0eXBlfSgpJHt0aGlzLnBheWFibGUgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRmFsbGJhY2tGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRmFsbGJhY2tGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JPYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcElzVmFsaWQgPSBvYmoucGVla0tleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodG9wSXNWYWxpZCwgXCJ0eXBlIG11c3QgYmUgZmFsbGJhY2sgb3IgcmVjZWl2ZVwiLCBcIm9ialwiLCBlcnJvck9iaik7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMCwgYHJlY2VpdmUgY2Fubm90IGhhdmUgYXJndW1lbnRzYCwgXCJvYmouaW5wdXRzXCIsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInBheWFibGVcIl0pKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soKSBbcGF5YWJsZV1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKGJ5dGVzKSBbcGF5YWJsZV0gcmV0dXJucyAoYnl0ZXMpXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAxICYmIGlucHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBpbnB1dHNcIiwgXCJvYmouaW5wdXRzXCIsIGlucHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXRzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIG91dHB1dHNcIiwgXCJvYmoub3V0cHV0c1wiLCBvdXRwdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gKG9iai5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgcGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBkZXNjcmlwdGlvblwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRmFsbGJhY2tGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGlzIGNvbnN0YW50IChlLmcuIGBgcHVyZWBgIG9yIGBgdmlld2BgIGZ1bmN0aW9ucykuXG4gICAgICovXG4gICAgY29uc3RhbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByZXR1cm5lZCB0eXBlcyBmb3IgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgb3V0cHV0cztcbiAgICAvKipcbiAgICAgKiAgVGhlIHN0YXRlIG11dGFiaWxpdHkgKGUuZy4gYGBwYXlhYmxlYGAsIGBgbm9ucGF5YWJsZWBgLCBgYHZpZXdgYFxuICAgICAqICBvciBgYHB1cmVgYClcbiAgICAgKi9cbiAgICBzdGF0ZU11dGFiaWxpdHk7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IHRvIHNlbmQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBzdGF0ZU11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZ1bmN0aW9uXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRnVuY3Rpb25GcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBvdXRwdXRzID0gT2JqZWN0LmZyZWV6ZShvdXRwdXRzLnNsaWNlKCkpO1xuICAgICAgICBjb25zdCBjb25zdGFudCA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuICAgICAgICBjb25zdCBwYXlhYmxlID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG8pID0+IEpTT04ucGFyc2Uoby5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc3RhdGVNdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicmV0dXJuc1wiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5vdXRwdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNlbGVjdG9yIGZvciBhIGZ1bmN0aW9uIHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIFwidmlld1wiLCBwYXJhbXMsIFtdLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnNlbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZ1bmN0aW9uRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZ1bmN0aW9uIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImZ1bmN0aW9uXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIG11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGVNdXRhYmlsaXR5ID0gb2JqLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gVXNlIGxlZ2FjeSBTb2xpZGl0eSBBQkkgbG9naWMgaWYgc3RhdGVNdXRhYmlsaXR5IGlzIG1pc3NpbmdcbiAgICAgICAgaWYgKHN0YXRlTXV0YWJpbGl0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5jb25zdGFudCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogdmVyaWZ5U3RhdGUgZm9yIHN0YXRlTXV0YWJpbGl0eSAoZS5nLiB0aHJvdyBpZlxuICAgICAgICAvLyAgICAgICAgcGF5YWJsZTogZmFsc2UgYnV0IHN0YXRlTXV0YWJpbGl0eSBpcyBcIm5vbnBheWFibGVcIilcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCBvYmoub3V0cHV0cyA/IG9iai5vdXRwdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGdW5jdGlvbkZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcInN0cnVjdFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3RydWN0IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipTdHJ1Y3RGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgc3RydWN0IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/fragments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nclass LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    fragment;\n    /**\n     *  The name of the Event.\n     */\n    name;\n    /**\n     *  The full Event signature.\n     */\n    signature;\n    /**\n     *  The topic hash for the Event.\n     */\n    topic;\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    args;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, topic, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nclass TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    fragment;\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    name;\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    args;\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    signature;\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    selector;\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    value;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args, value) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nclass ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    fragment;\n    /**\n     *  The name of the Error.\n     */\n    name;\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    args;\n    /**\n     *  The full Error signature.\n     */\n    signature;\n    /**\n     *  The selector for the Error.\n     */\n    selector;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nclass Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    hash;\n    /**\n     *  @_ignore:\n     */\n    _isIndexed;\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */\n    constructor(hash) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { hash, _isIndexed: true });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\"string\"],\n        reason: (message) => {\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\"uint256\"],\n        reason: (code) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nclass Interface {\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    fragments;\n    /**\n     *  The Contract constructor.\n     */\n    deploy;\n    /**\n     *  The Fallback method, if any.\n     */\n    fallback;\n    /**\n     *  If receiving ether is supported.\n     */\n    receive;\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi) {\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            }\n            catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { deploy: fragment });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    }\n                    else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { fallback, receive });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal) {\n        const format = (minimal ? \"minimal\" : \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson() {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#functions.get(name)), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#events.get(name)), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            }\n            else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#errors.get(name)), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n    _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            }\n            catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                }\n                catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            }\n            else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            }\n            else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\"address\"], [value]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index) => {\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this.#abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                }\n                else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                }\n                else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        value = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)((tx.value != null) ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof (value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof (value.formatJson) === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof (value.format) === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDVDtBQUN3SjtBQUNwSjtBQUM2QjtBQUNtRDtBQUN2RjtBQUNFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW50ZXJmYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIEludGVyZmFjZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIHY2IGluc3RhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\n\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nclass Typed {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    type;\n    /**\n     *  The actual value.\n     */\n    value;\n    #options;\n    /**\n     *  @_ignore:\n     */\n    _typedSymbol;\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd, type, value, options) {\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { _typedSymbol, type, value });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt() {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString() {\n        return (this.type === \"string\");\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return (this.value).length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v) { return n(v, 8); }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v) { return n(v, 16); }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v) { return n(v, 24); }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v) { return n(v, 32); }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v) { return n(v, 40); }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v) { return n(v, 48); }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v) { return n(v, 56); }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v) { return n(v, 64); }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v) { return n(v, 72); }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v) { return n(v, 80); }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v) { return n(v, 88); }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v) { return n(v, 96); }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v) { return n(v, 104); }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v) { return n(v, 112); }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v) { return n(v, 120); }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v) { return n(v, 128); }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v) { return n(v, 136); }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v) { return n(v, 144); }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v) { return n(v, 152); }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v) { return n(v, 160); }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v) { return n(v, 168); }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v) { return n(v, 176); }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v) { return n(v, 184); }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v) { return n(v, 192); }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v) { return n(v, 200); }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v) { return n(v, 208); }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v) { return n(v, 216); }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v) { return n(v, 224); }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v) { return n(v, 232); }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v) { return n(v, 240); }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v) { return n(v, 248); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v) { return n(v, 256); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v) { return n(v, 256); }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v) { return n(v, -8); }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v) { return n(v, -16); }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v) { return n(v, -24); }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v) { return n(v, -32); }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v) { return n(v, -40); }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v) { return n(v, -48); }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v) { return n(v, -56); }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v) { return n(v, -64); }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v) { return n(v, -72); }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v) { return n(v, -80); }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v) { return n(v, -88); }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v) { return n(v, -96); }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v) { return n(v, -104); }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v) { return n(v, -112); }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v) { return n(v, -120); }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v) { return n(v, -128); }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v) { return n(v, -136); }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v) { return n(v, -144); }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v) { return n(v, -152); }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v) { return n(v, -160); }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v) { return n(v, -168); }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v) { return n(v, -176); }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v) { return n(v, -184); }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v) { return n(v, -192); }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v) { return n(v, -200); }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v) { return n(v, -208); }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v) { return n(v, -216); }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v) { return n(v, -224); }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v) { return n(v, -232); }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v) { return n(v, -240); }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v) { return n(v, -248); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v) { return n(v, -256); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v) { return n(v, -256); }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v) { return b(v, 1); }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v) { return b(v, 2); }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v) { return b(v, 3); }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v) { return b(v, 4); }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v) { return b(v, 5); }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v) { return b(v, 6); }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v) { return b(v, 7); }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v) { return b(v, 8); }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v) { return b(v, 9); }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v) { return b(v, 10); }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v) { return b(v, 11); }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v) { return b(v, 12); }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v) { return b(v, 13); }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v) { return b(v, 14); }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v) { return b(v, 15); }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v) { return b(v, 16); }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v) { return b(v, 17); }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v) { return b(v, 18); }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v) { return b(v, 19); }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v) { return b(v, 20); }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v) { return b(v, 21); }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v) { return b(v, 22); }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v) { return b(v, 23); }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v) { return b(v, 24); }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v) { return b(v, 25); }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v) { return b(v, 26); }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v) { return b(v, 27); }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v) { return b(v, 28); }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v) { return b(v, 29); }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v) { return b(v, 30); }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v) { return b(v, 31); }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v) { return b(v, 32); }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value) {\n        return (value\n            && typeof (value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsS0FBSyxNQUFNLFlBQVksZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CLFlBQVksTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQixRQUFRLGlFQUFnQixTQUFTLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUssUUFBUSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nfunction getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nfunction getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ2M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQix5REFBUSxDQUFDLDJEQUFTO0FBQ3JDLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwrREFBYztBQUNsQix5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFLFlBQVksTUFBTTtBQUNwRDtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDakI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEsdURBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sMkVBQTJFLGVBQWU7QUFDeEcsUUFBUSwrREFBYyxvQ0FBb0M7QUFDMUQ7QUFDQSxXQUFXLHVEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekMsbUJBQW1CLHVEQUFVO0FBQzdCO0FBQ0EsUUFBUSx1REFBTSxvRkFBb0YsMEJBQTBCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY2hlY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/contract-address.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nfunction getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    }\n    else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    }\n    else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([from, nonceHex])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\"0xff\", from, salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=contract-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ3VEO0FBQzVEO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHVEQUFVO0FBQzNCLGtCQUFrQiwwREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQVUsQ0FBQywwREFBUyxDQUFDLDJEQUFTLENBQUMsMERBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsdURBQVU7QUFDM0IsaUJBQWlCLHlEQUFRO0FBQ3pCLHlCQUF5Qix5REFBUTtBQUNqQyxJQUFJLCtEQUFjO0FBQ2xCLElBQUksK0RBQWM7QUFDbEIsV0FBVyx1REFBVSxDQUFDLDBEQUFTLENBQUMsMkRBQVMsQ0FBQyx1REFBTTtBQUNoRDtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/contract-address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nconst ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9hZGRyZXNzZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */\nconst ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gaGFzaC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof (target) === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                }\n                catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { filters });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                }\n                catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                }\n                catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nclass Contract extends _ContractBase() {\n}\n//# sourceMappingURL=contract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNpQjtBQUNwRTtBQUNBO0FBQzREO0FBQ2lHO0FBQ2pCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpRUFBYztBQUM5RTtBQUNBLCtCQUErQixpRUFBYztBQUM3QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixnREFBSztBQUM1QixJQUFJLCtEQUFjO0FBQ2xCO0FBQ0Esc0JBQXNCLG1FQUFXO0FBQ2pDLElBQUksK0RBQWM7QUFDbEIsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFD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QUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaXNDYWxsRXhjZXB0aW9uLCBpc0hleFN0cmluZywgcmVzb2x2ZVByb3BlcnRpZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMudG8gPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcInRvXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIHRvXCIsIFwib3ZlcnJpZGVzLnRvXCIsIG92ZXJyaWRlcy50byk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udHJhY3QuaW50ZXJmYWNlO1xuICAgICAgICBjb25zdCBub1ZhbHVlID0gKGdldEJpZ0ludCgodHgudmFsdWUgfHwgQk5fMCksIFwib3ZlcnJpZGVzLnZhbHVlXCIpID09PSBCTl8wKTtcbiAgICAgICAgY29uc3Qgbm9EYXRhID0gKCh0eC5kYXRhIHx8IFwiMHhcIikgPT09IFwiMHhcIik7XG4gICAgICAgIGlmIChpZmFjZS5mYWxsYmFjayAmJiAhaWZhY2UuZmFsbGJhY2sucGF5YWJsZSAmJiBpZmFjZS5yZWNlaXZlICYmICFub0RhdGEgJiYgIW5vVmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGF5YWJsZSB8fCBub1ZhbHVlLCBcImNhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzLnZhbHVlXCIsIHR4LnZhbHVlKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBmYWxsYmFjayBjb250cmFjdHMgdG8gc2V0IG5vbi1lbXB0eSBkYXRhXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsUmVzdWx0ID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGwsIHN0YXRpY0NhbGxSZXN1bHQsXG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnROYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnRcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9waWNIYXNoaWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljcyBhbmQgc29ydCBUb3BpY1NldHNcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSkudmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhZyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4geyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcbiAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViKGNvbnRyYWN0LCBvcGVyYXRpb24sIGV2ZW50KSB7XG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgW10sIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0YXJnZXQsIHJ1bm5lciwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xuICAgICAgICBsZXQgYWRkciA9IG51bGw7XG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIocnVubmVyKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgIGRlcGxveVR4ID0gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSB8fCB0aGlzLmludGVyZmFjZS5oYXNFdmVudChTdHJpbmcocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHRhcmdldCBhbmQgQUJJLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXG4gICAgICovXG4gICAgYXR0YWNoKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkZXBsb3llZCBieXRlY29kZSBvciBudWxsIGlmIG5vIGJ5dGVjb2RlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcikpLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cbiAgICAgKi9cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogIGFmdGVyIGl0IGlzIGZpcmVkIG9uY2UuXG4gICAgICovXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25jZVwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbWl0IGFuICUlZXZlbnQlJSBjYWxsaW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCAlJWFyZ3MlJS5cbiAgICAgKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiAgb2YgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gJSVldmVudCUlIG9yIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxuICAgICAqICB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCBzdG9wIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXG4gICAgICovXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoYWRkcmVzcywgcnVubmVyID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    error;\n    /**\n     * @_ignore:\n     */\n    constructor(log, error) {\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { error });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nclass ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nclass ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nclass ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nclass ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\n//# sourceMappingURL=wrappers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN3RjtBQUNyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDTyx1QkFBdUIsdURBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLHVEQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsc0VBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsdUVBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMseURBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC93cmFwcGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7IH1cbn1cbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXG4gICAgICogIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbG9nLnRvcGljcy5sZW5ndGggPyB0aGlzLiNpZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy4jaWZhY2UsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSoqIHdpbGwgcmV0dXJuIGFcbiAqICBbW0NvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XV0gd2hlbiB3YWl0ZWQgb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFVua25vd25FdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgZG9lcyBub3QgbWF0Y2ggYW55IGV2ZW50cyBpbiB0aGUgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGZyYWdtZW50LCBfbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBuZXcgRXZlbnRMb2coX2xvZywgY29udHJhY3QuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/wrappers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/crypto-browser.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/crypto-browser.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHash: () => (/* binding */ createHash),\n/* harmony export */   createHmac: () => (/* binding */ createHmac),\n/* harmony export */   pbkdf2Sync: () => (/* binding */ pbkdf2Sync),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* Browser Crypto Shims */\n\n\n\n\n\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nfunction createHash(algo) {\n    switch (algo) {\n        case \"sha256\": return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256.create();\n        case \"sha512\": return _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512.create();\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nfunction createHmac(_algo, key) {\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__.hmac.create(algo, key);\n}\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(algo, password, salt, { c: iterations, dkLen: keylen });\n}\nfunction randomBytes(length) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n//# sourceMappingURL=crypto-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2NyeXB0by1icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQ0k7QUFDQTtBQUNBO0FBQ2E7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4Qix3REFBTTtBQUNwQyw4QkFBOEIsd0RBQU07QUFDcEM7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ087QUFDUCxvQkFBb0IsTUFBTSxrRUFBUSw0REFBRTtBQUNwQyxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsb0RBQUk7QUFDZjtBQUNPO0FBQ1Asb0JBQW9CLE1BQU0sa0VBQVEsNERBQUU7QUFDcEMsSUFBSSwrREFBYztBQUNsQixXQUFXLDREQUFNLHlCQUF5Qiw4QkFBOEI7QUFDeEU7QUFDTztBQUNQLElBQUksdURBQU07QUFDVjtBQUNBLEtBQUs7QUFDTCxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9jcnlwdG8tYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBCcm93c2VyIENyeXB0byBTaGltcyAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG47XG5jb25zdCBhbnlHbG9iYWwgPSBnZXRHbG9iYWwoKTtcbmNvbnN0IGNyeXB0byA9IGFueUdsb2JhbC5jcnlwdG8gfHwgYW55R2xvYmFsLm1zQ3J5cHRvO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2goYWxnbykge1xuICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgICBjYXNlIFwic2hhMjU2XCI6IHJldHVybiBzaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGNhc2UgXCJzaGE1MTJcIjogcmV0dXJuIHNoYTUxMi5jcmVhdGUoKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBoYXNoaW5nIGFsZ29yaXRobSBuYW1lXCIsIFwiYWxnb3JpdGhtXCIsIGFsZ28pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoX2FsZ28sIGtleSkge1xuICAgIGNvbnN0IGFsZ28gPSAoeyBzaGEyNTYsIHNoYTUxMiB9W19hbGdvXSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoYWxnbyAhPSBudWxsLCBcImludmFsaWQgaG1hYyBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBobWFjLmNyZWF0ZShhbGdvLCBrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgX2FsZ28pIHtcbiAgICBjb25zdCBhbGdvID0gKHsgc2hhMjU2LCBzaGE1MTIgfVtfYWxnb10pO1xuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIHBia2RmMiBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBwYmtkZjIoYWxnbywgcGFzc3dvcmQsIHNhbHQsIHsgYzogaXRlcmF0aW9ucywgZGtMZW46IGtleWxlbiB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICBhc3NlcnQoY3J5cHRvICE9IG51bGwsIFwicGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBzZWN1cmUgcmFuZG9tIG51bWJlcnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwicmFuZG9tQnl0ZXNcIlxuICAgIH0pO1xuICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCA8PSAxMDI0LCBcImludmFsaWQgbGVuZ3RoXCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/crypto-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\n\n\nlet locked = false;\nconst _keccak256 = function (data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nfunction keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ007QUFDdEQ7QUFDQTtBQUNBLFdBQVcsOERBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9rZWNjYWsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBrZWNjYWtfMjU2KGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/sha2.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n\n\nconst _sha256 = function (data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function (data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nfunction sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function () { locked256 = true; };\nsha256.register = function (func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */\nfunction sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function () { locked512 = true; };\nsha512.register = function (func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256);\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNhO0FBQ3REO0FBQ0EsV0FBVyxzREFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxzREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix5REFBUTtBQUN6QixXQUFXLHdEQUFPO0FBQ2xCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHlEQUFRO0FBQ3pCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgX3NoYTI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmNvbnN0IF9zaGE1MTIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcbmxldCBsb2NrZWQyNTYgPSBmYWxzZSwgbG9ja2VkNTEyID0gZmFsc2U7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTI1NihkYXRhKSk7XG59XG5zaGEyNTYuXyA9IF9zaGEyNTY7XG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcbnNoYTI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGE1MTIoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTUxMihkYXRhKSk7XG59XG5zaGE1MTIuXyA9IF9zaGE1MTI7XG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTUxMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nclass Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r() { return this.#r; }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parseInt(this.#s.substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", this.#s);\n        return this.#s;\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        this.#s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n    }\n    /**\n     *  Return the s value, unchecked for EIP-2 compliance.\n     *\n     *  This should generally not be used and is for situations where\n     *  a non-canonical S value might be relevant, such as Frontier blocks\n     *  that were mined prior to EIP-2 or invalid Authorization List\n     *  signatures.\n     */\n    get _s() { return this.#s; }\n    /**\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n     */\n    isValid() {\n        return (parseInt(this.#s.substring(0, 3)) < 8);\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v() { return this.#v; }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV() { return this.#networkV; }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity() {\n        return (this.v === 27) ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n    get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\n    }\n    /**\n     *  @private\n     */\n    constructor(guard, r, s, v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `Signature { r: \"${this.r}\", s: \"${this._s}\"${this.isValid() ? \"\" : ', valid: \"false\"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone() {\n        const clone = new Signature(_guard, this.r, this._s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString() : null),\n            r: this.r, s: this._s, v: this.v,\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId, v) {\n        return ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, 27);\n        }\n        if (typeof (sig) === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(32, 64));\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, s, v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function (s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v : undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: (((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80) ? 28 : 27) };\n            }\n            if (yParity != null) {\n                switch ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNvSDtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZLENBQUMsMERBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDJEQUFVO0FBQ2pDLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYywwREFBMEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDJEQUFVO0FBQ2pDLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsMERBQVM7QUFDM0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxPQUFPLFNBQVMsUUFBUSxHQUFHLHlDQUF5QyxhQUFhLGFBQWEsY0FBYyxnQkFBZ0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQVEsRUFBRSx5REFBUTtBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFRO0FBQ2xDO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3REFBTztBQUN2RDtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDLDBCQUEwQix3REFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBVztBQUN2Qyw4QkFBOEIseURBQVE7QUFDdEM7QUFDQSx1QkFBdUIsd0RBQU87QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSwwQkFBMEIsMERBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFXO0FBQ3ZDLHlCQUF5QixLQUFLLHlEQUFRO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBEQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWmVyb0hhc2ggfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodG9CZUFycmF5KHZhbHVlKSwgMzIpO1xufVxuLyoqXG4gKiAgQSBTaWduYXR1cmUgIEBUT0RPXG4gKlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpTaWduaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgICNyO1xuICAgICNzO1xuICAgICN2O1xuICAgICNuZXR3b3JrVjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgcmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHJlcHJlc2VudHMgdGhlIGBgeGBgIGNvb3JkaW5hdGUgb2YgYSBcInJlZmVyZW5jZVwiIG9yXG4gICAgICogIGNoYWxsZW5nZSBwb2ludCwgZnJvbSB3aGljaCB0aGUgYGB5YGAgY2FuIGJlIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGdldCByKCkgeyByZXR1cm4gdGhpcy4jcjsgfVxuICAgIHNldCByKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgodmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3IgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHNgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IHMoKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzOyB1c2UgLl9zXCIsIFwic1wiLCB0aGlzLiNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3M7XG4gICAgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSBoZXhsaWZ5KF92YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHMgdmFsdWUsIHVuY2hlY2tlZCBmb3IgRUlQLTIgY29tcGxpYW5jZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYW5kIGlzIGZvciBzaXR1YXRpb25zIHdoZXJlXG4gICAgICogIGEgbm9uLWNhbm9uaWNhbCBTIHZhbHVlIG1pZ2h0IGJlIHJlbGV2YW50LCBzdWNoIGFzIEZyb250aWVyIGJsb2Nrc1xuICAgICAqICB0aGF0IHdlcmUgbWluZWQgcHJpb3IgdG8gRUlQLTIgb3IgaW52YWxpZCBBdXRob3JpemF0aW9uIExpc3RcbiAgICAgKiAgc2lnbmF0dXJlcy5cbiAgICAgKi9cbiAgICBnZXQgX3MoKSB7IHJldHVybiB0aGlzLiNzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgU2lnbmF0dXJlIGlzIHZhbGlkIGZvciBbW2xpbmstZWlwLTJdXSBzaWduYXR1cmVzLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAocGFyc2VJbnQodGhpcy4jcy5zdWJzdHJpbmcoMCwgMykpIDwgOCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHYgPT09IDI3IHx8IHYgPT09IDI4LCBcImludmFsaWQgdlwiLCBcInZcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFSVAtMTU1IGBgdmBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG5ldHdvcmtWKCkgeyByZXR1cm4gdGhpcy4jbmV0d29ya1Y7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIGZvciBFSVAtMTU1IGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbGVnYWN5Q2hhaW5JZCgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZ2V0Q2hhaW5JZCh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHlQYXJpdHlgYCBmb3IgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTZWUgYGB2YGAgZm9yIG1vcmUgZGV0YWlscyBvbiBob3cgdGhpcyB2YWx1ZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudiA9PT0gMjcpID8gMCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYGB5UGFyaXR5YGBcbiAgICAgKiAgYW5kIGBgc2BgIGNvbXBhY3RlZCBpbnRvIGEgc2luZ2xlIGBgYnl0ZXMzMmBgLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5QW5kUygpIHtcbiAgICAgICAgLy8gVGhlIEVJUC0yMDk4IGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAgICAgICAgY29uc3QgeVBhcml0eUFuZFMgPSBnZXRCeXRlcyh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHlQYXJpdHlBbmRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjb21wYWN0U2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnlQYXJpdHlBbmRTXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xuICAgICAgICB0aGlzLiNyID0gcjtcbiAgICAgICAgdGhpcy4jcyA9IHM7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5fc31cIiR7dGhpcy5pc1ZhbGlkKCkgPyBcIlwiIDogJywgdmFsaWQ6IFwiZmFsc2VcIid9LCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLl9zLCB0aGlzLnYpO1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrVikge1xuICAgICAgICAgICAgY2xvbmUuI25ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYGBKU09OLnN0cmluZ2lmeWBgLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBuZXR3b3JrVjogKChuZXR3b3JrViAhPSBudWxsKSA/IG5ldHdvcmtWLnRvU3RyaW5nKCkgOiBudWxsKSxcbiAgICAgICAgICAgIHI6IHRoaXMuciwgczogdGhpcy5fcywgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKGdldEJpZ0ludChjaGFpbklkKSAqIEJOXzIpICsgQmlnSW50KDM1ICsgdiAtIDI3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIGZyb20gYSBgYHlQYXJpcnR5YGAsXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9uIChpLmUuID49IDM1KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxuICAgICAqICAgIC8vX2Vycm9yOlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBcInNpZ25hdHVyZVwiLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHNpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XG4gICAgICAgICAgICAgICAgc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHJhdyBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWcuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgclxuICAgICAgICBjb25zdCBfciA9IHNpZy5yO1xuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XG4gICAgICAgIC8vIEdldCBzOyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VaW50MjU2KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XG4gICAgICAgIH0pKHNpZy5zLCBzaWcueVBhcml0eUFuZFMpO1xuICAgICAgICAvLyBHZXQgdjsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHsgbmV0d29ya1YsIHYgfSA9IChmdW5jdGlvbiAoX3YsIHlQYXJpdHlBbmRTLCB5UGFyaXR5KSB7XG4gICAgICAgICAgICBpZiAoX3YgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRCaWdJbnQoX3YpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtWOiAoKHYgPj0gQk5fMzUpID8gdiA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVih2KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2OiAoKGdldEJ5dGVzKHlQYXJpdHlBbmRTKVswXSAmIDB4ODApID8gMjggOiAyNykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGdldE51bWJlcih5UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHsgdjogMjcgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4geyB2OiAyOCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHZcIik7XG4gICAgICAgIH0pKHNpZy52LCBzaWcueVBhcml0eUFuZFMsIHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xuICAgICAgICBpZiAobmV0d29ya1YpIHtcbiAgICAgICAgICAgIHJlc3VsdC4jbmV0d29ya1YgPSBuZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBtdWx0aXBsZSBvZiB2LCB5UGFyaXR5LCB5UGFyaXR5QW5kUyB3ZSBnaXZlbiwgY2hlY2sgdGhleSBtYXRjaFxuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eSA9PSBudWxsIHx8IGdldE51bWJlcihzaWcueVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSA9PT0gcmVzdWx0LnlQYXJpdHksIFwieVBhcml0eSBtaXNtYXRjaFwiKTtcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHlBbmRTID09IG51bGwgfHwgc2lnLnlQYXJpdHlBbmRTID09PSByZXN1bHQueVBhcml0eUFuZFMsIFwieVBhcml0eUFuZFMgbWlzbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signature.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\n\n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\nclass SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */\n    get privateKey() { return this.#privateKey; }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */\n    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */\n    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */\n    sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.s, 32),\n            v: (sig.recovery ? 0x1c : 0x1b)\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */\n    computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */\n    static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */\n    static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([sig.r, sig.s])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */\n    static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n}\n//# sourceMappingURL=signing-key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDNkQ7QUFDdEU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsMkJBQTJCLHdEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsQ0FBQywyREFBVTtBQUNqQyxvQkFBb0IsOERBQVMsTUFBTSw2REFBWSxVQUFVLDZEQUFZO0FBQ3JFO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQVM7QUFDeEIsZUFBZSx3REFBTztBQUN0QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTyxDQUFDLDhEQUFTLGlCQUFpQiw2REFBWSxvQkFBb0IseURBQVE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFRO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkIsOERBQVM7QUFDcEMsbUJBQW1CLHdEQUFPO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUztBQUMvQixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsb0JBQW9CLG9EQUFTO0FBQzdCLHNCQUFzQiw4REFBUyx1QkFBdUIsNkRBQVksQ0FBQyx1REFBTTtBQUN6RTtBQUNBLGdEQUFnRCw2REFBWTtBQUM1RCxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFTO0FBQzlCLHFCQUFxQiw4REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFkZCBkZXRhaWxzIGFib3V0IHNpZ25pbmcgaGVyZS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlNpZ25pbmcgIFthYm91dC1zaWduaW5nXVxuICovXG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgdG9CZUhleCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuL3NpZ25hdHVyZS5qc1wiO1xuLyoqXG4gKiAgQSAqKlNpZ25pbmdLZXkqKiBwcm92aWRlcyBoaWdoLWxldmVsIGFjY2VzcyB0byB0aGUgZWxsaXB0aWMgY3VydmVcbiAqICBjcnlwdG9ncmFwaHkgKEVDQykgb3BlcmF0aW9ucyBhbmQga2V5IG1hbmFnZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICAjcHJpdmF0ZUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNpZ25pbmdLZXkqKiBmb3IgJSVwcml2YXRlS2V5JSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI3ByaXZhdGVLZXkgPSBoZXhsaWZ5KHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5LlxuICAgICAqL1xuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy4jcHJpdmF0ZUtleTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYDB4MDRgYCBhbmQgYmUgMTMyXG4gICAgICogY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMTMwIGhleGFkZWNpbWFsIG5pYmJsZXMpLlxuICAgICAqL1xuICAgIGdldCBwdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggZWl0aGVyIHRoZSBwcmVmaXggYGAweDAyYGAgb3IgYGAweDAzYGBcbiAgICAgKiAgYW5kIGJlIDY4IGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDMzIGhleGFkZWNpbWFsXG4gICAgICogIG5pYmJsZXMpXG4gICAgICovXG4gICAgZ2V0IGNvbXByZXNzZWRQdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCAlJWRpZ2VzdCUlLlxuICAgICAqL1xuICAgIHNpZ24oZGlnZXN0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKGdldEJ5dGVzQ29weShkaWdlc3QpLCBnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGxvd1M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB0b0JlSGV4KHNpZy5yLCAzMiksXG4gICAgICAgICAgICBzOiB0b0JlSGV4KHNpZy5zLCAzMiksXG4gICAgICAgICAgICB2OiAoc2lnLnJlY292ZXJ5ID8gMHgxYyA6IDB4MWIpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgW1tsaW5rLXdpa2ktZWNkaF1dIHNoYXJlZCBzZWNyZXQgYmV0d2VlbiB0aGlzXG4gICAgICogIHByaXZhdGUga2V5IGFuZCB0aGUgJSVvdGhlciUlIGtleS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVvdGhlciUlIGtleSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LFxuICAgICAqICBhIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmljIGtleSBvciBhcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQmVzdCBwcmFjdGljZSBpcyB1c3VhbGx5IHRvIHVzZSBhIGNyeXB0b2dyYXBoaWMgaGFzaCBvbiB0aGVcbiAgICAgKiAgcmV0dXJuZWQgdmFsdWUgYmVmb3JlIHVzaW5nIGl0IGFzIGEgc3ltZXRyaWMgc2VjcmV0LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24xID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0xXCIpKVxuICAgICAqICAgIHNpZ24yID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0yXCIpKVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoYXQgcHJpdkEuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJCKS4uLlxuICAgICAqICAgIHNpZ24xLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjIucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHByaXZCLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQSkuXG4gICAgICogICAgc2lnbjIuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMS5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIGdldEJ5dGVzKHB1YktleSksIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciAlJWtleSUlLCBvcHRpb25hbGx5ICUlY29tcHJlc3NlZCUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJWtleSUlIG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksIGFcbiAgICAgKiAgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHVibGljIGtleSBvciBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSk7XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSwgdHJ1ZSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgZmFsc2UpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIENvbXByZXNzZWQgYSBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCB0cnVlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzKGtleSwgXCJrZXlcIik7XG4gICAgICAgIC8vIHByaXZhdGUga2V5XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5KGJ5dGVzLCAhIWNvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocHViS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByYXcgcHVibGljIGtleTsgdXNlIHVuY29tcHJlc3NlZCBrZXkgd2l0aCAweDA0IHByZWZpeFxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgICAgICAgICAgcHViWzBdID0gMHgwNDtcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShwb2ludC50b1Jhd0J5dGVzKGNvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBwcml2YXRlIGtleSB3aGljaCBwcm9kdWNlZCB0aGVcbiAgICAgKiAgJSVzaWduYXR1cmUlJSBmb3IgdGhlIGdpdmVuICUlZGlnZXN0JSUuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAga2V5ID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSlcbiAgICAgKiAgICBkaWdlc3QgPSBpZChcImhlbGxvIHdvcmxkXCIpXG4gICAgICogICAgc2lnID0ga2V5LnNpZ24oZGlnZXN0KVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoZSBzaWduZXIgcHVibGljIGtleS4uLlxuICAgICAqICAgIGtleS5wdWJsaWNLZXlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byB0aGUgcmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KGdldEJ5dGVzQ29weShjb25jYXQoW3NpZy5yLCBzaWcuc10pKSk7XG4gICAgICAgIHNlY3BTaWcgPSBzZWNwU2lnLmFkZFJlY292ZXJ5Qml0KHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcFNpZy5yZWNvdmVyUHVibGljS2V5KGdldEJ5dGVzQ29weShkaWdlc3QpKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHViS2V5ICE9IG51bGwsIFwiaW52YWxpZCBzaWduYXR1cmUgZm9yIGRpZ2VzdFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViS2V5LnRvSGV4KGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHBvaW50IHJlc3VsdGluZyBmcm9tIGFkZGluZyB0aGUgZWxsaXBpYyBjdXJ2ZSBwb2ludHNcbiAgICAgKiAgJSVwMCUlIGFuZCAlJXAxJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgYSBjb21tb24gZnVuY3Rpb24gbW9zdCBkZXZlbG9wZXJzIHNob3VsZCByZXF1aXJlLCBidXRcbiAgICAgKiAgY2FuIGJlIHVzZWZ1bCBmb3IgY2VydGFpbiBwcml2YWN5LXNwZWNpZmljIHRlY2huaXF1ZXMuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgW1tIRE5vZGVXYWxsZXRdXSB0byBjb21wdXRlIGNoaWxkXG4gICAgICogIGFkZHJlc3NlcyBmcm9tIHBhcmVudCBwdWJsaWMga2V5cyBhbmQgY2hhaW4gY29kZXMuXG4gICAgICovXG4gICAgc3RhdGljIGFkZFBvaW50cyhwMCwgcDEsIGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgcHViMCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDApLnN1YnN0cmluZygyKSk7XG4gICAgICAgIGNvbnN0IHB1YjEgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAxKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViMC5hZGQocHViMSkudG9IZXgoISFjb21wcmVzc2VkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signing-key.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nfunction id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n}\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDJEQUFTLENBQUMsNERBQVc7QUFDaEM7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/namehash.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/namehash.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(app-pages-browser)/../../node_modules/.pnpm/@adraffy+ens-normalize@1.10.1/node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nfunction ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nfunction namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([result, (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((comps.pop()))]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nfunction dnsEncode(name, _maxLength) {\n    const length = (_maxLength != null) ? _maxLength : 63;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp) => {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYyx1Q0FBdUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWMseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDZCQUE2QixjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwrREFBYyxnREFBZ0Q7QUFDbEUsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVMsQ0FBQyx1REFBTSxVQUFVLDJEQUFTO0FBQ3BEO0FBQ0EsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsd0RBQU8sQ0FBQyx1REFBTTtBQUN6QixRQUFRLCtEQUFjLGlDQUFpQyxzQkFBc0IsVUFBVSxRQUFRO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSwgX21heExlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IChfbWF4TGVuZ3RoICE9IG51bGwpID8gX21heExlbmd0aCA6IDYzO1xuICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCA8PSAyNTUsIFwiRE5TIGVuY29kZWQgbGFiZWwgY2Fubm90IGV4Y2VlZCAyNTVcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCA8PSBsZW5ndGgsIGBsYWJlbCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBleGNlZWRzICR7bGVuZ3RofSBieXRlc2AsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/namehash.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? (width - 1) : width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\n            return function (_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function (value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: (match[2] + match[4]),\n            array: {\n                base: match[1],\n                prefix: (match[1] + match[2]),\n                count: (match[5] ? parseInt(match[5]) : -1),\n            }\n        };\n    }\n    return { base: type };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nclass TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    primaryType;\n    #types;\n    /**\n     *  The types.\n     */\n    get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(_types) {\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type) => {\n            types[type] = _types[type].map(({ name, type }) => {\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return { name, type: (base + (index || \"\")) };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for (const name in types) {\n            const uniqueNames = new Set();\n            for (const field of types[name]) {\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, { primaryType: primaryTypes[0] });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)) {\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value) => {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(this.#fullTypes.get(type));\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v) => this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value) => {\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value) => {\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return { domain, value };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_7__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLGtDQUFrQztBQUNJO0FBQ0Y7QUFDVTtBQUNnSDtBQUM1STtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseURBQVE7QUFDMUI7QUFDQTtBQUNBLGVBQWUsdURBQU07QUFDckI7QUFDQSxXQUFXLHdEQUFPO0FBQ2xCO0FBQ0EsZ0JBQWdCLHdEQUFPO0FBQ3ZCLGlCQUFpQix3REFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDBEQUEwRCxvQkFBb0IsYUFBYSxJQUFJO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFTO0FBQy9CLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBVTtBQUN6QixLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiw2REFBVTtBQUM3QjtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QixLQUFLO0FBQ0w7QUFDQSxzQkFBc0IseURBQVE7QUFDOUIsUUFBUSwrREFBYztBQUN0QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUIsZ0NBQWdDLHFEQUFJO0FBQ3BDO0FBQ0E7QUFDQSw4QkFBOEIsMERBQVM7QUFDdkMsZ0JBQWdCLCtEQUFjLDBFQUEwRSxLQUFLO0FBQzdHLHVCQUF1Qix3REFBTyxVQUFVLHVEQUFN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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFPLENBQUMseURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxRUFBYztBQUN6QjtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgeyBUeXBlZERhdGFEb21haW4sIFR5cGVkRGF0YUZpZWxkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGhleGxpZnksIGlzSGV4U3RyaW5nLCBtYXNrLCB0b0JlSGV4LCB0b1F1YW50aXR5LCB0b1R3b3MsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWQuanNcIjtcbmNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheSgzMik7XG5wYWRkaW5nLmZpbGwoMCk7XG5jb25zdCBCTl9fMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuO1xuO1xuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBjb25zdCBwYWRPZmZzZXQgPSBieXRlcy5sZW5ndGggJSAzMjtcbiAgICBpZiAocGFkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xufVxuY29uc3QgaGV4VHJ1ZSA9IHRvQmVIZXgoQk5fMSwgMzIpO1xuY29uc3QgaGV4RmFsc2UgPSB0b0JlSGV4KEJOXzAsIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgJHtKU09OLnN0cmluZ2lmeShrZXkpfWAsIGBkb21haW4uJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IGRvbWFpbkNoZWNrcyA9IHtcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXG4gICAgdmVyc2lvbjogY2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLFxuICAgIGNoYWluSWQ6IGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcImRvbWFpbi5jaGFpbklkXCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAwLCBcImludmFsaWQgY2hhaW4gSURcIiwgXCJkb21haW4uY2hhaW5JZFwiLCBfdmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh2YWx1ZSk7XG4gICAgfSxcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlLCBcImRvbWFpbi5zYWx0XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IDMyLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLCBcImRvbWFpbi5zYWx0XCIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNVcHBlciA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzTG93ZXIgPSBzaWduZWQgPyAoKGJvdW5kc1VwcGVyICsgQk5fMSkgKiBCTl9fMSkgOiBCTl8wO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gYm91bmRzTG93ZXIgJiYgdmFsdWUgPD0gYm91bmRzVXBwZXIsIGB2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvQmVIZXgoc2lnbmVkID8gdG9Ud29zKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAzMiAmJiBtYXRjaFsxXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShnZXRBZGRyZXNzKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghdmFsdWUpID8gaGV4RmFsc2UgOiBoZXhUcnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0oJHtmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4gKHR5cGUgKyBcIiBcIiArIG5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbn1cbi8vIGZvb1tdWzNdID0+IHsgYmFzZTogXCJmb29cIiwgaW5kZXg6IFwiW11bM11cIiwgYXJyYXk6IHtcbi8vICAgICBiYXNlOiBcImZvb1wiLCBwcmVmaXg6IFwiZm9vW11cIiwgY291bnQ6IDMgfSB9XG5mdW5jdGlvbiBzcGxpdEFycmF5KHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oW15cXHg1Yl0qKSgoXFx4NWJcXGQqXFx4NWQpKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIGluZGV4OiAobWF0Y2hbMl0gKyBtYXRjaFs0XSksXG4gICAgICAgICAgICBhcnJheToge1xuICAgICAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIHByZWZpeDogKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIGNvdW50OiAobWF0Y2hbNV0gPyBwYXJzZUludChtYXRjaFs1XSkgOiAtMSksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGJhc2U6IHR5cGUgfTtcbn1cbi8qKlxuICogIEEgKipUeXBlZERhdGFFbmNvZGUqKiBwcmVwYXJlcyBhbmQgZW5jb2RlcyBbW2xpbmstZWlwLTcxMl1dIHBheWxvYWRzXG4gKiAgZm9yIHNpZ25lZCB0eXBlZCBkYXRhLlxuICpcbiAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhvc2UgdGhhdCB3aXNoIHRvIGNvbXB1dGUgdmFyaW91cyBjb21wb25lbnRzIG9mIGFcbiAqICB0eXBlZCBkYXRhIGhhc2gsIHByaW1hcnkgdHlwZXMsIG9yIHN1Yi1jb21wb25lbnRzLCBidXQgZ2VuZXJhbGx5IHRoZVxuICogIGhpZ2hlciBsZXZlbCBbW1NpZ25lci1zaWduVHlwZWREYXRhXV0gaXMgbW9yZSB1c2VmdWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZGVyaXZlZCBhdXRvbWF0aWNhbGx5IGZyb20gdGhlIFtbdHlwZXNdXSwgc2luY2Ugbm9cbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxuICAgICAqICBpbnRlcm5hbGx5LCB0aGUgcHJpbWFyeSB0eXBlIG11c3QgYmUgdGhlIG9ubHkgcmVtYWluaW5nIHR5cGUgd2l0aFxuICAgICAqICBubyBwYXJlbnQgbm9kZXMuXG4gICAgICovXG4gICAgcHJpbWFyeVR5cGU7XG4gICAgI3R5cGVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGVzKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLiN0eXBlcyk7XG4gICAgfVxuICAgICNmdWxsVHlwZXM7XG4gICAgI2VuY29kZXJDYWNoZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwZXJmb3JtcyBhbGwgbmVjZXNzYXJ5IGNoZWNraW5nIHRoYXQgdHlwZXMgYXJlIHZhbGlkIGFuZFxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXG4gICAgICogIHdlbGwgYXMgY29tcHV0ZXMgdGhlIFtbcHJpbWFyeVR5cGVdXS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdHlwZXMpIHtcbiAgICAgICAgdGhpcy4jZnVsbFR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSBfdHlwZXNbdHlwZV0ubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmFzZSB0eXBlICh1bmxlc3MgbmFtZSBjb25mbGljdClcbiAgICAgICAgICAgICAgICBsZXQgeyBiYXNlLCBpbmRleCB9ID0gc3BsaXRBcnJheSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJpbnRcIiAmJiAhX3R5cGVzW1wiaW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcImludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJ1aW50XCIgJiYgIV90eXBlc1tcInVpbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwidWludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lLCB0eXBlOiAoYmFzZSArIChpbmRleCB8fCBcIlwiKSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlua3Muc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBwYXJlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3R5cGVzID0gSlNPTi5zdHJpbmdpZnkodHlwZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghdW5pcXVlTmFtZXMuaGFzKGZpZWxkLm5hbWUpLCBgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gc3BsaXRBcnJheShmaWVsZC50eXBlKS5iYXNlO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJhc2VUeXBlICE9PSBuYW1lLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyZW50cy5oYXMoYmFzZVR5cGUpLCBgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGJhc2VUeXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzLmdldChuYW1lKS5hZGQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoICE9PSAwLCBcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMSwgYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKCh0KSA9PiAoSlNPTi5zdHJpbmdpZnkodCkpKS5qb2luKFwiLCBcIil9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodHlwZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpbmtzLmdldCh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzLmdldChzdWJ0eXBlKS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNldF0gb2Ygc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy4jZnVsbFR5cGVzLnNldChuYW1lLCBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxuICAgICAqL1xuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuI2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICAjZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gYXJyYXkucHJlZml4O1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyhzdWJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoY29uY2F0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSBpZCh0aGlzLiNmdWxsVHlwZXMuZ2V0KHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWVbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGwgdHlwZSBmb3IgJSVuYW1lJSUuXG4gICAgICovXG4gICAgZW5jb2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bGxUeXBlcy5nZXQobmFtZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCwgYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGhhc2ggb2YgJSV2YWx1ZSUlIGZvciB0aGUgdHlwZSBvZiAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGxlZCBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX3Zpc2l0KGFycmF5LnByZWZpeCwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsICUlY2FsYmFjayUlIGZvciBlYWNoIHZhbHVlIGluICUldmFsdWUlJSwgcGFzc2luZyB0aGUgdHlwZSBhbmRcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHJlcGxhY2luZyBhZGRyZXNzZXMgb3Igb3RoZXIgdHJhbnNmb3JtYXRpb24gdGhhdFxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSB2YWx1ZSBmcm9tIHJlc29sdmluZyBhbGwgYWRkcmVzc2VzIGluICUldmFsdWUlJSBmb3JcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICBkb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCBkb21haW4pO1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG51bGwgdG8gaWdub3JlIHZhbHVlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IGF3YWl0IHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgSlNPTi1lbmNvZGVkIHBheWxvYWQgZXhwZWN0ZWQgYnkgbm9kZXMgd2hpY2ggaW1wbGVtZW50XG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWxpemVkIHR5cGVzXG4gICAgICAgIHR5cGVzID0gZW5jb2Rlci50eXBlcztcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID09IG51bGwsIFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShnZXRCeXRlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIHR5cGVkIGRhdGEgZm9yIHRoZSAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSwgc2lnbmF0dXJlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../contract/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ens-resolver.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof (v) === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof (v) === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof (v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nclass UnmanagedSubscriber {\n    /**\n     *  The name fof the event.\n     */\n    name;\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name) { (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name }); }\n    start() { }\n    stop() { }\n    pause(dropWhilePaused) { }\n    resume() { }\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from((new Set(items)).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = { topics: _event };\n    }\n    if (typeof (_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n    if ((_event.address || _event.topics)) {\n        const event = _event;\n        const filter = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr) => {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                }\n                else {\n                    promises.push((async () => {\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            }\n            else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() { return (new Date()).getTime(); }\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nclass AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network, options) {\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        }\n        else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_4__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        }\n        else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() { return this.#options.pollingInterval; }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider() { return this; }\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead() { return this.#disableCcipRead; }\n    set disableCcipRead(value) { this.#disableCcipRead = !!value; }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            }\n            catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result: { error } });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            }\n            catch (error) { }\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n        }\n        if (typeof (blockTag) === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof (blockTag) === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b) => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t) => {\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock) => {\n            let address = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) {\n                    address.push(this._getAddress(addr));\n                }\n            }\n            else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a) => (typeof (a) !== \"string\")).length ||\n            (fromBlock != null && typeof (fromBlock) !== \"string\") ||\n            (toBlock != null && typeof (toBlock) !== \"string\")) {\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(_request);\n        const promises = [];\n        [\"to\", \"from\"].forEach((key) => {\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function () { request[key] = await addr; })());\n            }\n            else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function () { request.blockTag = await blockTag; })());\n            }\n            else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return (async function () {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                }\n                catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            }\n            else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })())\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({ method: \"call\", transaction, blockTag }));\n        }\n        catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n                }\n                catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\", transaction, info: { data }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n                };\n                this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({}, tx), result });\n                    return result;\n                }\n                catch (error) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({}, tx), error });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof (address) !== \"string\" || typeof (blockTag) !== \"string\") {\n            [address, blockTag] = await Promise.all([address, blockTag]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof (blockTag) !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getLogs\", filter })\n        });\n        return params.map((p) => this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_11__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_12__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_14__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        }\n        catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = (_confirms != null) ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject) => {\n            let timer = null;\n            const listener = (async (blockNumber) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        }\n        else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.EventPayload(this, (once ? null : listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            }\n            catch (error) { }\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return (count > 0);\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        }\n        else {\n            for (const [tag, { started, subscriber }] of this.#subs) {\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused() { return (this.#pausedState != null); }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        }\n        else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */\n    resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.toUtf8String)(bytes);\n        }\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    }\n    catch (error) { }\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\", urls: [], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => result[k]);\n    return result;\n}\n//# sourceMappingURL=abstract-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRTtBQUNiO0FBQ0o7QUFDSjtBQUNVO0FBQ3FPO0FBQzNPO0FBQzBEO0FBQ25FO0FBQ21FO0FBQ2lFO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFnQixTQUFTLE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBVztBQUNuQjtBQUNBLGlCQUFpQix5Q0FBeUMsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxRQUFRLHVEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUksdURBQU0sQ0FBQywwREFBUyxxQkFBcUIsMERBQVM7QUFDbEQ7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDBEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUmVzb2x2ZXIgfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVubWFuYWdlZFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyIHdpdGggJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogX2V2ZW50LCB0YWc6IF9ldmVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyhfZXZlbnQsIDMyKSkge1xuICAgICAgICBjb25zdCBoYXNoID0gX2V2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidHJhbnNhY3Rpb25cIiwgdGFnOiBnZXRUYWcoXCJ0eFwiLCB7IGhhc2ggfSksIGhhc2ggfTtcbiAgICB9XG4gICAgaWYgKF9ldmVudC5vcnBoYW4pIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIC8vIEBUT0RPOiBTaG91bGQgbG93ZXJjYXNlIGFuZCB3aGF0bm90IHRoaW5ncyBoZXJlIGluc3RlYWQgb2YgY29weS4uLlxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9ycGhhblwiLCB0YWc6IGdldFRhZyhcIm9ycGhhblwiLCBldmVudCksIGZpbHRlcjogY29weShldmVudCkgfTtcbiAgICB9XG4gICAgaWYgKChfZXZlbnQuYWRkcmVzcyB8fCBfZXZlbnQudG9waWNzKSkge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgdG9waWNzOiAoKGV2ZW50LnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZEFkZHJlc3MgPSAoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhhZGRyKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGF3YWl0IHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmFkZHJlc3MuZm9yRWFjaChhZGRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZEFkZHJlc3MoZXZlbnQuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBjb25jaXNpZnkoYWRkcmVzc2VzLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyLCB0YWc6IGdldFRhZyhcImV2ZW50XCIsIGZpbHRlciksIHR5cGU6IFwiZXZlbnRcIiB9O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIFByb3ZpZGVyRXZlbnRcIiwgXCJldmVudFwiLCBfZXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8qKlxuICogIEFuICoqQWJzdHJhY3RQcm92aWRlcioqIHByb3ZpZGVzIGEgYmFzZSBjbGFzcyBmb3Igb3RoZXIgc3ViLWNsYXNzZXMgdG9cbiAqICBpbXBsZW1lbnQgdGhlIFtbUHJvdmlkZXJdXSBBUEkgYnkgbm9ybWFsaXppbmcgaW5wdXQgYXJndW1lbnRzIGFuZFxuICogIGZvcm1hdHRpbmcgb3V0cHV0IHJlc3VsdHMgYXMgd2VsbCBhcyB0cmFja2luZyBldmVudHMgZm9yIGNvbnNpc3RlbnRcbiAqICBiZWhhdmlvdXIgb24gYW4gZXZlbnR1YWxseS1jb25zaXN0ZW50IG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjc3VicztcbiAgICAjcGx1Z2lucztcbiAgICAvLyBudWxsPXVucGF1c2VkLCB0cnVlPXBhdXNlZCtkcm9wV2hpbGVQYXVzZWQsIGZhbHNlPXBhdXNlZFxuICAgICNwYXVzZWRTdGF0ZTtcbiAgICAjZGVzdHJveWVkO1xuICAgICNuZXR3b3JrUHJvbWlzZTtcbiAgICAjYW55TmV0d29yaztcbiAgICAjcGVyZm9ybUNhY2hlO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayBudW1iZXIgaWYgcnVubmluZyBhbiBldmVudCBvciAtMSBpZiBubyBcImJsb2NrXCIgZXZlbnRcbiAgICAjbGFzdEJsb2NrTnVtYmVyO1xuICAgICNuZXh0VGltZXI7XG4gICAgI3RpbWVycztcbiAgICAjZGlzYWJsZUNjaXBSZWFkO1xuICAgICNvcHRpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipBYnN0cmFjdFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLCBvclxuICAgICAqICB1c2UgdGhlIHZhcmlvdXMgbmV0d29yayBkZXRlY3Rpb24gY2FwYWJpbGl0aWVzIHRvIGRpc2NvdmVyIHRoZVxuICAgICAqICBbW05ldHdvcmtdXSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfbmV0d29yaykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXh0VGltZXIgPSAxO1xuICAgICAgICB0aGlzLiN0aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRoaXNgYCwgdG8gYWxsb3cgYW4gKipBYnN0cmFjdFByb3ZpZGVyKiogdG8gaW1wbGVtZW50XG4gICAgICogIHRoZSBbW0NvbnRyYWN0UnVubmVyXV0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgcGx1Zy1pbnMuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3IHBsdWctaW4uXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jb25uZWN0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgYSBwbHVnaW4gYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJldmVudCBhbnkgQ0NJUC1yZWFkIG9wZXJhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHJlcXVlc3RlZFxuICAgICAqICBpbiBhIFtbY2FsbF1dIHVzaW5nIGBgZW5hYmxlQ2NpcFJlYWRgYC5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNjaXBSZWFkKCkgeyByZXR1cm4gdGhpcy4jZGlzYWJsZUNjaXBSZWFkOyB9XG4gICAgc2V0IGRpc2FibGVDY2lwUmVhZCh2YWx1ZSkgeyB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSAhIXZhbHVlOyB9XG4gICAgLy8gU2hhcmVzIG11bHRpcGxlIGlkZW50aWNhbCByZXF1ZXN0cyBtYWRlIGR1cmluZyB0aGUgc2FtZSAyNTBtc1xuICAgIGFzeW5jICNwZXJmb3JtKHJlcSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy4jb3B0aW9ucy5jYWNoZVRpbWVvdXQ7XG4gICAgICAgIC8vIENhY2hpbmcgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRhZ1xuICAgICAgICBjb25zdCB0YWcgPSBnZXRUYWcocmVxLm1ldGhvZCwgcmVxKTtcbiAgICAgICAgbGV0IHBlcmZvcm0gPSB0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghcGVyZm9ybSkge1xuICAgICAgICAgICAgcGVyZm9ybSA9IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5zZXQodGFnLCBwZXJmb3JtKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZykgPT09IHBlcmZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRhdGEgZm9yIGV4ZWN1dGluZyB0aGUgQ0NJUC1yZWFkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwIHx8IHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHtkYXRhfSBpcyBwcmVzZW50LCB1c2UgUE9TVDsgb3RoZXJ3aXNlIEdFVFxuICAgICAgICAgICAgLy9jb25zdCBqc29uOiBzdHJpbmcgfCBudWxsID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAvLyAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHsgZGF0YSwgc2VuZGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRGZXRjaFJlcXVlc3RcIiwgcmVxdWVzdCwgaW5kZXg6IGksIHVybHMgfSk7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJ1bmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgcmVzb3VyY2UuLi5cbiAgICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5sb3ctbGV2ZWwgZmV0Y2ggZXJyb3IgKG1pc3NpbmcgaG9zdCwgYmFkIFNTTCwgZXRjLiksXG4gICAgICAgICAgICAgICAgLy8gc28gdHJ5IG5leHQgVVJMXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0OiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3AuYm9keUpzb247XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoUmVzdWx0XCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgYXNzZXJ0KHJlc3Auc3RhdHVzQ29kZSA8IDQwMCB8fCByZXNwLnN0YXR1c0NvZGUgPj0gNTAwLCBgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHsgcmVhc29uOiBcIjQwNF9NSVNTSU5HX1JFU09VUkNFXCIsIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmwsIGVycm9yTWVzc2FnZSB9IH0pO1xuICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIjUwMF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmxzLCBlcnJvck1lc3NhZ2VzIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBibG9jayBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIF93cmFwQmxvY2sodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayhmb3JtYXRCbG9jayh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgbG9nIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0xvZ11dLlxuICAgICAqL1xuICAgIF93cmFwTG9nKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nKGZvcm1hdExvZyh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVjZWlwdCBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVjZWlwdChmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlc3BvbnNlIGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBOZXR3b3JrLCBmb3JjaW5nIGEgbmV0d29yayBkZXRlY3Rpb24gdXNpbmcgd2hhdGV2ZXJcbiAgICAgKiAgdGVjaG5pcXVlIHRoZSBzdWItY2xhc3MgcmVxdWlyZXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBzaG91bGQgdXNlIHRoaXMgdG8gcGVyZm9ybSBhbGwgYnVpbHQtaW4gb3BlcmF0aW9ucy4gQWxsXG4gICAgICogIG1ldGhvZHMgc2FuaXRpemVzIGFuZCBub3JtYWxpemVzIHRoZSB2YWx1ZXMgcGFzc2VkIGludG8gdGhpcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCBtZXRob2Q6ICR7cmVxLm1ldGhvZH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBpbmZvOiByZXFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXRlXG4gICAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0QmxvY2tOdW1iZXJcIiB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUsIHJlc29sdmluZyBFTlNcbiAgICAgKiAgbmFtZXMgYW5kIFtbQWRkcmVzc2FibGVdXSBvYmplY3RzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhblxuICAgICAqICBhZGRyZXNzLlxuICAgICAqL1xuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKGFkZHJlc3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHZhbGlkIGJsb2NrIHRhZyBmb3IgJSVibG9ja1RhZyUlLCByZXNvbHZpbmdcbiAgICAgKiAgbmVnYXRpdmUgdmFsdWVzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkIGJsb2NrIHRhZy5cbiAgICAgKi9cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZykpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSBnZXROdW1iZXIoYmxvY2tUYWcsIFwiYmxvY2tUYWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KHRoaXMuI2xhc3RCbG9ja051bWJlciArIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYikgPT4gdG9RdWFudGl0eShiICsgYmxvY2tUYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIGZpbHRlciBmb3IgJSVmaWx0ZXIlJSwgcmVzb2x2aW5nIGFueSBFTlNcbiAgICAgKiAgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIG9iamVjdCBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICBmaWx0ZXIuXG4gICAgICovXG4gICAgX2dldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b3BpY3NcbiAgICAgICAgY29uc3QgdG9waWNzID0gKGZpbHRlci50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoXCJibG9ja0hhc2hcIiBpbiBmaWx0ZXIpID8gZmlsdGVyLmJsb2NrSGFzaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChfYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN3aXRjaCAoX2FkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX2FkZHJlc3Muc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CbG9jayAhPSBudWxsIHx8IHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbHRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBmcm9tQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gdG9CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkcmVzc2VzIGNvdWxkIGJlIGFzeW5jIChFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzKVxuICAgICAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhhZGRyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbUJsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJmcm9tQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci5mcm9tQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0Jsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJ0b0Jsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzLmZpbHRlcigoYSkgPT4gKHR5cGVvZiAoYSkgIT09IFwic3RyaW5nXCIpKS5sZW5ndGggfHxcbiAgICAgICAgICAgIChmcm9tQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKGZyb21CbG9jaykgIT09IFwic3RyaW5nXCIpIHx8XG4gICAgICAgICAgICAodG9CbG9jayAhPSBudWxsICYmIHR5cGVvZiAodG9CbG9jaykgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1Byb21pc2UuYWxsKGFkZHJlc3MpLCBmcm9tQmxvY2ssIHRvQmxvY2tdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGFkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdHJhbnNhY3Rpb24gZm9yICUlcmVxdWVzdCUlLCByZXNvbHZpbmdcbiAgICAgKiAgYW55IEVOUyBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfcmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY29weVJlcXVlc3QoX3JlcXVlc3QpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBbXCJ0b1wiLCBcImZyb21cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gcmVzb2x2ZUFkZHJlc3MocmVxdWVzdFtrZXldLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYWRkcikpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3Rba2V5XSA9IGF3YWl0IGFkZHI7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXF1ZXN0LmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcocmVxdWVzdC5ibG9ja1RhZyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdC5ibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tUYWcgPSBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBuZXR3b3JrIHdhcyBzZXQgYW5kIHRoaXMgaXMgb3VyIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgY3VycmVudCBuZXR3b3JrIChzaGFyZWQgd2l0aCBhbGwgY2FsbHMpXG4gICAgICAgICAgICBjb25zdCBkZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNhbGxcIiwgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCBPZmZjaGFpbkxvb2t1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHJhbnNhY3Rpb24udG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBBcmdzLnNlbmRlci50b0xvd2VyQ2FzZSgpID09PSB0eFNlbmRlci50b0xvd2VyQ2FzZSgpLCBcIkNDSVAgUmVhZCBzZW5kZXIgbWlzbWF0Y2hcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0gYXdhaXQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjY2lwQXJncy5jYWxsZGF0YSwgY2NpcEFyZ3MudXJscyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbmNhdChbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChfdHgpIHtcbiAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tUYWcgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIC8vIFdyaXRlXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgaGFzaCwgbmV0d29yayB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcbiAgICAgICAgaWYgKHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcik7XG4gICAgfVxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAvLyBAVE9ETzogQWRkIEN1c3RvbUJsb2NrUGx1Z2luIGNoZWNrXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB0aGlzLl9nZXRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsIHx8IHJlc29sdmVyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBDb250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgX2NvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xufVxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuZnVuY3Rpb24gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxuICAgIH07XG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\n\n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from]) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    }\n    else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nclass AbstractSigner {\n    /**\n     *  The provider this signer is connected to.\n     */\n    provider;\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, { provider: (provider || null) });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await (this.provider).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        }\n        else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        }\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        }\n        else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        }\n        else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    }\n                    else {\n                        pop.type = 2;\n                    }\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    }\n                    else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                }\n                else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                }\n                else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            }\n            else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async populateAuthorization(_auth) {\n        const auth = Object.assign({}, _auth);\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n        // @TODO: Take chain ID into account when populating noce?\n        if (auth.nonce == null) {\n            auth.nonce = await this.getNonce();\n        }\n        return auth;\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", { operation: \"authorize\" });\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nclass VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    address;\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address, provider) {\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, { address });\n    }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\n//# sourceMappingURL=abstract-signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ0M7QUFDcUQ7QUFDL0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNLHVEQUF1RCxXQUFXO0FBQzVFO0FBQ0E7QUFDQSxjQUFjLHlEQUFXO0FBQ3pCO0FBQ0EsaUJBQWlCLGlFQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFjO0FBQzFCO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFTO0FBQ3JDLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxxQkFBcUIsa0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxvRkFBb0Ysd0JBQXdCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsU0FBUztBQUMxQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sa0NBQWtDLE9BQU8sOEJBQThCLFdBQVc7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5IG9yIEVJUC00ODQ0XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBfYXV0aCk7XG4gICAgICAgIC8vIEFkZCBhIGNoYWluIElEIGlmIG5vdCBleHBsaWNpdGx5IHNldCB0byAwXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aC5jaGFpbklkID0gKGF3YWl0IGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXROZXR3b3JrXCIpLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XG4gICAgICAgIGlmIChhdXRoLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGgubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBUcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogaW4gdjcgbW92ZSB0aGlzIHRvIGJlIGFic3RyYWN0XG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImF1dGhvcml6YXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIHNpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJhdXRob3JpemVcIiB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-signer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contract/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\n\n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nclass MulticoinProviderPlugin {\n    /**\n     *  The name.\n     */\n    name;\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { name });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nclass BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nclass EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider;\n    /**\n     *  The address of the resolver.\n     */\n    address;\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name;\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { provider, address, name });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                }\n                catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.dnsEncode)(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        }\n        catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            }\n            catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: { coinType, data }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar() {\n        const linkage = [{ type: \"name\", value: this.name }];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n                        const tokenId = comps[1];\n                        const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n                        }\n                        else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeHex)(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n                        // Get the token metadata\n                        let metadata = {};\n                        const response = await (new _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n                        try {\n                            metadata = response.bodyJson;\n                        }\n                        catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            }\n                            catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", value: imageUrl });\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        }\n        catch (error) { }\n        return { linkage, url: null };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        }\n        catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider, name) {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n//# sourceMappingURL=ens-resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lEO0FBQ0c7QUFDSjtBQUNPO0FBQzBGO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyx5QkFBeUI7QUFDMUQ7QUFDQSw2QkFBNkIsd0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRU5TIGlzIGEgc2VydmljZSB3aGljaCBhbGxvd3MgZWFzeS10by1yZW1lbWJlciBuYW1lcyB0byBtYXAgdG9cbiAqICBuZXR3b3JrIGFkZHJlc3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Vucy1yZXNvbHZlcjpFTlMgUmVzb2x2ZXIgIFthYm91dC1lbnMtcnNvbHZlcl1cbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b0JlSGV4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIHVzZSB0aGUgZmV0Y2gtZGF0YTppcGZzIGdhdGV3YXlcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG47XG47XG4vKipcbiAqICBBIHByb3ZpZGVyIHBsdWdpbiBzdXBlci1jbGFzcyBmb3IgcHJvY2Vzc2luZyBtdWx0aWNvaW4gYWRkcmVzcyB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvaXZkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUFkZHJlc3MoY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xuLyoqXG4gKiAgQSAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKiBwcm92aWRlcyBzZXJ2aWNlIGZvciBjb21tb25cbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcbiAqICBkZWNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCYXNpY011bHRpY29pblBsdWdpbklkKTtcbiAgICB9XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG4vKipcbiAqICBBIGNvbm5lY3RlZCBvYmplY3QgdG8gYSByZXNvbHZlZCBFTlMgbmFtZSByZXNvbHZlciwgd2hpY2ggY2FuIGJlXG4gKiAgdXNlZCB0byBxdWVyeSBhZGRpdGlvbmFsIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSByZXNvbHZlci5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSB0aGlzIHJlc29sdmVyIHdhcyByZXNvbHZlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLy8gRm9yIEVJUC0yNTQ0IG5hbWVzLCB0aGUgYW5jZXN0b3IgdGhhdCBwcm92aWRlZCB0aGUgcmVzb2x2ZXJcbiAgICAjc3VwcG9ydHMyNTQ0O1xuICAgICNyZXNvbHZlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVyID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmUoYnl0ZXMsIGJ5dGVzKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIsIHN0cmluZykgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGNvbnRlbnRoYXNoKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQgZnV0dXJlIGF0dGVtcHRzIHRyeSBhZ2Fpbi4uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdXBwb3J0czI1NDQ7XG4gICAgfVxuICAgIGFzeW5jICNmZXRjaChmdW5jTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVycyBpcyBhbHdheXMgdGhlIG5vZGVoYXNoXG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWVoYXNoKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGZ1bmNOYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGRuc0VuY29kZSh0aGlzLm5hbWUsIDI1NSksXG4gICAgICAgICAgICAgICAgaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBwYXJhbXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXNvbHZlcltmdW5jTmFtZV0oLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29pblBsdWdpbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucHJvdmlkZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29pblBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblBsdWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XG4gICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICBjb25zdCBzd2FybSA9IGRhdGEubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgIGlmIChzd2FybSAmJiBzd2FybVsxXS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYXZhdGFyIHVybCBvciBgYG51bGxgYCBpZiB0aGUgYXZhdGFyIGlzIGVpdGhlclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxuICAgICAqICBub3Qgb3duZWQgYnkgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWZ1bC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuX2dldEF2YXRhcigpO1xuICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZW4gcmVzb2x2aW5nIGFuIGF2YXRhciwgdGhlcmUgYXJlIG1hbnkgc3RlcHMgaW52b2x2ZWQsIHN1Y2hcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXG4gICAgICogIE5GVC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XG4gICAgICogIHdhcyB3b3JraW5nIGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdGhpcy5uYW1lIH1dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYXZhdGFyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJhdmF0YXJcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZ2V0SXBmc0xpbmsoYXZhdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IHVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwidG9rZW5VUkkodWludDI1NilcIiA6IFwidXJpKHVpbnQyNTYpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBgISR7c2NoZW1lfWNhaXBgLCB2YWx1ZTogKG1hdGNoWzJdIHx8IFwiXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGNvbXBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtNzIxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB0b2tlblVSSSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB1cmkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IGF3YWl0IGNvbnRyYWN0Lm93bmVyT2YodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYmFsYW5jZVwiLCB2YWx1ZTogXCIwXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgdmFsdWU6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBhd2FpdCBjb250cmFjdFtzZWxlY3Rvcl0odG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRvQmVIZXgodG9rZW5JZCwgMzIpLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG5ldyBGZXRjaFJlcXVlc3QobWV0YWRhdGFVcmwpKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGdldEVuc0FkZHJlc3MocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZW5zUGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBjb250cmFjdC5yZXNvbHZlcihuYW1laGFzaChuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKSxcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxuICAgICAqICBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoYXdhaXQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/ens-resolver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/format.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/format.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */\n\n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return (function (value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    });\n}\nfunction arrayOf(format, allowNull) {\n    return ((array) => {\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i) => format(i));\n    });\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return ((value) => {\n        const result = {};\n        for (const key in format) {\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]) {\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            }\n            catch (error) {\n                const message = (error instanceof Error) ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", { value });\n            }\n        }\n        return result;\n    });\n}\nfunction formatBoolean(value) {\n    switch (value) {\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n}, {\n    prevRandao: [\"mixHash\"]\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx) => {\n        if (typeof (tx) === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\"gasPrice\"],\n    hash: [\"transactionHash\"],\n    index: [\"transactionIndex\"],\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, undefined),\n        type: (value) => {\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        authorizationList: allowNull(arrayOf((v) => {\n            let sig;\n            if (v.signature) {\n                sig = v.signature;\n            }\n            else {\n                let yParity = v.yParity;\n                if (yParity === \"0x1b\") {\n                    yParity = 0;\n                }\n                else if (yParity === \"0x1c\") {\n                    yParity = 1;\n                }\n                sig = Object.assign({}, v, { yParity });\n            }\n            return {\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(v.address),\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.chainId),\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.nonce),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(sig)\n            };\n        }, false), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\"input\"],\n        gasLimit: [\"gas\"],\n        index: [\"transactionIndex\"]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value.signature);\n    }\n    else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */\n    // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n}\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ21FO0FBQ3BCO0FBQ1M7QUFDNkQ7QUFDckg7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU0sbUNBQW1DLEtBQUssR0FBRyxRQUFRLGtCQUFrQixPQUFPO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWMsMEJBQTBCLEVBQUUsc0JBQXNCO0FBQ3BFO0FBQ087QUFDUCxJQUFJLCtEQUFjLENBQUMsNERBQVc7QUFDOUI7QUFDQTtBQUNPO0FBQ1AsSUFBSSwrREFBYyxDQUFDLDREQUFXO0FBQzlCO0FBQ0E7QUFDTztBQUNQLFNBQVMsNERBQVc7QUFDcEI7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDQTtBQUNBLGFBQWEseURBQVU7QUFDdkI7QUFDQSxpQkFBaUIsc0RBQVM7QUFDMUI7QUFDQSxXQUFXLHNEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBUztBQUMvQixDQUFDO0FBQ0Q7QUFD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bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENyZWF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQsIGFsbG93TnVsbCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmIChhbGxvd051bGwgJiYgYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGkpID0+IGZvcm1hdChpKSk7XG4gICAgfSk7XG59XG4vLyBSZXF1aXJlcyBhbiBvYmplY3Qgd2hpY2ggbWF0Y2hlcyBhIGZsZWV0IG9mIG90aGVyIGZvcm1hdHRlcnNcbi8vIEFueSBGb3JtYXRGdW5jIG1heSByZXR1cm4gYHVuZGVmaW5lZGAgdG8gaGF2ZSB0aGUgdmFsdWUgb21pdHRlZFxuLy8gZnJvbSB0aGUgcmVzdWx0IG9iamVjdC4gQ2FsbHMgcHJlc2VydmUgYHRoaXNgLlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChmb3JtYXQsIGFsdE5hbWVzKSB7XG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbHRLZXkgb2YgYWx0TmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcbiAgICAgICAgICAgICAgICBpZiAobnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIHZhbHVlIGZvciB2YWx1ZS4ke2tleX0gKCR7bWVzc2FnZX0pYCwgXCJCQURfREFUQVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgYm9vbGVhbjsgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgMzIpLCBcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VWludDI1Nih2YWx1ZSkge1xuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh2YWx1ZSwgMzIpO1xufVxuY29uc3QgX2Zvcm1hdExvZyA9IG9iamVjdCh7XG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcmVtb3ZlZDogYWxsb3dOdWxsKGZvcm1hdEJvb2xlYW4sIGZhbHNlKSxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRCbG9jayA9IG9iamVjdCh7XG4gICAgaGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gpLFxuICAgIHBhcmVudEhhc2g6IGZvcm1hdEhhc2gsXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgbnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdGltZXN0YW1wOiBnZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBnZXRCaWdJbnQsXG4gICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgc3RhdGVSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgcmVjZWlwdHNSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIGV4Y2Vzc0Jsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIG1pbmVyOiBhbGxvd051bGwoZ2V0QWRkcmVzcyksXG4gICAgcHJldlJhbmRhbzogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxufSwge1xuICAgIHByZXZSYW5kYW86IFtcIm1peEhhc2hcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2Zvcm1hdEJsb2NrKHZhbHVlKTtcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBfZm9ybWF0UmVjZWlwdExvZyA9IG9iamVjdCh7XG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWNlaXB0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRSZWNlaXB0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgZnJvbTogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcm9vdDogYWxsb3dOdWxsKGhleGxpZnkpLFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgbG9nc0Jsb29tOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgbG9nczogYXJyYXlPZihmb3JtYXRSZWNlaXB0TG9nKSxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgYmxvYkdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBzdGF0dXM6IGFsbG93TnVsbChnZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChnZXROdW1iZXIsIDApXG59LCB7XG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IFtcImdhc1ByaWNlXCJdLFxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgaWYgKHZhbHVlLnRvICYmIGdldEJpZ0ludCh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICAvLyBTb21lIG5vZGVzIGRvIG5vdCByZXR1cm4gdGhpcywgdXN1YWxseSB0ZXN0IG5vZGVzIChsaWtlIEdhbmFjaGUpXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCB1bmRlZmluZWQpLFxuICAgICAgICB0eXBlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoYWNjZXNzTGlzdGlmeSwgbnVsbCksXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IGFsbG93TnVsbChhcnJheU9mKGZvcm1hdEhhc2gsIHRydWUpLCBudWxsKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGFsbG93TnVsbChhcnJheU9mKCh2KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2lnO1xuICAgICAgICAgICAgaWYgKHYuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2lnID0gdi5zaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeVBhcml0eSA9IHYueVBhcml0eTtcbiAgICAgICAgICAgICAgICBpZiAoeVBhcml0eSA9PT0gXCIweDFiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHlQYXJpdHkgPT09IFwiMHgxY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWcgPSBPYmplY3QuYXNzaWduKHt9LCB2LCB7IHlQYXJpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3Modi5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQodi5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KHYubm9uY2UpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oc2lnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgZmFsc2UpLCBudWxsKSxcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgICAgIGJsb2NrTnVtYmVyOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXG4gICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcykgbXVzdCBiZSBzZXRcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckJsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgICAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICB2YWx1ZTogZ2V0QmlnSW50LFxuICAgICAgICBub25jZTogZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIGNoYWluSWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpXG4gICAgfSwge1xuICAgICAgICBkYXRhOiBbXCJpbnB1dFwiXSxcbiAgICAgICAgZ2FzTGltaXQ6IFtcImdhc1wiXSxcbiAgICAgICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl1cbiAgICB9KSh2YWx1ZSk7XG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxuICAgIGlmIChyZXN1bHQudG8gPT0gbnVsbCAmJiByZXN1bHQuY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gZ2V0Q3JlYXRlQWRkcmVzcyhyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgZmVlIGRhdGFcbiAgICAvLyBBZGQgYW4gYWNjZXNzIGxpc3QgdG8gc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCh2YWx1ZS50eXBlID09PSAxIHx8IHZhbHVlLnR5cGUgPT09IDIpICYmIHZhbHVlLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBzaWduYXR1cmVcbiAgICBpZiAodmFsdWUuc2lnbmF0dXJlKSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiBnZXRCaWdJbnQocmVzdWx0LmJsb2NrSGFzaCkgPT09IEJOXzApIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/format.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/network.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/network.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */\n\n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/\nconst Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */\nclass Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name, chainId) {\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */\n    toJSON() {\n        return { name: this.name, chainId: String(this.chainId) };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */\n    get name() { return this.#name; }\n    set name(value) { this.#name = value; }\n    /**\n     *  The network chain ID.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\"); }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */\n    matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof (other) === \"string\") {\n            try {\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\n            }\n            catch (error) { }\n            return (this.name === other);\n        }\n        if (typeof (other) === \"number\" || typeof (other) === \"bigint\") {\n            try {\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\n            }\n            catch (error) { }\n            return false;\n        }\n        if (typeof (other) === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId));\n                }\n                catch (error) { }\n                return false;\n            }\n            if (other.name != null) {\n                return (this.name === other.name);\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */\n    getPlugins(basename) {\n        return (this.plugins.filter((p) => (p.name.split(\"#\")[0] === basename)));\n    }\n    /**\n     *  Create a copy of this Network.\n     */\n    clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin) => {\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */\n    computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || (new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for (let i = 2; i < tx.data.length; i += 2) {\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                }\n                else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for (const addr in accessList) {\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */\n    static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof (network) === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof (network) === \"string\" || typeof (network) === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof (network) === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof (network.clone) === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof (network) === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof (network.name) === \"string\" && typeof (network.chainId) === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network((network.name), (network.chainId));\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */\n    static register(nameOrChainId, networkFunc) {\n        if (typeof (nameOrChainId) === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while (comps[1].length < decimals) {\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(), fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\n            };\n            return feeData;\n        }\n        catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", { request, response, error });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function () {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin) => {\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name) => {\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, { ensNetwork: 1, altNames: [\"homestead\"] });\n    registerEth(\"ropsten\", 3, { ensNetwork: 3 });\n    registerEth(\"rinkeby\", 4, { ensNetwork: 4 });\n    registerEth(\"goerli\", 5, { ensNetwork: 5 });\n    registerEth(\"kovan\", 42, { ensNetwork: 42 });\n    registerEth(\"sepolia\", 11155111, { ensNetwork: 11155111 });\n    registerEth(\"holesky\", 17000, { ensNetwork: 17000 });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1,\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, { ensNetwork: 1 });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, { ensNetwork: 1 });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, { ensNetwork: 1 });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"linea-sepolia\", 59141, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, {});\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\"maticMumbai\", \"maticmum\"],\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, { ensNetwork: 1 });\n}\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7QUFDYztBQUN3QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUIsZ0JBQWdCLDBEQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwREFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGFBQWE7QUFD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ZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgcHJvcGVydGllcyByZXF1aXJlZCB0b1xuICogIGludGVyYWN0IHdpdGggYSBzcGVjaWZpYyBjaGFpbi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzOk5ldHdvcmtzICBbbmV0d29ya3NdXG4gKi9cbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luIH0gZnJvbSBcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCI7XG4vKiAqICogKlxuLy8gTmV0d29ya3Mgd2hpY2ggb3BlcmF0aW9uIGFnYWluc3QgYW4gTDIgY2FuIHVzZSB0aGlzIHBsdWdpbiB0b1xuLy8gc3BlY2lmeSBob3cgdG8gYWNjZXNzIEwxLCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIEVOUyxcbi8vIGZvciBleGFtcGxlLlxuZXhwb3J0IGNsYXNzIExheWVyT25lQ29ubmVjdGlvblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5IHByb3ZpZGVyITogUHJvdmlkZXI7XG4vLyBAVE9ETzogUmVuYW1lIHRvIENoYWluQWNjZXNzIGFuZCBhbGxvdyBmb3IgY29ubmVjdGluZyB0byBhbnkgY2hhaW5cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubGF5ZXItb25lLWNvbm5lY3Rpb25cIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXM8TGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luPih0aGlzLCB7IHByb3ZpZGVyIH0pO1xuICAgIH1cblxuICAgIGNsb25lKCk6IExheWVyT25lQ29ubmVjdGlvblBsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbn1cbiovXG5jb25zdCBOZXR3b3JrcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogcHJvdmlkZXMgYWNjZXNzIHRvIGEgY2hhaW4ncyBwcm9wZXJ0aWVzIGFuZCBhbGxvd3NcbiAqICBmb3IgcGx1Zy1pbnMgdG8gZXh0ZW5kIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQoY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgTmV0d29yay5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubmFtZSwgY2hhaW5JZDogU3RyaW5nKHRoaXMuY2hhaW5JZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNvbW1vbiBuYW1lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGNhbm9uaWNhbCBuYW1lLCBhcyBuZXR3b3JrcyBtaWdoIGhhdmUgbXVsdGlwbGVcbiAgICAgKiAgbmFtZXMuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLiNuYW1lOyB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHsgdGhpcy4jbmFtZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNoYWluIElELlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIG1hdGNoZXMgdGhpcyBuZXR3b3JrLiBBbnkgY2hhaW4gSURcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgZG9lcyBub3QgY3VycmVudGx5IGNoZWNrIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMsXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIG1hdGNoZXMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlci5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHBsdWdpbiwgaWYgYW55LCBtYXRjaGluZyAlJW5hbWUlJSBleGFjdGx5LiBQbHVnaW5zXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IChwLm5hbWUuc3BsaXQoXCIjXCIpWzBdID09PSBiYXNlbmFtZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBOZXR3b3JrKHRoaXMubmFtZSwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQSBHYXNDb3N0UGx1Z2luIGNhbiBiZSBhdHRhY2hlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICB2YWx1ZXMuXG4gICAgICovXG4gICAgY29tcHV0ZUludHJpbnNpY0dhcyh0eCkge1xuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XG4gICAgICAgIGlmICh0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhWmVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFOb256ZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmFibGUgd2l0aCBuZXR3b3JrLWxpa2UgYWJpbGl0aWVzXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gbmV0d29yay5jbG9uZSgpO1xuICAgICAgICAgICAgLy9pZiAodHlwZW9mKG5ldHdvcmsubmFtZSkgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldHdvcmtpc2hcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tID0gbmV3IE5ldHdvcmsoKG5ldHdvcmsubmFtZSksIChuZXR3b3JrLmNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgY29uZmxpY3RpbmcgbmV0d29yayBmb3IgJHtKU09OLnN0cmluZ2lmeShleGlzdGluZy5uYW1lKX1gLCBcIm5hbWVPckNoYWluSWRcIiwgbmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29ya3Muc2V0KG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKTtcbiAgICB9XG59XG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XG4vLyBGaXhlZE51bWJlciBhbmQgd2Ugd2FudCB0byBrZWVwIE5ldHdvcmtzIHRpbnkuIFRoZSB2YWx1ZXNcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXG5mdW5jdGlvbiBwYXJzZVVuaXRzKF92YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXG4gICAgd2hpbGUgKGNvbXBzWzFdLmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUb28gbWFueSBkZWNpbWFscyBhbmQgc29tZSBub24temVybyBlbmRpbmcsIHRha2UgdGhlIGNlaWxpbmdcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xuICAgICAgICBpZiAoIWNvbXBzWzFdLnN1YnN0cmluZyg5KS5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICBmcmFjKys7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHNbMV0gPSBmcmFjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XG59XG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xuICAgIHJldHVybiBuZXcgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbih1cmwsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCksIGZldGNoRmVlRGF0YSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3BvbnNlLmJvZHlKc29uLnN0YW5kYXJkO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4RmVlLCA5KSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7IGVuc05ldHdvcms6IDExMTU1MTExIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiaG9sZXNreVwiLCAxNzAwMCwgeyBlbnNOZXR3b3JrOiAxNzAwMCB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tc2Vwb2xpYVwiLCA0MjE2MTQsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2VcIiwgODQ1MywgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1nb2VybGlcIiwgODQ1MzEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5iXCIsIDU2LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJ0XCIsIDk3LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtZ29lcmxpXCIsIDU5MTQwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1tdW1iYWlcIiwgODAwMDEsIHtcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi10ZXN0bmV0LnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbVwiLCAxMCwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/network.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */\nclass NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    name;\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */\n    constructor(name) {\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */\n    clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */\nclass GasCostPlugin extends NetworkPlugin {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    effectiveBlock;\n    /**\n     *  The transactions base fee.\n     */\n    txBase;\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate;\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero;\n    /**\n     *  The fee per non-zero-byte in the data.\n     */\n    txDataNonzero;\n    /**\n     *  The fee per storage key in the [[link-eip-2930]] access list.\n     */\n    txAccessListStorageKey;\n    /**\n     *  The fee per address in the [[link-eip-2930]] access list.\n     */\n    txAccessListAddress;\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */\n    constructor(effectiveBlock, costs) {\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);\n        const props = { effectiveBlock };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (value) === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */\nclass EnsPlugin extends NetworkPlugin {\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    address;\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    targetNetwork;\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */\n    constructor(address, targetNetwork) {\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: (address || EnsAddress),\n            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */\nclass FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */\n    constructor(feeDataFunc) {\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */\n    async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */\n    get url() { return this.#url; }\n    /**\n     *  The callback to use when computing the FeeData.\n     */\n    get processFunc() { return this.#processFunc; }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */\n    constructor(url, processFunc) {\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() { return this; }\n}\n/*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/\n//# sourceMappingURL=plugins-network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQ1A7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFnQixTQUFTLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUUsd0JBQXdCO0FBQ3hCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWMsbURBQW1ELEtBQUs7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcbiAgICAgKiAgdW5pcXVlIG5hbWVzIHdpdGggYSBrbm93biBhdXRob3JpdHkgYXMgd2VsbCBhcyBoaWVyYXJjaGFsIGVudHJpZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxuICAgICAqXG4gICAgICogIFRoaXMgYWxsb3dzIGEgaGFyZGZvcmsgdG8gaGF2ZSB1cGRhdGVkIHZhbHVlcyBpbmNsdWRlZCBhcyB3ZWxsIGFzXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGVmZmVjdGl2ZUJsb2NrO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxuICAgICAqL1xuICAgIHR4QmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBmb3IgY3JlYXRpbmcgYSBuZXcgYWNjb3VudC5cbiAgICAgKi9cbiAgICB0eENyZWF0ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YVplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhTm9uemVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgc3RvcmFnZSBrZXkgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcbiAgICAgKiAgbGF0ZXN0IGJsb2NrIG9yIGFub3RoZXIgR2FzQ29zdFBsdWdpbiBzdXBlcmNlZGVzIHRoYXQgYmxvY2sgbnVtYmVyLFxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RpdmVCbG9jaywgY29zdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCBudWxsaXNoKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGxpc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipFbnNQbHVnaW4qKiBhbGxvd3MgYSBbW05ldHdvcmtdXSB0byBzcGVjaWZ5IHRoZSBFTlMgUmVnaXN0cnlcbiAqICBDb250cmFjdCBhZGRyZXNzIGFuZCB0aGUgdGFyZ2V0IG5ldHdvcmsgdG8gdXNlIHdoZW4gdXNpbmcgdGhhdFxuICogIGNvbnRyYWN0LlxuICpcbiAqICBWYXJpb3VzIHRlc3RuZXRzIGhhdmUgdGhlaXIgb3duIGluc3RhbmNlIG9mIHRoZSBjb250cmFjdCB0byB1c2UsIGJ1dFxuICogIGluIGdlbmVyYWwsIHRoZSBtYWlubmV0IGluc3RhbmNlIHN1cHBvcnRzIG11bHRpLWNoYWluIGFkZHJlc3NlcyBhbmRcbiAqICBzaG91bGQgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI2ZlZURhdGFGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGRhdGEgZnVuY3Rpb24gcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGdldCBmZWVEYXRhRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVlRGF0YUZ1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZWVEYXRhXCIpO1xuICAgICAgICB0aGlzLiNmZWVEYXRhRnVuYyA9IGZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGZlZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZlZURhdGEocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZlZURhdGFGdW5jKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVlRGF0YU5ldHdvcmtQbHVnaW4odGhpcy4jZmVlRGF0YUZ1bmMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbi8qXG5leHBvcnQgY2xhc3MgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgI2Jsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz47XG4gICAgcmVhZG9ubHkgI2Jsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT47XG5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+LCBibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+KSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5uZXR3b3JrLXBsdWdpbnMuY3VzdG9tLWJsb2NrXCIpO1xuICAgICAgICB0aGlzLiNibG9ja0Z1bmMgPSBibG9ja0Z1bmM7XG4gICAgICAgIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMgPSBibG9ja1dpdGhUeHNGdW5jO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NrKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pOiBQcm9taXNlPEJsb2NrPHN0cmluZz4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NraW9ucyhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPik6IFByb21pc2U8QmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbih0aGlzLiNibG9ja0Z1bmMsIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMpO1xuICAgIH1cbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/plugins-network.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: () => (/* binding */ BrowserProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nclass BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    #request;\n    #providerInfo;\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */\n    constructor(ethereum, network, _options) {\n        // Copy the options\n        const options = Object.assign({}, ((_options != null) ? _options : {}), { batchMaxCount: 1 });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        this.#providerInfo = null;\n        if (_options && _options.providerInfo) {\n            this.#providerInfo = _options.providerInfo;\n        }\n        this.#request = async (method, params) => {\n            const payload = { method, params };\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\n                return result;\n            }\n            catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\n                throw error;\n            }\n        };\n    }\n    get providerInfo() {\n        return this.#providerInfo;\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [{ id: payload.id, result }];\n        }\n        catch (e) {\n            return [{\n                    id: payload.id,\n                    error: { code: e.code, data: e.data, message: e.message }\n                }];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch (error.error.code || -1) {\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */\n    async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof (address) === \"number\") {\n            return (accounts.length > address);\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!(await this.hasSigner(address))) {\n            try {\n                await this.#request(\"eth_requestAccounts\", []);\n            }\n            catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, { id: payload.id, error });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */\n    static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window :\n            (typeof (window) !== \"undefined\") ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context\n            && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await (new Promise((resolve, reject) => {\n            let found = [];\n            const addProvider = (event) => {\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = () => {\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map(i => Object.assign({}, (i.info))));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        }\n                        else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        }\n                        else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter(f => (filtered.uuid === f.info.uuid));\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            }\n                            else {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    }\n                    else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                }\n                else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(() => { finalize(); }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        }));\n    }\n}\n//# sourceMappingURL=provider-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThEO0FBQ0k7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLDJFQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFDQUFxQyxLQUFLLGtCQUFrQjtBQUNwRyxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHVDQUF1QywwREFBUztBQUNoRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbjtcbi8qKlxuICogIEEgKipCcm93c2VyUHJvdmlkZXIqKiBpcyBpbnRlbmRlZCB0byB3cmFwIGFuIGluamVjdGVkIHByb3ZpZGVyIHdoaWNoXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXG4gKiAgY3VycmVudGx5IGRvLlxuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI3JlcXVlc3Q7XG4gICAgI3Byb3ZpZGVySW5mbztcbiAgICAvKipcbiAgICAgKiAgQ29ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrLCBfb3B0aW9ucykge1xuICAgICAgICAvLyBDb3B5IHRoZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAoKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSksIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVxdWVzdCwgXCJpbnZhbGlkIEVJUC0xMTkzIHByb3ZpZGVyXCIsIFwiZXRoZXJldW1cIiwgZXRoZXJldW0pO1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gbnVsbDtcbiAgICAgICAgaWYgKF9vcHRpb25zICYmIF9vcHRpb25zLnByb3ZpZGVySW5mbykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gX29wdGlvbnMucHJvdmlkZXJJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSBhc3luYyAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kRWlwMTE5M1JlcXVlc3RcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgZXJyb3IucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVySW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb3ZpZGVySW5mbztcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiRUlQLTExOTMgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCByZXF1ZXN0XCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3JlcXVlc3QocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zIHx8IFtdKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBpZDogcGF5bG9hZC5pZCwgcmVzdWx0IH1dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IGUuY29kZSwgZGF0YTogZS5kYXRhLCBtZXNzYWdlOiBlLm1lc3NhZ2UgfVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XG4gICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAvLyBFSVAtMTE5MyBnaXZlcyB1cyBzb21lIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZXMsIHNvIHJld3JpdGVcbiAgICAgICAgLy8gdGhlbSBpbnRvIEV0aGVycyBzdGFuZGFyZCBlcnJvcnMuXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEaXNjb3ZlciBhbmQgY29ubmVjdCB0byBhIFByb3ZpZGVyIGluIHRoZSBCcm93c2VyIHVzaW5nIHRoZVxuICAgICAqICBbW2xpbmstZWlwLTY5NjNdXSBkaXNjb3ZlcnkgbWVjaGFuaXNtLiBJZiBubyBwcm92aWRlcnMgYXJlXG4gICAgICogIHByZXNlbnQsIGBgbnVsbGBgIGlzIHJlc29sdmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkaXNjb3ZlcihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIob3B0aW9ucy5wcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMud2luZG93ID8gb3B0aW9ucy53aW5kb3cgOlxuICAgICAgICAgICAgKHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIikgPyB3aW5kb3cgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnlQcm92aWRlciA9IG9wdGlvbnMuYW55UHJvdmlkZXI7XG4gICAgICAgIGlmIChhbnlQcm92aWRlciAmJiBjb250ZXh0LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJQcm92aWRlcihjb250ZXh0LmV0aGVyZXVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0ICYmIFwiZGlzcGF0Y2hFdmVudFwiIGluIGNvbnRleHRcbiAgICAgICAgICAgICYmIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8gb3B0aW9ucy50aW1lb3V0IDogMzAwO1xuICAgICAgICBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZFByb3ZpZGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgICAgIGlmIChhbnlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZmlsdGVyaW5nIGlzIHByb3ZpZGVkOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBmaWx0ZXIsIHdpdGggYSBjb3BpZXMgb2YgZm91bmQgcHJvdmlkZXIgaW5mb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gb3B0aW9ucy5maWx0ZXIoZm91bmQubWFwKGkgPT4gT2JqZWN0LmFzc2lnbih7fSwgKGkuaW5mbykpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb3ZpZGVyIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgQnJvd3NlclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHByb3ZpZGVyIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQudXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm91bmQuZmlsdGVyKGYgPT4gKGZpbHRlcmVkLnV1aWQgPT09IGYuaW5mby51dWlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXaGF0IHNob3VsZCBoYXBwZW4gaWYgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICBmb3IgdGhlIHNhbWUgVVVJRD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJyb3dzZXJQcm92aWRlcihwcm92aWRlciwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckluZm86IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcImZpbHRlciByZXR1cm5lZCB1bmtub3duIGluZm9cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSBmaXJzdCBmb3VuZCBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gZm91bmRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVySW5mbzogaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBhZGRQcm92aWRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgZmluYWxpemUoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./network.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof (value.getAddress) === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return (value.map(deepCopy));\n    }\n    if (typeof (value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return (value && typeof (value.pollingInterval) === \"number\");\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: (1 << 20),\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    address;\n    constructor(provider, address) {\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { address });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        }\n        else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [1000, 100];\n            let invalids = 0;\n            const checkTx = async () => {\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                }\n                catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") ||\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", { error }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        }\n        else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n    }\n    async signMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message), this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nclass JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while (payloads.length) {\n                // Create payload batches that satisfy our batch constraints\n                const batch = [(payloads.shift())];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push((payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift((batch.pop()));\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    }\n                    catch (error) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options) {\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof (staticNetwork) === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from(network);\n            }\n        }\n        else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            }\n            else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async () => {\n                try {\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                }\n                catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async () => {\n            const payload = {\n                id: this.#nextId++, method: \"eth_chainId\", params: [], jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            }\n            catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                throw error;\n            }\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async () => {\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                }\n                catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready() { return this.#notReady == null; }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_13__.accessListify)(tx.accessList);\n        }\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map(h => h.toLowerCase());\n        }\n        if (tx.authorizationList) {\n            result[\"authorizationList\"] = tx.authorizationList.map((_a) => {\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_14__.authorizationify)(_a);\n                return {\n                    address: a.address,\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.nonce),\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.chainId),\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.yParity),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.r),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.s),\n                };\n            });\n        }\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [] };\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [] };\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n            case \"getPriorityFee\":\n                return { method: \"eth_maxPriorityFeePerGas\", args: [] };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [req.signedTransaction]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [req.blockTag, !!req.includeTransactions]\n                    };\n                }\n                else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [req.blockHash, !!req.includeTransactions]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [req.hash]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [req.hash]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\n                };\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [this.getRpcTransaction(req.transaction)]\n                };\n            }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    }\n                    else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [req.filter] };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n            else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_15__.AbiCoder.getBuiltinCallException((method === \"eth_call\") ? \"call\" : \"estimateGas\", (payload.params[0]), (result ? result.data : null));\n            e.info = { error, payload };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof (error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\"),\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = (payload.params[0]);\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error, payload }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof (address) === \"number\") {\n            const accounts = (await accountsPromise);\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts) {\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nclass JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options) {\n        super(network, options);\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) {\n            pollingInterval = defaultOptions.pollingInterval;\n        }\n        this.#pollingInterval = pollingInterval;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval() { return this.#pollingInterval; }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nclass JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options) {\n        if (url == null) {\n            url = \"http:/\\/localhost:8545\";\n        }\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.FetchRequest(url);\n        }\n        else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [resp];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        }\n        catch (error) { }\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n}\n//# sourceMappingURL=provider-jsonrpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNzQjtBQUNiO0FBQ3NCO0FBQ2tIO0FBQzdHO0FBQ3pCO0FBQ2Y7QUFDdUQ7QUFDN0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsMENBQTBDLE9BQU8sR0FBRyxlQUFlO0FBQ25FO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsK0RBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUFVO0FBQzVCLFFBQVEsaUVBQWdCLFNBQVMsU0FBUztBQUMxQztBQUNBO0FBQ0EsUUFBUSx1REFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQWM7QUFDakQsZ0JBQWdCLCtEQUFjO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FB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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDREQUFXO0FBQzVGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1qc29ucnBjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIE9uZSBvZiB0aGUgbW9zdCBjb21tb24gd2F5cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBibG9ja2NoYWluIGlzXG4gKiAgYnkgYSBub2RlIHJ1bm5pbmcgYSBKU09OLVJQQyBpbnRlcmZhY2Ugd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB0byxcbiAqICBiYXNlZCBvbiB0aGUgdHJhbnNwb3J0LCB1c2luZzpcbiAqXG4gKiAgLSBIVFRQIG9yIEhUVFBTIC0gW1tKc29uUnBjUHJvdmlkZXJdXVxuICogIC0gV2ViU29ja2V0IC0gW1tXZWJTb2NrZXRQcm92aWRlcl1dXG4gKiAgLSBJUEMgLSBbW0lwY1NvY2tldFByb3ZpZGVyXV1cbiAqXG4gKiBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvanNvbnJwYzpKU09OLVJQQyBQcm92aWRlciAgW2Fib3V0LWpzb25ycGNQcm92aWRlcl1cbiAqL1xuLy8gQFRPRE86XG4vLyAtIEFkZCB0aGUgYmF0Y2hpbmcgQVBJXG4vLyBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLz9zY2hlbWFVcmw9aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V0aGVyZXVtL2V0aDEuMC1hcGlzL2Fzc2VtYmxlZC1zcGVjL29wZW5ycGMuanNvbiZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOnNwbGl0VmlldyU1RD10cnVlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6aW5wdXQlNUQ9ZmFsc2UmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpleGFtcGxlc0Ryb3Bkb3duJTVEPWZhbHNlXG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBoZXhsaWZ5LCBpc0hleFN0cmluZywgdG9RdWFudGl0eSwgdG9VdGY4Qnl0ZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RQcm92aWRlciwgVW5tYW5hZ2VkU3Vic2NyaWJlciB9IGZyb20gXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFNpZ25lciB9IGZyb20gXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyLCBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1maWx0ZXJpZC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuY29uc3QgUHJpbWl0aXZlID0gXCJiaWdpbnQsYm9vbGVhbixmdW5jdGlvbixudW1iZXIsc3RyaW5nLHN5bWJvbFwiLnNwbGl0KC8sL2cpO1xuLy9jb25zdCBNZXRob2RzID0gXCJnZXRBZGRyZXNzLHRoZW5cIi5zcGxpdCgvLC9nKTtcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgUHJpbWl0aXZlLmluZGV4T2YodHlwZW9mICh2YWx1ZSkpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBLZWVwIGFueSBBZGRyZXNzYWJsZVxuICAgIGlmICh0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5tYXAoZGVlcENvcHkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNob3VsZCBub3QgaGFwcGVuOiAke3ZhbHVlfSAoJHt0eXBlb2YgKHZhbHVlKX0pYCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzUG9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucG9sbGluZ0ludGVydmFsKSA9PT0gXCJudW1iZXJcIik7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwb2xsaW5nOiBmYWxzZSxcbiAgICBzdGF0aWNOZXR3b3JrOiBudWxsLFxuICAgIGJhdGNoU3RhbGxUaW1lOiAxMCxcbiAgICBiYXRjaE1heFNpemU6ICgxIDw8IDIwKSxcbiAgICBiYXRjaE1heENvdW50OiAxMDAsXG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLy8gQFRPRE86IFVuY2hlY2tlZCBTaWduZXJzXG5leHBvcnQgY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICBhZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgcmVjb25uZWN0IEpzb25ScGNTaWduZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5jb25uZWN0XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gICAgfVxuICAgIC8vIEpTT04tUlBDIHdpbGwgYXV0b21hdGlhbGx5IGZpbGwgaW4gbm9uY2UsIGV0Yy4gc28gd2UganVzdCBjaGVjayBmcm9tXG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGp1c3QgdGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIHNlbnQsIHdoaWNoIGlzIHdoYXRcbiAgICAvLyB0aGUgYmFyZSBKU09OLVJQQyBBUEkgZG9lcztcbiAgICBhc3luYyBzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgX2Zyb20gPSB0eC5mcm9tO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh7IC4uLnR4LCBmcm9tOiB0aGlzLmFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYWRkcmVzcyBtYXkgYmUgYW4gRU5TIG5hbWUgb3IgQWRkcmVzc2FibGVcbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IF90byA9IHR4LnRvO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHR4LnRvID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX3RvLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG9mIG91ciBwcm9wZXJ0aWVzIGFyZSBmaWxsZWQgaW5cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgbWluZWQgYW55IGVhcmxpZXIgdGhhbiBhbnkgcmVjZW50IGJsb2NrXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuICAgICAgICByZXR1cm4gYXdhaXQgKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRzID0gWzEwMDAsIDEwMF07XG4gICAgICAgICAgICBsZXQgaW52YWxpZHMgPSAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgY2FuY2VsbGVkOiBzdG9wIHBvbGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIGJhZDogdGhlIG5vZGUgcmV0dXJucyBiYWQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGNoYW5nZWQ6IGNhbGxpbmcgYWdhaW4gd2lsbCBhbHNvIGZhaWxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdW5zdXBwb3J0ZWQ6IGxpa2VseSBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FOQ0VMTEVEXCIpIHx8IGlzRXJyb3IoZXJyb3IsIFwiQkFEX0RBVEFcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXJyb3IoZXJyb3IsIFwiTkVUV09SS19FUlJPUlwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AtZ2FwIGZvciBtaXNiZWhhdmluZyBiYWNrZW5kczsgc2VlICM0NTEzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mby5zZW5kVHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkcyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFueW9uZSB0aGF0IGNhcmVzOyBidXQgd2Ugd2lsbCB0cnkgYWdhaW4sIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGxpa2VseSBhbiBpbnRlcm1pdHRlbnQgc2VydmljZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gZmV0Y2ggdHJhbnNhdGlvbiBhZnRlciBzZW5kaW5nICh3aWxsIHRyeSBhZ2FpbilcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGFub3RoZXIgNCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fc2V0VGltZW91dCgoKSA9PiB7IGNoZWNrVHgoKTsgfSwgdGltZW91dHMucG9wKCkgfHwgNDAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tUeCgpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFtcbiAgICAgICAgICAgIGhleGxpZnkobWVzc2FnZSksIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDb3B5KF92YWx1ZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBUeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcyAhPSBudWxsLCBcIlR5cGVkRGF0YSBkb2VzIG5vdCBzdXBwb3J0IG51bGwgYWRkcmVzc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgIGFzeW5jIF9sZWdhY3lTaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgaGV4bGlmeShtZXNzYWdlKVxuICAgICAgICBdKTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY0FwaVByb3ZpZGVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIGFuZCAqKk1VU1QqKiBiZVxuICogIHN1Yi1jbGFzc2VkLlxuICpcbiAqICBJdCBwcm92aWRlcyB0aGUgYmFzZSBmb3IgYWxsIEpTT04tUlBDLWJhc2VkIFByb3ZpZGVyIGludGVyYWN0aW9uLlxuICpcbiAqICBTdWItY2xhc3NpbmcgTm90ZXM6XG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIF9zZW5kXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUHJvdmlkZXIgZXh0ZW5kcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjb3B0aW9ucztcbiAgICAvLyBUaGUgbmV4dCBJRCB0byB1c2UgZm9yIHRoZSBKU09OLVJQQyBJRCBmaWVsZFxuICAgICNuZXh0SWQ7XG4gICAgLy8gUGF5bG9hZHMgYXJlIHF1ZXVlZCBhbmQgdHJpZ2dlcmVkIGluIGJhdGNoZXMgdXNpbmcgdGhlIGRyYWluVGltZXJcbiAgICAjcGF5bG9hZHM7XG4gICAgI2RyYWluVGltZXI7XG4gICAgI25vdFJlYWR5O1xuICAgICNuZXR3b3JrO1xuICAgICNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAjc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgYmF0Y2hpbmcsIG5vIGhhcm0gaW4gc2VuZGluZyBpdCBpbW1lZGlhdGVseVxuICAgICAgICBjb25zdCBzdGFsbFRpbWUgPSAodGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hNYXhDb3VudFwiKSA9PT0gMSkgPyAwIDogdGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hTdGFsbFRpbWVcIik7XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0aGlzLiNwYXlsb2FkcztcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBheWxvYWQgYmF0Y2hlcyB0aGF0IHNhdGlzZnkgb3VyIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBbKHBheWxvYWRzLnNoaWZ0KCkpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPT09IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gucHVzaCgocGF5bG9hZHMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEpTT04uc3RyaW5naWZ5KGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLiNvcHRpb25zLmJhdGNoTWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHMudW5zaGlmdCgoYmF0Y2gucG9wKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3VsdCB0byBlYWNoIHBheWxvYWRcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKChiYXRjaC5sZW5ndGggPT09IDEpID8gYmF0Y2hbMF0ucGF5bG9hZCA6IGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgaW4gYmF0Y2ggb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHZlLCByZWplY3QsIHBheWxvYWQgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3VsdC5maWx0ZXIoKHIpID0+IChyLmlkID09PSBwYXlsb2FkLmlkKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0OyB0aGUgbm9kZSBmYWlsZWQgdXMgaW4gdW5leHBlY3RlZCB3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1ha2VFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2UgZm9yIHJlcXVlc3RcIiwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LCBpbmZvOiB7IHBheWxvYWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBnb29kOyBzZW5kIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWplY3QgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBhdWdtZW50IHRoZSBlcnJvciB3aXRoIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWxsVGltZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI25leHRJZCA9IDE7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNub3RSZWFkeSA9IHsgcHJvbWlzZSwgcmVzb2x2ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRpY05ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAodHlwZW9mIChzdGF0aWNOZXR3b3JrKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFzdGF0aWNOZXR3b3JrIHx8IG5ldHdvcmsgIT09IFwiYW55XCIsIFwic3RhdGljTmV0d29yayBjYW5ub3QgYmUgdXNlZCBvbiBzcGVjaWFsIG5ldHdvcmsgJ2FueSdcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0YXRpY05ldHdvcmsgJiYgbmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IE5ldHdvcmsuZnJvbShuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0aWNOZXR3b3JrKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHN0YXRpYyBuZXR3b3JrIGlzIGNvbXBhdGJpbGUgd2l0aCB0aGUgcHJvdmlkZWQgbmV0d3Jva1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobmV0d29yayA9PSBudWxsIHx8IHN0YXRpY05ldHdvcmsubWF0Y2hlcyhuZXR3b3JrKSwgXCJzdGF0aWNOZXR3b3JrIE1VU1QgbWF0Y2ggbmV0d29yayBvYmplY3RcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IHN0YXRpY05ldHdvcms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3B0aW9uICUla2V5JSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgY2FuIHVzZSB0aGlzIHRvIGlucXVpcmUgYWJvdXQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIF9nZXRPcHRpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIHRoZSBbW05ldHdvcmtdXSB0aGlzIHByb3ZpZGVyIGhhcyBjb21taXR0ZWQgdG8uIE9uIGVhY2ggY2FsbCwgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMgZGV0ZWN0ZWQsIGFuZCBpZiBpdCBoYXMgY2hhbmdlZCwgdGhlIGNhbGwgd2lsbCByZWplY3QuXG4gICAgICovXG4gICAgZ2V0IF9uZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jbmV0d29yaywgXCJuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUgeWV0XCIsIFwiTkVUV09SS19FUlJPUlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbm9uLW5vcm1hbGl6ZWQgdmFsdWUgYnkgcGVyZm9ybWluZyAlJXJlcSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSBiZWhhdmlvciBvZiBhY3Rpb25zLFxuICAgICAqICBhbmQgc2hvdWxkIGdlbmVyYWxseSBjYWxsIGBgc3VwZXIuX3BlcmZvcm1gYCBhcyBhIGZhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICAvLyBMZWdhY3kgbmV0d29ya3MgZG8gbm90IGxpa2UgdGhlIHR5cGUgZmllbGQgYmVpbmcgcGFzc2VkIGFsb25nICh3aGljaFxuICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgcmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBsZXQgdHggPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIGdldEJpZ0ludCh0eC50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBvciBuZXdlciBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBwcmUtRUlQLTE1NTlcbiAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IHR5cGU6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UnBjUmVxdWVzdChyZXEpO1xuICAgICAgICBpZiAocmVxdWVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXM7IGl0IGRldGVjdHMgdGhlICphY3R1YWwqIG5ldHdvcmsgdGhhdFxuICAgICAqICB3ZSBhcmUgKipjdXJyZW50bHkqKiBjb25uZWN0ZWQgdG8uXG4gICAgICpcbiAgICAgKiAgS2VlcCBpbiBtaW5kIHRoYXQgW1tzZW5kXV0gbWF5IG9ubHkgYmUgdXNlZCBvbmNlIFtbcmVhZHldXSwgb3RoZXJ3aXNlIHRoZVxuICAgICAqICBfc2VuZCBwcmltaXRpdmUgbXVzdCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAobmV0d29yaykge1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVhZHksIHVzZSBgYHNlbmRgYCwgd2hpY2ggZW5hYmxlZCByZXF1ZXN0cyB0byBiZSBiYXRjaGVkXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBub3QgcmVhZHkgeWV0OyB1c2UgdGhlIHByaW1pdGl2ZSBfc2VuZFxuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLiNuZXh0SWQrKywgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIHBhcmFtczogW10sIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCkpWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIGlmIChcInJlc3VsdFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKipNVVNUKiogY2FsbCB0aGlzLiBVbnRpbCBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2FsbHNcbiAgICAgKiAgd2lsbCBiZSBwYXNzZWQgdG8gW1tfc2VuZF1dIGZyb20gW1tzZW5kXV0uIElmIGl0IGlzIG92ZXJyaWRkZW4sIHRoZW5cbiAgICAgKiAgYGBzdXBlci5fc3RhcnQoKWBgICoqTVVTVCoqIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICBDYWxsaW5nIGl0IG11bHRpcGxlIHRpbWVzIGlzIHNhZmUgYW5kIGhhcyBubyBlZmZlY3QuXG4gICAgICovXG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCB8fCB0aGlzLiNub3RSZWFkeS5yZXNvbHZlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNub3RSZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuI25vdFJlYWR5ID0gbnVsbDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgbmV0d29ya1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkpzb25ScGNQcm92aWRlciBmYWlsZWQgdG8gZGV0ZWN0IG5ldHdvcmsgYW5kIGNhbm5vdCBzdGFydCB1cDsgcmV0cnkgaW4gMXMgKHBlcmhhcHMgdGhlIFVSTCBpcyB3cm9uZyBvciB0aGUgbm9kZSBpcyBub3Qgc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcImZhaWxlZCB0byBib290c3RyYXAgbmV0d29yayBkZXRlY3Rpb25cIiwgXCJORVRXT1JLX0VSUk9SXCIsIHsgZXZlbnQ6IFwiaW5pdGlhbC1uZXR3b3JrLWRpc2NvdmVyeVwiLCBpbmZvOiB7IGVycm9yIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBkaXNwYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuIFRoaXMgY2FuIGJlIHVzZWQgaW5cbiAgICAgKiAgc3ViLWNsYXNzZXMgdG8gZGVmZXIgc2VuZGluZyBkYXRhIHVudGlsIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0VW50aWxSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbm90UmVhZHkucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFN1YnNjcmliZXIgdGhhdCB3aWxsIG1hbmFnZSB0aGUgJSVzdWIlJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mXG4gICAgICogIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICAvLyBQZW5kaW5nIEZpbHRlcnMgYXJlbid0IGF2YWlsYmxlIHZpYSBwb2xsaW5nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ycGhhbmVkIExvZ3MgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSwgYnkgdGhlIGZpbHRlciwgc2luY2VcbiAgICAgICAgLy8gbG9ncyB3aXRoIHJlbW92ZWQgYXJlIGVtaXR0ZWQgYnkgaXRcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcIm9ycGhhblwiICYmIHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihcIm9ycGhhblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0eCUlIGFzIGEgbm9ybWFsaXplZCBKU09OLVJQQyB0cmFuc2FjdGlvbiByZXF1ZXN0LFxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZHN0S2V5XSA9IHRvUXVhbnRpdHkoZ2V0QmlnSW50KHR4W2tleV0sIGB0eC4ke2tleX1gKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWRkcmVzc2VzIGFuZCBkYXRhIGFyZSBsb3dlcmNhc2VcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHhba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGFjY2VzcyBsaXN0IG9iamVjdFxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyA8YW55PiBjYXNlIG9uY2UgRUlQLTQ4NDQgYWRkZWQgdG8gcHJlcGFyZWQgdHhcbiAgICAgICAgICAgIHJlc3VsdFtcImJsb2JWZXJzaW9uZWRIYXNoZXNcIl0gPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLm1hcChoID0+IGgudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhdXRob3JpemF0aW9uTGlzdFwiXSA9IHR4LmF1dGhvcml6YXRpb25MaXN0Lm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gYXV0aG9yaXphdGlvbmlmeShfYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogdG9RdWFudGl0eShhLm5vbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdG9RdWFudGl0eShhLmNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5OiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgICAgICAgICByOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgICAgICAgICBzOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogYmxvYnMgc2hvdWxkIHByb2JhYmx5IGFsc28gYmUgY29waWVkIG92ZXIsIG9wdGlvbmFsbHlcbiAgICAgICAgLy8gYWNjb3VudGluZyBmb3IgdGhlIGt6ZyBwcm9wZXJ0eSB0byBiYWNrZmlsbCBibG9iVmVyc2lvbmVkSGFzaGVzXG4gICAgICAgIC8vIHVzaW5nIHRoZSBjb21taXRtZW50LiBPciBzaG91bGQgdGhhdCBiZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIHRvXG4gICAgICAgIC8vIHRoZSBjYWxsZXI/XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtc2cubWF0Y2goL25vbmNlL2kpICYmIG1zZy5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbigobWV0aG9kID09PSBcImV0aF9jYWxsXCIpID8gXCJjYWxsXCIgOiBcImVzdGltYXRlR2FzXCIsIChwYXlsb2FkLnBhcmFtc1swXSksIChyZXN1bHQgPyByZXN1bHQuZGF0YSA6IG51bGwpKTtcbiAgICAgICAgICAgIGUuaW5mbyA9IHsgZXJyb3IsIHBheWxvYWQgfTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgZXN0aW1hdGVHYXMgYW5kIGNhbGwgY2FuIHJldHVybiBhcmJpdHJhcnkgY29udHJhY3QtZGVmaW5lZCB0ZXh0LCBzbyBub3cgd2VcbiAgICAgICAgLy8gd2UgY2FuIHByb2Nlc3MgdGV4dCBzYWZlbHkuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShzcGVsdW5rTWVzc2FnZShlcnJvcikpO1xuICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZHxldGhlcnMtdXNlci1kZW5pZWQvaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk1hcCA9IHtcbiAgICAgICAgICAgICAgICBldGhfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIHBlcnNvbmFsX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDogXCJzaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjogXCJzaWduVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIHdhbGxldF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKGFjdGlvbk1hcFttZXRob2RdIHx8IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKHBheWxvYWQucGFyYW1zWzBdKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZS9pKSAmJiBtZXNzYWdlLm1hdGNoKC90b28gbG93L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24vaSkgJiYgbWVzc2FnZS5tYXRjaCgvdW5kZXJwcmljZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbWV0aG9kLCBpbmZvOiB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1bnN1cHBvcnRlZCA9ICEhbWVzc2FnZS5tYXRjaCgvdGhlIG1ldGhvZCAuKiBkb2VzIG5vdCBleGlzdC9pKTtcbiAgICAgICAgaWYgKCF1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmRldGFpbHMgJiYgZXJyb3IuZGV0YWlscy5zdGFydHNXaXRoKFwiVW5hdXRob3JpemVkIG1ldGhvZDpcIikpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kLCBpbmZvOiB7IGVycm9yLCBwYXlsb2FkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJjb3VsZCBub3QgY29hbGVzY2UgZXJyb3JcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXF1ZXN0cyB0aGUgJSVtZXRob2QlJSB3aXRoICUlcGFyYW1zJSUgdmlhIHRoZSBKU09OLVJQQyBwcm90b2NvbFxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXG4gICAgICogIEFQSS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xuICAgICAqICBpbiB0aGUgb3B0aW9ucywgYXNzaWducyB0aGUgcmVxdWVzdCBhIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXG4gICAgICogIG92ZXJyaWRlIFtbX3NlbmRdXSBvciBmb3JjZSB0aGUgb3B0aW9ucyB2YWx1ZXMgaW4gdGhlXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuI25leHRJZCsrO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgbWV0aG9kLCBwYXJhbXMsIGlkLCBqc29ucnBjOiBcIjIuMFwiIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgcGVuZGluZyBkcmFpblRpbWVyLCBzZXQgb25lXG4gICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgW1tTaWduZXJdXSBhY2NvdW50IGZvciAgJSVhZGRyZXNzJSUgbWFuYWdlZCBieVxuICAgICAqICB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWFkZHJlc3MlJSBpcyBhIG51bWJlciwgaXQgaXMgdXNlZCBhcyBhbiBpbmRleCBpbiB0aGVcbiAgICAgKiAgdGhlIGFjY291bnRzIGZyb20gW1tsaXN0QWNjb3VudHNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgb24gY2xpZW50cyB3aGljaCBtYW5hZ2UgYWNjb3VudHMgKHN1Y2ggYXNcbiAgICAgKiAgR2V0aCB3aXRoIGltcG9ydGVkIGFjY291bnQgb3IgTWV0YU1hc2spLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgYWNjb3VudCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzUHJvbWlzZSA9IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIC8vIEFjY291bnQgaW5kZXhcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IGFjY291bnRzUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA+PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIGFjY291bnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWNjb3VudHNbYWRkcmVzc10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzUHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWNjb3VudCBhZGRyZXNzXG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGFjY291bnQpID09PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudFwiKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEFjY291bnRzKCkge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKGEpID0+IG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGEpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZHJhaW5UaW1lcik7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgZm9yIChjb25zdCB7IHBheWxvYWQsIHJlamVjdCB9IG9mIHRoaXMuI3BheWxvYWRzKSB7XG4gICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIC8vIFBhcmVudCBjbGVhbi11cFxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gQFRPRE86IHJlbW92ZSB0aGlzIGluIHY3LCBpdCBpcyBub3QgZXhwb3J0ZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbi8vIGlzIGV4cG9zZWQgaW4gdGhlIEpzb25ScGNBcGlQcm92aWRlciBieSBzZXR0aW5nIHBvbGxpbmcgdG8gdHJ1ZS4gSXQgc2hvdWxkXG4vLyBiZSBzYWZlIHRvIHJlbW92ZSByZWdhcmRsZXNzLCBiZWNhdXNlIGl0IGlzbid0IHJlYWNoYWJsZSwgYnV0IGp1c3QgaW4gY2FzZS5cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI3BvbGxpbmdJbnRlcnZhbDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcG9sbGluZ0ludGVydmFsID0gdGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ0ludGVydmFsXCIpO1xuICAgICAgICBpZiAocG9sbGluZ0ludGVydmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IGRlZmF1bHRPcHRpb25zLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY1Byb3ZpZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb24gUHJvdmlkZXJzLFxuICogIHdoaWNoIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIG92ZXIgSFRUUCAob3IgSFRUUFMpIHJlcXVlc3RzLlxuICpcbiAqICBFdmVudHMgYXJlIHByb2Nlc3NlZCBieSBwb2xsaW5nIHRoZSBiYWNrZW5kIGZvciB0aGUgY3VycmVudCBibG9ja1xuICogIG51bWJlcjsgd2hlbiBpdCBhZHZhbmNlcywgYWxsIGJsb2NrLWJhc2UgZXZlbnRzIGFyZSB0aGVuIGNoZWNrZWRcbiAqICBmb3IgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBGZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XG4gICAgICAgIC8vIHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrIChpLmUuIGV0aF9jaGFpbklkKSB1bnRpbCB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8uXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwKSkge1xuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhOiB2YWx1ZS5kYXRhIH07XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVua0RhdGEoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWpzb25ycGMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nclass FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nfunction copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b) => {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nclass Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The hash tree root of the parent beacon block for the given\n     *  execution block. See [[link-eip-4788]].\n     */\n    parentBeaconBlockRoot;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The root hash for the global state after applying changes\n     *  in this block.\n     */\n    stateRoot;\n    /**\n     *  The hash of the transaction receipts trie.\n     */\n    receiptsRoot;\n    /**\n     *  The total amount of blob gas consumed by the transactions\n     *  within the block. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The running total of blob gas consumed in excess of the\n     *  target, prior to the block. See [[link-eip-4844]].\n     */\n    excessBlobGas;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  The latest RANDAO mix of the post beacon state of\n     *  the previous block.\n     */\n    prevRandao;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot,\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash, miner, prevRandao, nonce, number, parentHash, timestamp,\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nclass Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nclass TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was sent to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The gas used for BLObs. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\n     */\n    blobGasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nclass TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The [[link-eip-4844]] max fee per BLOb gas.\n     */\n    maxFeePerBlobGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    /**\n     *  The [[link-eip-4844]] BLOb versioned hashes.\n     */\n    blobVersionedHashes;\n    /**\n     *  The [[link-eip-7702]] authorizations (if any).\n     */\n    authorizationList;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\n        this.authorizationList = (tx.authorizationList != null) ? tx.authorizationList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList, blockNumber, blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (confirms === 1 || (await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsV0FBVyxpQkFBaUI7QUFDb0k7QUFDeEc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBUyxzQkFBc0IsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQVMsc0JBQXNCLElBQUk7QUFDekQ7QUFDQTtBQUNBLDRCQUE0QixvRUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQVc7QUFDM0IsdUJBQXVCLHdEQUFPO0FBQzlCO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUxBQXVMO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHdHQUF3RyxvQ0FBb0M7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0dBQStHO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsUUFBUSxrRUFBaUI7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQixRQUFRLGtFQUFpQjtBQUNsRTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTO0FBQ3BDLGlCQUFpQjtBQUNqQix3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQTJDO0FBQy9FO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsNEJBQTRCLHdEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhDQUE4QztBQUN0RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxxRkFBcUYsNEJBQTRCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxxRkFBcUYsNEJBQTRCO0FBQy9ILFFBQVEsdURBQU0sd0dBQXdHLDRCQUE0QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzQnl0ZXNMaWtlLCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cbi8vIEBUT0RPPyA8VCBleHRlbmRzIEZlZURhdGEgPSB7IH0+IGltcGxlbWVudHMgUmVxdWlyZWQ8VD5cbi8qKlxuICogIEEgKipGZWVEYXRhKiogd3JhcHMgYWxsIHRoZSBmZWUtcmVsYXRlZCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoXG4gKiAgdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZ2FzUHJpY2U6IGdldFZhbHVlKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJGZWVEYXRhXCIsXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xuICAgIGlmIChyZXEudG8pIHtcbiAgICAgICAgcmVzdWx0LnRvID0gcmVxLnRvO1xuICAgIH1cbiAgICBpZiAocmVxLmZyb20pIHtcbiAgICAgICAgcmVzdWx0LmZyb20gPSByZXEuZnJvbTtcbiAgICB9XG4gICAgaWYgKHJlcS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gaGV4bGlmeShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyQmxvYkdhcyxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJLZXlzID0gXCJ0eXBlLG5vbmNlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0TnVtYmVyKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChyZXEuYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGhvcml6YXRpb25MaXN0ID0gcmVxLmF1dGhvcml6YXRpb25MaXN0LnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzLnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQua3pnID0gcmVxLmt6ZztcbiAgICB9XG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9icyA9IHJlcS5ibG9icy5tYXAoKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgZXhlY3V0aW9uIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00Nzg4XV0uXG4gICAgICovXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xuICAgICAqICBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIHN0YXRlUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzIHRyaWUuXG4gICAgICovXG4gICAgcmVjZWlwdHNSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgd2l0aGluIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcnVubmluZyB0b3RhbCBvZiBibG9iIGdhcyBjb25zdW1lZCBpbiBleGNlc3Mgb2YgdGhlXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgZXhjZXNzQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXG4gICAgICogIHRoZSBwcmV2aW91cyBibG9jay5cbiAgICAgKi9cbiAgICBwcmV2UmFuZGFvO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiBibG9jay5ibG9iR2FzVXNlZCxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBnZXRWYWx1ZShibG9jay5wcmV2UmFuZGFvKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcyksXG4gICAgICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaGFzaGVzLCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgdGhleSB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbnMsIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogIHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBibG9ja3Mgd2hpY2ggcHJlZmV0Y2hlZFxuICAgICAqICB0cmFuc2FjdGlvbnMsIGJ5IHBhc3NpbmcgYGB0cnVlYGAgdG8gJSVwcmVmZXRjaFR4cyUlXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxuICAgICAqL1xuICAgIGdldCBwcmVmZXRjaGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIuLi5cbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlZmV0Y2hlZCB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJubyBtYXRjaGluZyB0cmFuc2FjdGlvblwiLCBcImluZGV4T3JIYXNoXCIsIGluZGV4T3JIYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGJlZW4gbWluZWQuIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGd1YXJkXG4gICAgICogIGZvciBhbGwgcHJvcGVydGllcyBvbiBhIFtbTWluZWRCbG9ja11dLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7IHJldHVybiAhIXRoaXMuaGFzaDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgb3JwaGFuZWRFdmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExvZ1xuLyoqXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXG4gKiAgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGBgTE9HKmBgIG9wY29kZXMsIHdoaWNoIGFyZSBtb3N0IGNvbW1vbmx5IHVzZWQgYnlcbiAqICBTb2xpZGl0eSdzIGVtaXQgZm9yIGFubm91bmNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljcyxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXgsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBsb2cudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBibG9jayB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXJlY2VpcHQsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb24gcmVjZWlwdFwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiB3YXMgc2VudCB0by5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgZGlyZWN0bHlcbiAgICAgKiAgcmVzcG9uc2libGUgZm9yIGRlcGxveWluZyBvbmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub24tbnVsbCAqKm9ubHkqKiBpZiB0aGUgYGB0b2BgIGlzIGVtcHR5IGFuZCB0aGUgYGBkYXRhYGBcbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCBhcyBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCBvZiB0aGlzIHRyYW5zYWN0aW9uIHdpdGhpbiB0aGUgYmxvY2sgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvb20gZmlsdGVyIGJ5dGVzIHRoYXQgcmVwcmVzZW50IGFsbCBsb2dzIHRoYXQgb2NjdXJyZWQgd2l0aGluXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIG1vc3QgZGV2ZWxvcGVycyxcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxuICAgICAqL1xuICAgIGxvZ3NCbG9vbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxuICAgICAqICBvbmx5IGJlIGFwcHJveGltYXRlZCwgYnV0IHRoZSBzZW5kZXIgbXVzdCBwYXkgdGhlIGdhcyBmZWUgZm9yIHRoZVxuICAgICAqICBlbnRpcmUgZ2FzIGxpbWl0LiBBZnRlciB0aGUgdHJhbnNhY3Rpb24sIHRoZSBkaWZmZXJlbmNlIGlzIHJlZnVuZGVkLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBnYXMgdXNlZCBieSBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgYmxvY2sgZm9yIHRoaXNcbiAgICAgKiAgYW5kIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBhIGxvd2VyIGBgaW5kZXhgYC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBkZXZlbG9wZXJzIGJ1dCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICB2YWxpZGF0ZSBjZXJ0YWluIGFzcGVjdHMgb2YgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGN1bXVsYXRpdmVHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIHRoZSBjb21wbGV4aXR5IG9mIFtbbGluay1laXAtMTU1OV1dIHRoaXMgdmFsdWUgY2FuIG9ubHlcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcbiAgICAgKiAgZmVlIGlzIHByb3RvY29sLWVuZm9yY2VkLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpY2UgcGFpZCBwZXIgQkxPQiBpbiBnYXMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gbWF4IGZlZSBwZXIgQkxPYiBnYXMuXG4gICAgICovXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcbiAgICAgKiAgYXMgZXRoZXIuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBjaGFpbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0IGZvciB0cmFuc2FjdGlvbiB0eXBlcyB0aGF0XG4gICAgICogIHN1cHBvcnQgaXQsIG90aGVyd2lzZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxuICAgICAqL1xuICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTc3MDJdXSBhdXRob3JpemF0aW9ucyAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBhdXRob3JpemF0aW9uTGlzdDtcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hdXRob3JpemF0aW9uTGlzdCA9ICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSA/IHR4LmF1dGhvcml6YXRpb25MaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMSB8fCAoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCByZS1vcmRlciB0aGlzIGV2ZW50IGFnYWluc3QgJSVvdGhlciUlLlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YXJ0QmxvY2spICYmIHN0YXJ0QmxvY2sgPj0gMCwgXCJpbnZhbGlkIHN0YXJ0QmxvY2tcIiwgXCJzdGFydEJsb2NrXCIsIHN0YXJ0QmxvY2spO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKGJsb2NrKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtYmxvY2tcIiwgaGFzaDogYmxvY2suaGFzaCwgbnVtYmVyOiBibG9jay5udW1iZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHR4LCBvdGhlcikge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJyZW9yZGVyLXRyYW5zYWN0aW9uXCIsIHR4LCBvdGhlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHR4KSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtdHJhbnNhY3Rpb25cIiwgdHggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIobG9nKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3M6IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKSxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcbiAgICAgICAgfSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            }\n            catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n            await this._emitResults(this.#provider, result);\n        }\n        catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                if (this.#provider.destroyed) {\n                    return;\n                }\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() { this.start(); }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n//# sourceMappingURL=subscriber-filterid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEVBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFNvbWUgYmFja2VuZHMgc3VwcG9ydCBzdWJzY3JpYmluZyB0byBldmVudHMgdXNpbmcgYSBGaWx0ZXIgSUQuXG4gKlxuICogIFdoZW4gc3Vic2NyaWJpbmcgd2l0aCB0aGlzIHRlY2huaXF1ZSwgdGhlIG5vZGUgaXNzdWVzIGEgdW5pcXVlXG4gKiAgLy9GaWx0ZXIgSUQvLy4gQXQgdGhpcyBwb2ludCB0aGUgbm9kZSBkZWRpY2F0ZXMgcmVzb3VyY2VzIHRvXG4gKiAgdGhlIGZpbHRlciwgc28gdGhhdCBwZXJpb2RpYyBjYWxscyB0byBmb2xsb3cgdXAgb24gdGhlIC8vRmlsdGVyIElELy9cbiAqICB3aWxsIHJlY2VpdmUgYW55IGV2ZW50cyBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgICNuZXR3b3JrO1xuICAgICNoYXVsdDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxuICAgICAqICB0byB0aGUgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpIHx8IGVycm9yLm9wZXJhdGlvbiAhPT0gXCJldGhfbmV3RmlsdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBGaWx0ZXIgSUQ7IGRvd25ncmFkZSB0b1xuICAgICAgICAgICAgLy8gcG9sbGluZ1xuICAgICAgICAgICAgaWYgKGZpbHRlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9yZWNvdmVyU3Vic2NyaWJlcih0aGlzLCB0aGlzLl9yZWNvdmVyKHRoaXMuI3Byb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsuY2hhaW5JZCAhPT0gbmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhaWQgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXRSZXN1bHRzKHRoaXMuI3Byb3ZpZGVyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAVE9ET1wiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub25jZShcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgICN0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWRQcm9taXNlID0gdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICBpZiAoZmlsdGVySWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgZmlsdGVySWRQcm9taXNlLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingBlockTagSubscriber: () => (/* binding */ PollingBlockTagSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        }\n        else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n//# sourceMappingURL=subscriber-polling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBVztBQUNuQjtBQUNBO0FBQ0EsSUFBSSx1REFBTTtBQUNWLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZUFBZTtBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIHBvbGxpbmcgc3Vic2NyaWJlciBmb3IgY29tbW9uIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvbGxpbmdTdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCkge1xuICAgIGlmIChldmVudCA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcihwcm92aWRlcik7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgcG9sbGluZyBldmVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJnZXRQb2xsaW5nU3Vic2NyaWJlclwiLCBpbmZvOiB7IGV2ZW50IH1cbiAgICB9KTtcbn1cbi8vIEBUT0RPOiByZWZhY3RvciB0aGlzXG4vKipcbiAqICBBICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIHBvbGxzIGF0IGEgcmVndWxhciBpbnRlcnZhbCBmb3IgYSBjaGFuZ2VcbiAqICBpbiB0aGUgYmxvY2sgbnVtYmVyLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsZXI7XG4gICAgI2ludGVydmFsO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkgeyB0aGlzLiNpbnRlcnZhbCA9IHZhbHVlOyB9XG4gICAgYXN5bmMgI3BvbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgcG9sbCB0byBzZXR1cCBvdXIgaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPOiBQdXQgYSBjYXAgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyBwZXIgbG9vcD9cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciAhPT0gdGhpcy4jYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQFRPRE86IE1pbm9yIGJ1bXAsIGFkZCBhbiBcImVycm9yXCIgZXZlbnQgdG8gbGV0IHN1YnNjcmliZXJzXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuI3BvbGwoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5fY2xlYXJUaW1lb3V0KHRoaXMuI3BvbGxlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKk9uQmxvY2tTdWJzY3JpYmVyKiogY2FuIGJlIHN1Yi1jbGFzc2VkLCB3aXRoIGEgW1tfcG9sbF1dXG4gKiAgaW1wbG1lbnRhdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsO1xuICAgICNydW5uaW5nO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipPbkJsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3BvbGwgPSAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGwoYmxvY2tOdW1iZXIsIHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgdGhpcy5zdG9wKCk7IH1cbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxufVxuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3RhZztcbiAgICAjbGFzdEJsb2NrO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCB0YWcpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiN0YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGF1c2UoZHJvcFdoaWxlUGF1c2VkKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2sodGhpcy4jdGFnKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLm51bWJlciA+IHRoaXMuI2xhc3RCbG9jaykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiN0YWcsIGJsb2NrLm51bWJlcik7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNmaWx0ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiNmaWx0ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNoYXNoO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlaGFzaCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcbiAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2hhc2gsIHR4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIGZpbHRlciBmb3IgaXRzIGxvZ3MuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIFRoZSBpbml0aWFsIGJsb2NrIGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjb3B5KHRoaXMuI2ZpbHRlcik7XG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XG4gICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcbiAgICAgICAgLy8gc28gd2Uga2VlcCBhIHNsaWRpbmcgd2luZG93IG9mIDYwIGJsb2NrcyB0byBrZWVwIHNjYW5uaW5nXG4gICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWR2YW5jZSB0aGUgYmxvY2sgbnVtYmVyIHdoZW4gbG9ncyB3ZXJlIGZvdW5kIHRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZXR3b3JrcyAobGlrZSBCTkIgYW5kIFBvbHlnb24pIHdoaWNoIG1heVxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/subscriber-polling.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n//# sourceMappingURL=accesslist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEU7QUFDQTtBQUNBLGlCQUFpQiw2REFBVTtBQUMzQjtBQUNBLFlBQVksK0RBQWMsQ0FBQyw0REFBVyxpREFBaUQsTUFBTTtBQUM3RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWMsZ0RBQWdELE1BQU07QUFDcEY7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyhzdG9yYWdlS2V5LCAzMiksIFwiaW52YWxpZCBzbG90XCIsIGBzdG9yYWdlS2V5c1ske2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0FjY2Vzc0xpc3RdXSBmcm9tIGFueSBldGhlcnMtc3VwcG9ydGVkIGFjY2Vzcy1saXN0IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldC5sZW5ndGggPT09IDIsIFwiaW52YWxpZCBzbG90IHNldFwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldCAhPSBudWxsICYmIHR5cGVvZiAoc2V0KSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFkZHJlc3Mtc2xvdCBzZXRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzbGlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFVLENBQUMsMkRBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEJBQTBCLHdEQUFVO0FBQ3BDO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIGZvciB0aGUgJSVrZXklJS5cbiAqXG4gKiAgVGhlIGtleSBtYXkgYmUgYW55IHN0YW5kYXJkIGZvcm0gb2YgcHVibGljIGtleSBvciBhIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XG4gICAgbGV0IHB1YmtleTtcbiAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHB1YmtleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGtlY2NhazI1NihcIjB4XCIgKyBwdWJrZXkuc3Vic3RyaW5nKDQpKS5zdWJzdHJpbmcoMjYpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGZvciB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3YXNcbiAqICB1c2VkIHRvIHNpZ24gJSVkaWdlc3QlJSB0aGF0IHJlc3VsdGVkIGluICUlc2lnbmF0dXJlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/authorization.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: () => (/* binding */ authorizationify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n\n\n\nfunction authorizationify(auth) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.nonce != null) ? auth.nonce : 0),\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.chainId != null) ? auth.chainId : 0),\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\n    };\n}\n//# sourceMappingURL=authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ0Y7QUFDRDtBQUN2QztBQUNQO0FBQ0EsaUJBQWlCLDZEQUFVO0FBQzNCLGVBQWUsMERBQVM7QUFDeEIsaUJBQWlCLDBEQUFTO0FBQzFCLG1CQUFtQix1REFBUztBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2F1dGhvcml6YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBhdXRob3JpemF0aW9uaWZ5KGF1dGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXG4gICAgICAgIG5vbmNlOiBnZXRCaWdJbnQoKGF1dGgubm9uY2UgIT0gbnVsbCkgPyBhdXRoLm5vbmNlIDogMCksXG4gICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCgoYXV0aC5jaGFpbklkICE9IG51bGwpID8gYXV0aC5jaGFpbklkIDogMCksXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oYXV0aC5zaWduYXR1cmUpXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/authorization.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/transaction.js":
/*!********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/addresses.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accesslist.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./authorization.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob) => {\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n            }\n        }\n        else if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof (kzg.blobToKZGCommitment) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment) => {\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof (kzg.computeBlobProof) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof (kzg.computeBlobKzgProof) === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof (kzg.computeBlobKZGProof) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return { blobToKzgCommitment, computeBlobKzgProof };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) {\n        versioned = \"0\" + versioned;\n    }\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i++) {\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(`authorization[${i}]: invalid array`);\n            }\n            if (auth.length !== 6) {\n                throw new Error(`authorization[${i}]: wrong length`);\n            }\n            if (!auth[1]) {\n                throw new Error(`authorization[${i}]: null address`);\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a) => {\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.r),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.s)\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\n            v\n        });\n        //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x02\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x01\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)]);\n}\nfunction _parseEip4844(data) {\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n        fields = fields[0];\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x03\",\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n        }\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x03\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)]);\n}\nfunction _parseEip7702(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\"),\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x04\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nclass Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    #auths;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n            case 4: return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    }\n    get authorizationList() {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        this.#auths = (auths == null) ? null : auths.map((a) => (0,_authorization_js__WEBPACK_IMPORTED_MODULE_10__.authorizationify)(a));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b) => Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n            else {\n                const commit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data),\n                    commitment: commit,\n                    proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() { return this.#kzg; }\n    set kzg(kzg) {\n        if (kzg == null) {\n            this.#kzg = null;\n        }\n        else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_12__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        const sig = signed ? this.signature : null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            }\n            else if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n                case 4: return Transaction.from(_parseEip7702(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ087QUFDc0I7QUFDdUc7QUFDckk7QUFDTTtBQUNSO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIseURBQVEseUJBQXlCLHdEQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxtQkFBbUIseURBQVE7QUFDM0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUIseURBQVEseUJBQXlCLHdEQUFPO0FBQzNEO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBUSxzQkFBc0Isd0RBQU8sUUFBUSx3REFBTztBQUN2RTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUIseURBQVEseUJBQXlCLHdEQUFPLFFBQVEsd0RBQU87QUFDMUU7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQWE7QUFDNUI7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLGlE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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1REFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQixZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvYWRkcmVzc2VzLmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHNoYTI1NiwgU2lnbmF0dXJlLCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWNvZGVSbHAsIGVuY29kZVJscCwgZ2V0Qnl0ZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0J5dGVzTGlrZSwgaXNIZXhTdHJpbmcsIHRvQmVBcnJheSwgemVyb1BhZFZhbHVlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4vYWNjZXNzbGlzdC5qc1wiO1xuaW1wb3J0IHsgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuL2F1dGhvcml6YXRpb24uanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBCTl9NQVhfVUlOVCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmNvbnN0IEJMT0JfU0laRSA9IDQwOTYgKiAzMjtcbmZ1bmN0aW9uIGdldEt6Z0xpYnJhcnkoa3pnKSB7XG4gICAgY29uc3QgYmxvYlRvS3pnQ29tbWl0bWVudCA9IChibG9iKSA9PiB7XG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcpIHtcbiAgICAgICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXI7IGNoZWNrIGZvciBjb21wdXRlQmxvYlByb29mIHNpbmNlIHRoaXMgQVBJXG4gICAgICAgICAgICAvLyBleHBlY3RzIGEgc3RyaW5nIHdoaWxlIHRoZSBremctd2FzbSBiZWxvdyBleHBlY3RzIGEgVW5pdDhBcnJheVxuICAgICAgICAgICAgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGhleGxpZnkoYmxvYikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8ga3pnLXdhc20gPDAuNS4wOyBibG9iVG9LemdDb21taXRtZW50KFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPj0gMC41LjA7IGJsb2JUb0taR0NvbW1pdG1lbnQoc3RyaW5nKSA9PiBzdHJpbmdcbiAgICAgICAgaWYgKFwiYmxvYlRvS1pHQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LWkdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XG4gICAgfTtcbiAgICBjb25zdCBjb21wdXRlQmxvYkt6Z1Byb29mID0gKGJsb2IsIGNvbW1pdG1lbnQpID0+IHtcbiAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuY29tcHV0ZUJsb2JQcm9vZihoZXhsaWZ5KGJsb2IpLCBoZXhsaWZ5KGNvbW1pdG1lbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPDAuNS4wOyBjb21wdXRlQmxvYkt6Z1Byb29mKFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JLemdQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4ga3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoYmxvYiwgY29tbWl0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga3pnLXdhc20gPj0gMC41LjA7IGNvbXB1dGVCbG9iS1pHUHJvb2Yoc3RyaW5nLCBzdHJpbmcpID0+IHN0cmluZ1xuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYktaR1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS1pHUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuY29tcHV0ZUJsb2JLWkdQcm9vZihoZXhsaWZ5KGJsb2IpLCBoZXhsaWZ5KGNvbW1pdG1lbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcbiAgICB9O1xuICAgIHJldHVybiB7IGJsb2JUb0t6Z0NvbW1pdG1lbnQsIGNvbXB1dGVCbG9iS3pnUHJvb2YgfTtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb25lZEhhc2godmVyc2lvbiwgaGFzaCkge1xuICAgIGxldCB2ZXJzaW9uZWQgPSB2ZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAodmVyc2lvbmVkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdmVyc2lvbmVkID0gXCIwXCIgKyB2ZXJzaW9uZWQ7XG4gICAgfVxuICAgIHZlcnNpb25lZCArPSBzaGEyNTYoaGFzaCkuc3Vic3RyaW5nKDQpO1xuICAgIHJldHVybiBcIjB4XCIgKyB2ZXJzaW9uZWQ7XG59XG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0aG9yaXphdGlvbkxpc3Q6IGludmFsaWQgYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogaW52YWxpZCBhcnJheWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1dGgubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiB3cm9uZyBsZW5ndGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXV0aFsxXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogbnVsbCBhZGRyZXNzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogaGFuZGxlQWRkcmVzcyhhdXRoWzFdKSxcbiAgICAgICAgICAgICAgICBub25jZTogaGFuZGxlVWludChhdXRoWzJdLCBcIm5vbmNlXCIpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoYXV0aFswXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5OiBoYW5kbGVOdW1iZXIoYXV0aFszXSwgXCJ5UGFyaXR5XCIpLFxuICAgICAgICAgICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoYXV0aFs0XSwgMzIpLFxuICAgICAgICAgICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoYXV0aFs1XSwgMzIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVOdW1iZXIoX3ZhbHVlLCBwYXJhbSkge1xuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGdldE51bWJlcihfdmFsdWUsIHBhcmFtKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVVpbnQoX3ZhbHVlLCBwYXJhbSkge1xuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gQk5fMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBwYXJhbSk7XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPD0gQk5fTUFYX1VJTlQsIFwidmFsdWUgZXhjZWVkcyB1aW50IHNpemVcIiwgcGFyYW0sIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIoX3ZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmxlbmd0aCA8PSAzMiwgYHZhbHVlIHRvbyBsYXJnZWAsIGB0eC4ke25hbWV9YCwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcCgoc2V0KSA9PiBbc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5c10pO1xufVxuZnVuY3Rpb24gZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKChhKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgICAgICBhLmFkZHJlc3MsXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLnNpZ25hdHVyZS55UGFyaXR5LCBcInlQYXJpdHlcIiksXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUuciksXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUucylcbiAgICAgICAgXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhhc2hlcyh2YWx1ZSwgcGFyYW0pIHtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgYGludmFsaWQgJHtwYXJhbX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCAkeyBwYXJhbSB9IGhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gNiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9uXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbM10pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgIT09IEJOXzAgfHwgKHYgPT09IEJOXzI3IHx8IHYgPT09IEJOXzI4KSwgXCJub24tY2Fub25pY2FsIGxlZ2FjeSB2XCIsIFwidlwiLCBmaWVsZHNbNl0pO1xuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXG4gICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzhdLCAzMiksXG4gICAgICAgICAgICB2XG4gICAgICAgIH0pO1xuICAgICAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgIF07XG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiLCBcInlQYXJpdHlcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgciA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMV0sIDMyKTtcbiAgICBjb25zdCBzID0gemVyb1BhZFZhbHVlKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcbiAgICB0eC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAyXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s2XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzddLCBcImFjY2Vzc0xpc3RcIilcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOCkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAxXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXA0ODQ0KGRhdGEpIHtcbiAgICBsZXQgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBsZXQgdHlwZU5hbWUgPSBcIjNcIjtcbiAgICBsZXQgYmxvYnMgPSBudWxsO1xuICAgIC8vIFBhcnNlIHRoZSBuZXR3b3JrIGZvcm1hdFxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA0ICYmIEFycmF5LmlzQXJyYXkoZmllbGRzWzBdKSkge1xuICAgICAgICB0eXBlTmFtZSA9IFwiMyAobmV0d29yayBmb3JtYXQpXCI7XG4gICAgICAgIGNvbnN0IGZCbG9icyA9IGZpZWxkc1sxXSwgZkNvbW1pdHMgPSBmaWVsZHNbMl0sIGZQcm9vZnMgPSBmaWVsZHNbM107XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkJsb2JzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbMV1cIiwgZkJsb2JzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQ29tbWl0cyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogY29tbWl0bWVudHMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzJdXCIsIGZDb21taXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmUHJvb2ZzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBwcm9vZnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzNdXCIsIGZQcm9vZnMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmQ29tbWl0cy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvY29tbWl0bWVudHMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZQcm9vZnMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL3Byb29mcyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcbiAgICAgICAgYmxvYnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHNbMV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGZCbG9ic1tpXSxcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiBmQ29tbWl0c1tpXSxcbiAgICAgICAgICAgICAgICBwcm9vZjogZlByb29mc1tpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkc1swXTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMSB8fCBmaWVsZHMubGVuZ3RoID09PSAxNCksIGBpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBoYW5kbGVVaW50KGZpZWxkc1s5XSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBmaWVsZHNbMTBdXG4gICAgfTtcbiAgICBpZiAoYmxvYnMpIHtcbiAgICAgICAgdHguYmxvYnMgPSBibG9icztcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodHgudG8gIT0gbnVsbCwgYGludmFsaWQgYWRkcmVzcyBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoZXM6IG11c3QgYmUgYW4gYXJyYXlcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHguYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzW2ldLCAzMiksIGBpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoIGF0IGluZGV4ICR7aX06IG11c3QgYmUgbGVuZ3RoIDMyYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCBFSVAtNDg0NCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxMSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBEbyB3ZSBuZWVkIHRvIGRvIHRoaXM/IFRoaXMgaXMgb25seSBjYWxsZWQgaW50ZXJuYWxseVxuICAgIC8vIGFuZCB1c2VkIHRvIHZlcmlmeSBoYXNoZXM7IGl0IG1pZ2h0IHNhdmUgdGltZSB0byBub3QgZG8gdGhpc1xuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1Nihjb25jYXQoWyBcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcykgXSkpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDExKSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDQ4NDQodHgsIHNpZywgYmxvYnMpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFplcm9BZGRyZXNzKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyQmxvYkdhcyB8fCAwLCBcIm1heEZlZVBlckJsb2JHYXNcIiksXG4gICAgICAgIGZvcm1hdEhhc2hlcyh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIHx8IFtdLCBcImJsb2JWZXJzaW9uZWRIYXNoZXNcIilcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgICAgIC8vIFdlIGhhdmUgYmxvYnM7IHJldHVybiB0aGUgbmV0d29yayB3cmFwcGVkIGZvcm1hdFxuICAgICAgICBpZiAoYmxvYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgICAgIFwiMHgwM1wiLFxuICAgICAgICAgICAgICAgIGVuY29kZVJscChbXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5wcm9vZiksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNzcwMihkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDEwIHx8IGZpZWxkcy5sZW5ndGggPT09IDEzKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiA0XCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogNCxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QoZmllbGRzWzldLCBcImF1dGhvcml6YXRpb25MaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTc3MDIgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMCkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA3NzAyKHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QodHguYXV0aG9yaXphdGlvbkxpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDRcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXG4gKiAgd2hvICh0aGUgW1t0b11dIGFkZHJlc3MpLCB3aGF0ICh0aGUgW1tkYXRhXV0pIGFuZCBob3cgbXVjaCAodGhlXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAjbWF4RmVlUGVyQmxvYkdhcztcbiAgICAjYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAja3pnO1xuICAgICNibG9icztcbiAgICAjYXV0aHM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogIElmIG51bGwsIHRoZSB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvblxuICAgICAqICBleHBsaWNpdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy4jdHlwZTsgfVxuICAgIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgXCJsZWdhY3lcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJiZXJsaW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMjkzMFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImxvbmRvblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0xNTU5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiY2FuY3VuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTQ4NDRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJwZWN0cmFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNzcwMlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBcImVpcC0xNTU5XCI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBcImVpcC00ODQ0XCI7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBcImVpcC03NzAyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3RvO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBaZXJvQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCB0byh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0byA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBub25jZS5cbiAgICAgKi9cbiAgICBnZXQgbm9uY2UoKSB7IHJldHVybiB0aGlzLiNub25jZTsgfVxuICAgIHNldCBub25jZSh2YWx1ZSkgeyB0aGlzLiNub25jZSA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcyB0aGlzIGRlZmluZXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgcGFpZC4gT25cbiAgICAgKiAgRUlQLTE1NTkgbmV0d29ya3MsIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBnYXNQcmljZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNnYXNQcmljZTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHRoaXMudHlwZSA9PT0gMCB8fCB0aGlzLnR5cGUgPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBnYXNQcmljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwiZ2FzUHJpY2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhQcmlvcml0eUZlZVBlckdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBldGhlciAoaW4gd2VpKSB0byBzZW5kIGluIHRoaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBhdXRob3JpemF0aW9uTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhdXRocyB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBpbiB2NywgdGhpcyBzaG91bGQgYmVjb21lIGEgbGl2ZSBvYmplY3QgaXRzZWxmLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYXV0aG9yaXphdGlvbkxpc3QoYXV0aHMpIHtcbiAgICAgICAgdGhpcy4jYXV0aHMgPSAoYXV0aHMgPT0gbnVsbCkgPyBudWxsIDogYXV0aHMubWFwKChhKSA9PiBhdXRob3JpemF0aW9uaWZ5KGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXggZmVlIHBlciBibG9iIGdhcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyQmxvYkdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckJsb2JHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyQmxvYkdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9iIHZlcnNpb25lZCBoYXNoZXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGJsb2JWZXJzaW9uZWRIYXNoZXMoKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnQ7IGlmIHVuc2V0LCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgICAgLy8gY2Fubm90IG11dGF0ZSB0aGUgb2JqZWN0LCBpZiBzZXQgaXQgY2FuXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGJsb2JWZXJzaW9uZWRIYXNoZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9icyBmb3IgdGhlIFRyYW5zYWN0aW9uLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiAgSWYgYGBibG9ic2BgIGlzIG5vbi1gYG51bGxgYCwgdGhlbiB0aGUgW1tzZXJpYWlsaXplZF1dXG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBuZXR3b3JrIGZvcm1hdHRlZCBzaWRlY2FyLCBvdGhlcndpc2UgaXRcbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIHN0YW5kYXJkIFtbbGluay1laXAtMjcxOF1dIHBheWxvYWQuIFRoZVxuICAgICAqICBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dIGlzIHVuYWZmZWN0ZWQgcmVnYXJkbGVzcy5cbiAgICAgKlxuICAgICAqICBXaGVuIHNldHRpbmcgYGBibG9ic2BgLCBlaXRoZXIgZnVsbHkgdmFsaWQgW1tCbG9iXV0gb2JqZWN0c1xuICAgICAqICBtYXkgYmUgc3BlY2lmaWVkIChpLmUuIGNvcnJlY3RseSBwYWRkZWQsIHdpdGggY29ycmVjdFxuICAgICAqICBjb21taXR0bWVudHMgYW5kIHByb29mcykgb3IgYSByYXcgW1tCeXRlc0xpa2VdXSBtYXlcbiAgICAgKiAgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiAgSWYgcmF3IFtbQnl0ZXNMaWtlXV0gYXJlIHByb3ZpZGVkLCB0aGUgW1tremddXSBwcm9wZXJ0eSAqKm11c3QqKlxuICAgICAqICBiZSBhbHJlYWR5IHNldC4gVGhlIGJsb2Igd2lsbCBiZSBjb3JyZWN0bHkgcGFkZGVkIGFuZCB0aGVcbiAgICAgKiAgW1tLemdMaWJyYXJ5XV0gd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvbW1pdHRtZW50IGFuZFxuICAgICAqICBwcm9vZiBmb3IgdGhlIGJsb2IuXG4gICAgICpcbiAgICAgKiAgQSBCTE9iIGlzIGEgc2VxdWVuY2Ugb2YgZmllbGQgZWxlbWVudHMsIGVhY2ggb2Ygd2hpY2ggbXVzdFxuICAgICAqICBiZSB3aXRoaW4gdGhlIEJMUyBmaWVsZCBtb2R1bG8sIHNvIHNvbWUgYWRkaXRpb25hbCBwcm9jZXNzaW5nXG4gICAgICogIG1heSBiZSByZXF1aXJlZCB0byBlbmNvZGUgYXJiaXRyYXJ5IGRhdGEgdG8gZW5zdXJlIGVhY2ggMzIgYnl0ZVxuICAgICAqICBmaWVsZCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlcyBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSxcbiAgICAgKiAgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIHZhbHVlcy4gU2V0dGluZyB0aGlzIHRvIGBgbnVsbGBgXG4gICAgICogIGRvZXMgKipub3QqKiByZW1vdmUgdGhlIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLCBsZWF2aW5nIHRoZW1cbiAgICAgKiAgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXQgYmxvYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLiNibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jYmxvYnMubWFwKChiKSA9PiBPYmplY3QuYXNzaWduKHt9LCBiKSk7XG4gICAgfVxuICAgIHNldCBibG9icyhfYmxvYnMpIHtcbiAgICAgICAgaWYgKF9ibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2Jsb2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gX2Jsb2JzW2ldO1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGJsb2IpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRoaXMuI2t6ZywgXCJhZGRpbmcgYSByYXcgYmxvYiByZXF1aXJlcyBhIEtaRyBsaWJyYXJ5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldCBibG9icygpXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzKGJsb2IpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGEubGVuZ3RoIDw9IEJMT0JfU0laRSwgXCJibG9iIGlzIHRvbyBsYXJnZVwiLCBgYmxvYnNbJHtpfV1gLCBibG9iKTtcbiAgICAgICAgICAgICAgICAvLyBQYWQgYmxvYiBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IEJMT0JfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCTE9CX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWQuc2V0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSB0aGlzLiNremcuYmxvYlRvS3pnQ29tbWl0bWVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9vZiA9IGhleGxpZnkodGhpcy4ja3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoZGF0YSwgY29tbWl0KSk7XG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGhleGxpZnkoY29tbWl0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2ZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gaGV4bGlmeShibG9iLmNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGJsb2IuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2Y6IGhleGxpZnkoYmxvYi5wcm9vZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JzID0gYmxvYnM7XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2ZXJzaW9uZWRIYXNoZXM7XG4gICAgfVxuICAgIGdldCBremcoKSB7IHJldHVybiB0aGlzLiNremc7IH1cbiAgICBzZXQga3pnKGt6Zykge1xuICAgICAgICBpZiAoa3pnID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2t6ZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNremcgPSBnZXRLemdMaWJyYXJ5KGt6Zyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgVHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RvID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbm9uY2UgPSAwO1xuICAgICAgICB0aGlzLiNnYXNMaW1pdCA9IEJOXzA7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNkYXRhID0gXCIweFwiO1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IEJOXzA7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNzaWcgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2F1dGhzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLnVuc2lnbmVkU2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGluZyBhZGRyZXNzLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb20oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3ModGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbVB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAjZ2V0U2VyaWFsaXplZChzaWduZWQsIHNpZGVjYXIpIHtcbiAgICAgICAgYXNzZXJ0KCFzaWduZWQgfHwgdGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgICAgICBjb25zdCBzaWcgPSBzaWduZWQgPyB0aGlzLnNpZ25hdHVyZSA6IG51bGw7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbmZlclR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplTGVnYWN5KHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMsIHNpZyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXA0ODQ0KHRoaXMsIHNpZywgc2lkZWNhciA/IHRoaXMuYmxvYnMgOiBudWxsKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDc3MDIodGhpcywgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB0aHJvd3MgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVuc2lnbmVkLiBGb3IgdGhlIHByZS1pbWFnZSxcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZS5cbiAgICAgKlxuICAgICAqICBUaGUgaGFzaCBvZiB0aGlzIGlzIHRoZSBkaWdlc3Qgd2hpY2ggbmVlZHMgdG8gYmUgc2lnbmVkIHRvXG4gICAgICogIGF1dGhvcml6ZSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRTZXJpYWxpemVkKGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgaW5mZXJUeXBlKCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuaW5mZXJUeXBlcygpO1xuICAgICAgICAvLyBQcmVmZXIgTG9uZG9uIChFSVAtMTU1OSkgb3ZlciBDYW5jdW4gKEJMT2IpXG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKDIpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgaGlnaGVzdCBpbmZlcnJlZCB0eXBlXG4gICAgICAgIHJldHVybiAodHlwZXMucG9wKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVmFsaWRhdGVzIHRoZSBleHBsaWNpdCBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBjb21wYXRpYmxlXG4gICAgICogIHRyYW5zYWN0aW9uIHR5cGVzLlxuICAgICAqL1xuICAgIGluZmVyVHlwZXMoKSB7XG4gICAgICAgIC8vIENoZWNrcyB0aGF0IHRoZXJlIGFyZSBubyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBjb25zdCBoYXNHYXNQcmljZSA9IHRoaXMuZ2FzUHJpY2UgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzRmVlID0gKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQWNjZXNzTGlzdCA9ICh0aGlzLmFjY2Vzc0xpc3QgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0Jsb2IgPSAodGhpcy4jbWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsIHx8IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMpO1xuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2UgYW5kIG1heEZlZVBlckdhc1wiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGFzc2VydCghaGFzRmVlIHx8ICh0aGlzLnR5cGUgIT09IDAgJiYgdGhpcy50eXBlICE9PSAxKSwgXCJ0cmFuc2FjdGlvbiB0eXBlIGNhbm5vdCBoYXZlIG1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGFzc2VydCh0aGlzLnR5cGUgIT09IDAgfHwgIWhhc0FjY2Vzc0xpc3QsIFwibGVnYWN5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGFjY2Vzc0xpc3RcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgJiYgdGhpcy5hdXRob3JpemF0aW9uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQmxvYiAmJiB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIFtbbGluay1laXAtNDg0NF1dIEJMT0JcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHRyYW5zYWNpdG9uLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIEpTT04tZnJpZW5kbHkgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcyA9ICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHModGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogcyh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBzKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHZhbHVlOiBzKHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgY2hhaW5JZDogcyh0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgc2lnOiB0aGlzLnNpZ25hdHVyZSA/IHRoaXMuc2lnbmF0dXJlLnRvSlNPTigpIDogbnVsbCxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHgpIHtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBnZXRCeXRlcyh0eCk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFswXSA+PSAweDdmKSB7IC8vIEBUT0RPOiA+IHZzID49ID8/XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlTGVnYWN5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMjkzMChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAxNTU5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDQ4NDQocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwNzcwMihwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHR4LmF1dGhvcml6YXRpb25MaXN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgYmxvYnMsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhc3NpZ24gdGhlIGt6ZyBiZWZvcmUgYXNzaWduaW5nIGJsb2JzLCB3aGljaFxuICAgICAgICAvLyByZXF1aXJlIHRoZSBsaWJyYXJ5IGluIHRoZSBldmVudCByYXcgYmxvYiBkYXRhIGlzIHByb3ZpZGVkLlxuICAgICAgICBpZiAodHgua3pnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5remcgPSB0eC5remc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmJsb2JzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9icyA9IHR4LmJsb2JzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5oYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5oYXNoJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5oYXNoID09PSB0eC5oYXNoLCBcImhhc2ggbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSAnLmZyb20nXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmZyb20udG9Mb3dlckNhc2UoKSA9PT0gKHR4LmZyb20gfHwgXCJcIikudG9Mb3dlckNhc2UoKSwgXCJmcm9tIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/transaction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base58.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base58.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\n\n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for (let i = 0; i < Alphabet.length; i++) {\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nfunction encodeBase58(_value) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for (let i = 0; i < bytes.length; i++) {\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nfunction decodeBase58(value) {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDUTtBQUNQO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLGtEQUFRO0FBQzFCLGdCQUFnQixtREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XG4gKiAgYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLiBDb25mdXNpbmdseSBzaW1pbGFyIGNoYXJhY3RlcnMgYXJlIG9taXR0ZWRcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXG4gKlxuICogIE5vdGUgdGhhdCBCYXNlNTggZW5jb2RlcyBhICoqbnVtZXJpYyoqIHZhbHVlLCBub3QgYXJiaXRyYXJ5IGJ5dGVzLFxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcbiAqICB0byBlbnN1cmUgbm9uLXplcm8gcHJlZml4ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl81OCA9IEJpZ0ludCg1OCk7XG4vKipcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX3ZhbHVlKTtcbiAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChieXRlcyk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0W051bWJlcih2YWx1ZSAlIEJOXzU4KV0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlIC89IEJOXzU4O1xuICAgIH1cbiAgICAvLyBBY2NvdW50IGZvciBsZWFkaW5nIHBhZGRpbmcgemVyb3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChieXRlc1tpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbMF0gKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base58.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base64-browser.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base64-browser.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n// utils/base64-browser\n\nfunction decodeBase64(textData) {\n    textData = atob(textData);\n    const data = new Uint8Array(textData.length);\n    for (let i = 0; i < textData.length; i++) {\n        data[i] = textData.charCodeAt(i);\n    }\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n}\nfunction encodeBase64(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUM7QUFDOUI7QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0EsV0FBVyxrREFBUTtBQUNuQjtBQUNPO0FBQ1AsaUJBQWlCLGtEQUFRO0FBQ3pCO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQtYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1dGlscy9iYXNlNjQtYnJvd3NlclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSB0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base64-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\n\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9kYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoPzpbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJ5dGVzTGlrZSB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLiBJZiBhbHJlYWR5IGEgVWludDhBcnJheVxuICogIHRoZSBvcmlnaW5hbCAlJXZhbHVlJSUgaXMgcmV0dXJuZWQ7IGlmIGEgY29weSBpcyByZXF1aXJlZCB1c2VcbiAqICBbW2dldEJ5dGVzQ29weV1dLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc0NvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XG4gKiAgdG8gcHJldmVudCBhbnkgbW9kaWZpY2F0aW9ucyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBiZWluZ1xuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0hleFN0cmluZ11dLlxuICpcbiAqICBJZiAlJWxlbmd0aCUlIGlzIGBgdHJ1ZWBgIG9yIGEgLy9udW1iZXIvLywgaXQgYWxzbyBjaGVja3MgdGhhdFxuICogICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9mICUlbGVuZ3RoJSUgKGlmIGEgLy9udW1iZXIvLylcbiAqICBieXRlcyBvZiBkYXRhIChlLmcuIGBgMHgxMjM0YGAgaXMgMiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGJ5dGVzW2ldO1xuICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGRhdGFzKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGFzLm1hcCgoZCkgPT4gaGV4bGlmeShkKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxuICpcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHNsaWNlIGJleW9uZCBkYXRhIGJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogYnl0ZXMubGVuZ3RoLCBvZmZzZXQ6IGVuZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMuc2xpY2UoKHN0YXJ0ID09IG51bGwpID8gMCA6IHN0YXJ0LCAoZW5kID09IG51bGwpID8gYnl0ZXMubGVuZ3RoIDogZW5kKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBhc3NlcnQobGVuZ3RoID49IGJ5dGVzLmxlbmd0aCwgXCJwYWRkaW5nIGV4Y2VlZHMgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgb2Zmc2V0OiBsZW5ndGggKyAxXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCgwKTtcbiAgICBpZiAobGVmdCkge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCBsZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgMCk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipsZWZ0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKnZhbHVlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgdWludDEyOGBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkQnl0ZXMoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBmYWxzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof (value) === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map((v) => stringify(v, seen))).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsbUJBQW1CLElBQUksMEJBQTBCLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEMsZ0NBQWdDLGdEQUFPLENBQUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFnQixVQUFVLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixVQUFVLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNLE9BQU87QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBzZWVuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoc2VlbiA9PSBudWxsKSB7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoKHYpID0+IHN0cmluZ2lmeSh2LCBzZWVuKSkpLmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpLCBzZWVuKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGssIHNlZW4pfTogJHtzdHJpbmdpZnkodmFsdWVba10sIHNlZW4pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/events.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/events.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\n\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nclass EventPayload {\n    /**\n     *  The event filter.\n     */\n    filter;\n    /**\n     *  The **EventEmitterable**.\n     */\n    emitter;\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter, listener, filter) {\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { emitter, filter });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBZ0IsU0FBUyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXZlbnRzIGFsbG93IGZvciBhcHBsaWNhdGlvbnMgdG8gdXNlIHRoZSBvYnNlcnZlciBwYXR0ZXJuLCB3aGljaFxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxuICogIGV4ZWN1dGlvbiBwYXRocy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuLyoqXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXG4gKiAgY2FsbGJhY2sgYWx3YXlzIGFoYXMgb25lIGFkZGl0aW9uYWwgYXJndW1lbnQgcGFzc2VkLCB3aGljaCBpc1xuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/geturl-browser.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\n\n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3])));\n    }\n    catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        }\n        catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nclass FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request) {\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() { return this.#cancelled; }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nclass FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */\n    get url() { return this.#url; }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        }\n        else if (typeof (body) === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        }\n        else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        }\n        else if (typeof (body) === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        }\n        else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout() { return this.#timeout; }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url) {\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    }\n                    catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                        // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            }\n            catch (error) { }\n            // Things won't get any better on another attempt; abort\n            return response;\n        }\n        else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            }\n            catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n    clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#throttle = Object.assign({}, this.#throttle);\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nclass FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */\n    get statusCode() { return this.#statusCode; }\n    /**\n     *  The response status message.\n     */\n    get statusMessage() { return this.#statusMessage; }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers() { return Object.assign({}, this.#headers); }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body() {\n        return (this.#body == null) ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText() {\n        try {\n            return (this.#body == null) ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        }\n        catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        }\n        catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = ((body == null) ? null : new Uint8Array(body));\n        this.#request = (request || null);\n        this.#error = { message: \"\" };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        }\n        else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        }\n        else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, { stall, throttle: true });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The request made for this response.\n     */\n    get request() { return this.#request; }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok() {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if (this.#body) {\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n            }\n        }\n        catch (e) { }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error,\n            info: {\n                requestUrl, responseBody,\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\n            }\n        });\n    }\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQ7QUFDckI7QUFDaUI7QUFDRjtBQUNHO0FBQ1g7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFZO0FBQ3BDLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYyx3REFBWTtBQUNuQztBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEsRUFBRSxTQUFTO0FBQzFEO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxRQUFRLGtEQUFNLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0RBQWdELHdEQUFZLENBQUMscURBQVcsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0EsV0FBVyxxREFBVztBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBGZXRjaGluZyBjb250ZW50IGZyb20gdGhlIHdlYiBpcyBlbnZpcm9ubWVudC1zcGVjaWZpYywgc28gRXRoZXJzXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxuICogIHRoaXMgc2VydmljZS5cbiAqXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cbiAqICBjcmVhdGUgYSByZXF1ZXN0IG9iamVjdCwgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9jZXNzIGRhdGFcbiAqICBhbmQgcG9wdWxhdGUgdGhlIFtbRmV0Y2hSZXNwb25zZV1dLlxuICpcbiAqICBJbiBhIGJyb3dzZXIsIHRoZSBbRE9NIGZldGNoXShsaW5rLWpzLWZldGNoKSBpcyB1c2VkLCBhbmQgdGhlIHJlc3VsdGluZ1xuICogIGBgUHJvbWlzZWBgIGlzIHdhaXRlZCBvbiB0byByZXRyaWV2ZSB0aGUgcGF5bG9hZC5cbiAqXG4gKiAgVGhlIFtbRmV0Y2hSZXF1ZXN0XV0gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIG1hbnkgY29tbW9uIHNpdHVhdGlvbnMsXG4gKiAgc3VjaCBhcyByZWRpcmVjdHMsIHNlcnZlciB0aHJvdHRsaW5nLCBhdXRoZW50aWNhdGlvbiwgZXRjLlxuICpcbiAqICBJdCBhbHNvIGhhbmRsZXMgY29tbW9uIGdhdGV3YXlzLCBzdWNoIGFzIElQRlMgYW5kIGRhdGEgVVJJcy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9mZXRjaGluZzpGZXRjaGluZyBXZWIgQ29udGVudCAgW2Fib3V0LWZldGNoXVxuICovXG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQsIGVuY29kZUJhc2U2NCB9IGZyb20gXCIuL2Jhc2U2NC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4vdXRmOC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlR2V0VXJsIH0gZnJvbSBcIi4vZ2V0dXJsLmpzXCI7XG5jb25zdCBNQVhfQVRURU1QVFMgPSAxMjtcbmNvbnN0IFNMT1RfSU5URVJWQUwgPSAyNTA7XG4vLyBUaGUgZ2xvYmFsIEZldGNoR2V0VXJsRnVuYyBpbXBsZW1lbnRhdGlvbi5cbmxldCBkZWZhdWx0R2V0VXJsRnVuYyA9IGNyZWF0ZUdldFVybCgpO1xuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgcmVJcGZzID0gbmV3IFJlZ0V4cChcIl5pcGZzOi9cXC8oaXBmcy8pPyguKikkXCIsIFwiaVwiKTtcbi8vIElmIGxvY2tlZCwgbmV3IEdhdGV3YXlzIGNhbm5vdCBiZSBhZGRlZFxubGV0IGxvY2tlZCA9IGZhbHNlO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSTHNcbmFzeW5jIGZ1bmN0aW9uIGRhdGFHYXRld2F5RnVuYyh1cmwsIHNpZ25hbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlRGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoMjAwLCBcIk9LXCIsIHtcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXG4gICAgICAgIH0sIChtYXRjaFsyXSA/IGRlY29kZUJhc2U2NChtYXRjaFszXSkgOiB1bnBlcmNlbnQobWF0Y2hbM10pKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIGRhdGE6IFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRmV0Y2hHYXRld2F5RnVuY11dIGZvciBmZXRjaGluZyBjb250ZW50IGZyb20gYSBzdGFuZGFyZFxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlSXBmcyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsaW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xufVxuY29uc3QgR2F0ZXdheXMgPSB7XG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcbiAgICBcImlwZnNcIjogZ2V0SXBmc0dhdGV3YXlGdW5jKFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiKVxufTtcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hDYW5jZWxTaWduYWwge1xuICAgICNsaXN0ZW5lcnM7XG4gICAgI2NhbmNlbGxlZDtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgZmV0Y2hTaWduYWxzLnNldChyZXF1ZXN0LCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4jY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGxpc3RlbmVyKCk7IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBhc3NlcnQoIXRoaXMuI2NhbmNlbGxlZCwgXCJzaW5nYWwgYWxyZWFkeSBjYW5jZWxsZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZldGNoQ2FuY2VsU2lnbmFsLmFkZENhbmNlbExpc3RlbmVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxuICAgIGNoZWNrU2lnbmFsKCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuY2FuY2VsbGVkLCBcImNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiLCB7fSk7XG4gICAgfVxufVxuLy8gQ2hlY2sgdGhlIHNpZ25hbCwgdGhyb3dpbmcgaWYgaXQgaXMgY2FuY2VsbGVkXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UgdXNpbmcgYSBVUkkuXG4gKlxuICogIEJ5IGRlZmF1bHQsIHRoZSBzdXBwb3J0ZWQgc2NoZW1lcyBhcmUgYGBIVFRQYGAsIGBgSFRUUFNgYCwgYGBkYXRhOmBgLFxuICogIGFuZCBgYElQRlM6YGAuXG4gKlxuICogIEFkZGl0aW9uYWwgc2NoZW1lcyBjYW4gYmUgYWRkZWQgZ2xvYmFsbHkgdXNpbmcgW1tyZWdpc3RlckdhdGV3YXldXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KFwiaHR0cHM6Ly93d3cucmljbW9vLmNvbVwiKVxuICogICAgcmVzcCA9IGF3YWl0IHJlcS5zZW5kKClcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVxdWVzdCB7XG4gICAgI2FsbG93SW5zZWN1cmU7XG4gICAgI2d6aXA7XG4gICAgI2hlYWRlcnM7XG4gICAgI21ldGhvZDtcbiAgICAjdGltZW91dDtcbiAgICAjdXJsO1xuICAgICNib2R5O1xuICAgICNib2R5VHlwZTtcbiAgICAjY3JlZHM7XG4gICAgLy8gSG9va3NcbiAgICAjcHJlZmxpZ2h0O1xuICAgICNwcm9jZXNzO1xuICAgICNyZXRyeTtcbiAgICAjc2lnbmFsO1xuICAgICN0aHJvdHRsZTtcbiAgICAjZ2V0VXJsRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIFVSTCB0byByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICBzZXQgdXJsKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBib2R5LCBpZiBhbnksIHRvIHNlbmQgYXMgdGhlIHJlcXVlc3QgYm9keS4gLy8oZGVmYXVsdDogbnVsbCkvL1xuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogIHNldCBhbmQgd2lsbCBiZSB1c2VkIGlmICoqbm90IG92ZXJyaWRkZW4qKiBieSBzZXR0aW5nIGEgY3VzdG9tXG4gICAgICogIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBudWxsLCB0aGUgYm9keSBpcyBjbGVhcmVkIChhbG9uZyB3aXRoIHRoZVxuICAgICAqICBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCkuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBzdHJpbmcsIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGB0ZXh0L3BsYWluYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBVaW50OEFycmF5LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYW55IG90aGVyIG9iamVjdCwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzXG4gICAgICogIHNldCB0byBgYGFwcGxpY2F0aW9uL2pzb25gYC5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICBzZXQgYm9keShib2R5KSB7XG4gICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoYm9keSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9keVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gSWYgbm8gbWV0aG9kXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xuICAgICAqICBudWxsIGFuZCBgYFBPU1RgYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI21ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCb2R5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gQWxsXG4gICAgICogIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvYmplY3QgaXMgYSBjb3B5LCBzbyBhbnkgY2hhbmdlcyB3aWxsICoqTk9UKiogYmUgcmVmbGVjdGVkXG4gICAgICogIGluIHRoZSBgYEZldGNoUmVxdWVzdGBgLlxuICAgICAqXG4gICAgICogIFRvIHNldCBhIGhlYWRlciBlbnRyeSwgdXNlIHRoZSBgYHNldEhlYWRlcmBgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jY3JlZHMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSBTdHJpbmcodGhpcy5ib2R5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXG4gICAgICogIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnNbU3RyaW5nKGtleSkudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYWxsIGhlYWRlcnMsIHJlc2V0dGluZyBhbGwgaW50cmluc2ljIGhlYWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgZm9yIHRoZSBgYEF1dGhvcml6YXRpb25gYCBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IHRoZSBjcmVkZW50aWFscywgdXNlIHRoZSBgYHNldENyZWRlbnRpYWxzYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGFuIGBgQXV0aG9yaXphdGlvbmBgIGZvciAlJXVzZXJuYW1lJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGV0ZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBwcmlvciB0byBlYWNoIHJlcXVlc3QsIGZvciBleGFtcGxlXG4gICAgICogIGR1cmluZyBhIHJlZGlyZWN0aW9uIG9yIHJldHJ5IGluIGNhc2Ugb2Ygc2VydmVyIHRocm90dGxpbmcuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvZmZlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcG9wdWxhdGUgaGVhZGVycyBvciB1cGRhdGVcbiAgICAgKiAgY29udGVudCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHByZWZsaWdodEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcmVmbGlnaHQgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByZWZsaWdodEZ1bmMocHJlZmxpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3ByZWZsaWdodCA9IHByZWZsaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVzcG9uc2UsIG9mZmVyaW5nIGFuXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcbiAgICAgKiAgcmVzcG9uc2UgZGF0YS5cbiAgICAgKlxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxuICAgICAqXG4gICAgICogIFRvIHNjaGVkdWxlIGEgcmV0cnkgYXR0ZW1wdCAoYXNzdW1pbmcgdGhlIG1heGltdW0gcmV0cnkgbGltaXRcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcm9jZXNzRnVuYyhwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxuICAgICAqL1xuICAgIGdldCByZXRyeUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcmV0cnlGdW5jKHJldHJ5KSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcyBhbmQgaXMgcGxhdGZvcm0gc3BlY2lmaWMgKGUuZy4gbm9kZWpzIHZzXG4gICAgICogIGJyb3dzZXJzKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGJ5IGRlZmF1bHQgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmxcbiAgICAgKiAgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIFtbcmVnaXN0ZXJHZXRVcmxdXS5cbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxuICAgICAqICB0aGlzIEZldGNoUmVxdWVzdCAoYW5kIGFueSBmdXR1cmUgY2xvbmVzKSB0byByZXZlcnQgYmFjayB0b1xuICAgICAqICB1c2luZyB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgaXMgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnksIGJ1dCBtYXkgYmUgdXNlZnVsXG4gICAgICogIGZvciBkZXZlbG9wZXJzIHRoYXQgd2lzaCB0byBpbnRlcmNlcHQgcmVxdWVzdHMgb3IgdG9cbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBnZXQgZ2V0VXJsRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XG4gICAgfVxuICAgIHNldCBnZXRVcmxGdW5jKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBPbmNlIGNyZWF0ZWQsIGVhY2ggcHJvcGVydHkgbWF5IGJlIHNldCBiZWZvcmUgaXNzdWluZyBhXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICB0aGlzLiNhbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2d6aXAgPSB0cnVlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuI3RpbWVvdXQgPSAzMDAwMDA7XG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xuICAgICAgICAgICAgc2xvdEludGVydmFsOiBTTE9UX0lOVEVSVkFMLFxuICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IE1BWF9BVFRFTVBUU1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNnZXRVcmxGdW5jID0gbnVsbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVxdWVzdCBtZXRob2Q9JHtKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCl9IHVybD0ke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gaGVhZGVycz0ke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlIHRoZSB0aHJvdHRsZSBwYXJhbWV0ZXJzIHVzZWQgdG8gZGV0ZXJtaW5lIG1heGltdW1cbiAgICAgKiAgYXR0ZW1wdHMgYW5kIGV4cG9uZW50aWFsLWJhY2tvZmYgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zbG90SW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1heEF0dGVtcHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XG4gICAgICAgIGlmIChhdHRlbXB0ID49IHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImV4Y2VlZGVkIG1heGltdW0gcmV0cnkgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdldFRpbWUoKSA8PSBleHBpcmVzLCBcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0LnNlbmRcIiwgcmVhc29uOiBcInRpbWVvdXRcIiwgcmVxdWVzdDogX3JlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IChyZXEudXJsLnNwbGl0KFwiOlwiKVswXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xuICAgICAgICBpZiAoc2NoZW1lIGluIEdhdGV3YXlzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBHYXRld2F5c1tzY2hlbWVdKHJlcS51cmwsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgcHJlZmxpZ2h0IGZ1bmN0aW9uOyB1cGRhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RnVuYykge1xuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VXJsRnVuYyhyZXEsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAvLyBSZWRpcmVjdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlZGlyZWN0KGxvY2F0aW9uKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgMCwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyBUaGluZ3Mgd29uJ3QgZ2V0IGFueSBiZXR0ZXIgb24gYW5vdGhlciBhdHRlbXB0OyBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5RnVuYyA9PSBudWxsIHx8IChhd2FpdCB0aGlzLnJldHJ5RnVuYyhyZXEsIHJlc3BvbnNlLCBhdHRlbXB0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBieSBzZW5kaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgIT0gbnVsbCwgXCJyZXF1ZXN0IGhhcyBub3QgYmVlbiBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5jYW5jZWxcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKCFzaWduYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGZXRjaFJlcXVlc3RdXSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZGlyZWN0aW9uXG4gICAgICogIHRvICUlbG9jYXRpb24lJS5cbiAgICAgKi9cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRpb25zXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYXRpb24uc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJlZGlyZWN0aW5nOlxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcbiAgICAgICAgLy8gLSBkb3duZ3JhZGluZyB0aGUgc2VjdXJpdHkgKGUuZy4gaHR0cHMgPT4gaHR0cClcbiAgICAgICAgLy8gLSB0byBub24tSFRUUCAob3Igbm9uLUhUVFBTKSBwcm90b2NvbHMgW3RoaXMgY291bGQgYmUgcmVsYXhlZD9dXG4gICAgICAgIGFzc2VydCh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAoY3VycmVudCAhPT0gXCJodHRwc1wiIHx8IHRhcmdldCAhPT0gXCJodHRwXCIpICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM/Oi8pLCBgdW5zdXBwb3J0ZWQgcmVkaXJlY3RgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGByZWRpcmVjdCgke3RoaXMubWV0aG9kfSAke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gPT4gJHtKU09OLnN0cmluZ2lmeShsb2NhdGlvbil9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0LCB3aXRoIGEgbmV3IFVSTFxuICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KGxvY2F0aW9uKTtcbiAgICAgICAgcmVxLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIHJlcS5hbGxvd0d6aXAgPSB0aGlzLmFsbG93R3ppcDtcbiAgICAgICAgcmVxLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHJlcS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgcmVxLiNib2R5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBEbyBub3QgZm9yd2FyZCBjcmVkZW50aWFscyB1bmxlc3Mgb24gdGhlIHNhbWUgZG9tYWluOyBvbmx5IGFic29sdXRlXG4gICAgICAgIC8vcmVxLmFsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgLy8gcGF0aHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ7IG1heSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgdG8gZm9yd2FyZD9cbiAgICAgICAgLy9zZXRTdG9yZShyZXEuI3Byb3BzLCBcImNyZWRzXCIsIGdldFN0b3JlKHRoaXMuI3Byb3MsIFwiY3JlZHNcIikpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhpcyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBGZXRjaFJlcXVlc3QodGhpcy51cmwpO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgbWV0aG9kXCIgKGkuZS4gbnVsbClcbiAgICAgICAgY2xvbmUuI21ldGhvZCA9IHRoaXMuI21ldGhvZDtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGJvZHlcIiB3aXRoIHR5cGUsIGNvcHlpbmcgdGhlIFVpbnQ4QXJyYXkgaXMgcHJlc2VudFxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgY2xvbmUuI2JvZHkgPSB0aGlzLiNib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgaGVhZGVyc1wiXG4gICAgICAgIGNsb25lLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIC8vIENyZWRlbnRpYWxzIGlzIHJlYWRvbmx5LCBzbyB3ZSBjb3B5IGludGVybmFsbHlcbiAgICAgICAgY2xvbmUuI2NyZWRzID0gdGhpcy4jY3JlZHM7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICBpZiAodGhpcy5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI3ByZWZsaWdodCA9IHRoaXMuI3ByZWZsaWdodDtcbiAgICAgICAgY2xvbmUuI3Byb2Nlc3MgPSB0aGlzLiNwcm9jZXNzO1xuICAgICAgICBjbG9uZS4jcmV0cnkgPSB0aGlzLiNyZXRyeTtcbiAgICAgICAgY2xvbmUuI3Rocm90dGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jdGhyb3R0bGUpO1xuICAgICAgICBjbG9uZS4jZ2V0VXJsRnVuYyA9IHRoaXMuI2dldFVybEZ1bmM7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIExvY2tzIGFsbCBzdGF0aWMgY29uZmlndXJhdGlvbiBmb3IgZ2F0ZXdheXMgYW5kIEZldGNoR2V0VXJsRnVuY1xuICAgICAqICByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGxvY2tDb25maWcoKSB7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2F0ZXdheShzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHYXRld2F5KHNjaGVtZSwgZnVuYykge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGludGVyY2VwdCAke3NjaGVtZX07IHVzZSByZWdpc3RlckdldFVybGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdldFVybChnZXRVcmwpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRHZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGdldFVybCBmdW5jdGlvbiB0aGF0IGZldGNoZXMgY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMuXG4gICAgICpcbiAgICAgKiAgVGhlIGF2YWlsYWJsZSAlJW9wdGlvbnMlJSBhcmUgZGVwZW5kZW50IG9uIHRoZSBwbGF0Zm9ybVxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IGlzIHVzZWZ1bFxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcbiAgICAgKiAgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVHZXRVcmwob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gXCJmZXRjaFwiIGRhdGEgVVJJcy5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XG4gICAgICogIGRhdGEgVVJJcywgc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWdpc3RlciBpdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XG4gICAgICogIGJlIHVzZWZ1bCBpbiBhIHdyYXBwZXIgdG8gcGVyZm9tIGN1c3RvbSBkYXRhIFVSSSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFHYXRld2F5RnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZmV0Y2ggSVBGUyAodW52YWxpZGF0ZWQpIGZyb21cbiAgICAgKiAgYSBjdXN0b20gZ2F0ZXdheSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IElQRlMgZ2F0ZXdheSB1c2VkIGludGVybmFsbHkgaXNcbiAgICAgKiAgYGBcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cImBgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpO1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFRoZSByZXNwb25zZSBmb3IgYSBGZXRjaFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcbiAgICAjc3RhdHVzQ29kZTtcbiAgICAjc3RhdHVzTWVzc2FnZTtcbiAgICAjaGVhZGVycztcbiAgICAjYm9keTtcbiAgICAjcmVxdWVzdDtcbiAgICAjZXJyb3I7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVzcG9uc2Ugc3RhdHVzPSR7dGhpcy5zdGF0dXNDb2RlfSBib2R5PSR7dGhpcy4jYm9keSA/IGhleGxpZnkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c0NvZGU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNNZXNzYWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzTWVzc2FnZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgaGVhZGVycy4gQWxsIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgb3IgYGBudWxsYGAgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5IGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcsIG9yIHRoZSBlbXB0eVxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIFVURi04IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGJvZHlUZXh0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keVRleHRcIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBKU09OLWVuY29kZWQgZGF0YVxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keUpzb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keUpzb25cIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5LCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjdW0sIGspID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2sudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcoaGVhZGVyc1trXSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy4jYm9keSA9ICgoYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShib2R5KSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy4jZXJyb3IgPSB7IG1lc3NhZ2U6IFwiXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcgaGVhZGVycyBhbmQgYm9keSwgYnV0IHdpdGhcbiAgICAgKiAgYW4gZXJyb3Igc3RhdHVzIGNvZGUgKGkuZS4gNTk5KSBhbmQgJSVtZXNzYWdlJSUgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXG4gICAgICovXG4gICAgbWFrZVNlcnZlckVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIHN0YXR1c01lc3NhZ2UsIHRoaXMuaGVhZGVycywgdGhpcy5ib2R5LCB0aGlzLiNyZXF1ZXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgY2FsbGVkIHdpdGhpbiBhIFtyZXF1ZXN0LnByb2Nlc3NGdW5jXShGZXRjaFJlcXVlc3QtcHJvY2Vzc0Z1bmMpXG4gICAgICogIGNhbGwsIGNhdXNlcyB0aGUgcmVxdWVzdCB0byByZXRyeSBhcyBpZiB0aHJvdHRsZWQgZm9yICUlc3RhbGwlJVxuICAgICAqICBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGhyb3dUaHJvdHRsZUVycm9yKG1lc3NhZ2UsIHN0YWxsKSB7XG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFsbCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFsbCkgJiYgc3RhbGwgPj0gMCwgXCJpbnZhbGlkIHN0YWxsIHRpbWVvdXRcIiwgXCJzdGFsbFwiLCBzdGFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc3RhbGwsIHRocm90dGxlOiB0cnVlIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlcXVlc3QgbWFkZSBmb3IgdGhpcyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHsgcmV0dXJuIHRoaXMuI3JlcXVlc3Q7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cbiAgICAgKi9cbiAgICBhc3NlcnRPaygpIHtcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgc2VydmVyIHJlc3BvbnNlICR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0VXJsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdFVybCA9IHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlQm9keSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogKHRoaXMucmVxdWVzdCB8fCBcInVua25vd24gcmVxdWVzdFwiKSwgcmVzcG9uc2U6IHRoaXMsIGVycm9yLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVN0YXR1czogYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/geturl-browser.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/geturl-browser.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: () => (/* binding */ createGetUrl),\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction createGetUrl(options) {\n    async function getUrl(req, _signal) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        let error = null;\n        const controller = new AbortController();\n        const timer = setTimeout(() => {\n            error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request timeout\", \"TIMEOUT\");\n            controller.abort();\n        }, req.timeout);\n        if (_signal) {\n            _signal.addListener(() => {\n                error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request cancelled\", \"CANCELLED\");\n                controller.abort();\n            });\n        }\n        const init = Object.assign({}, options, {\n            method: req.method,\n            headers: new Headers(Array.from(req)),\n            body: req.body || undefined,\n            signal: controller.signal\n        });\n        let resp;\n        try {\n            resp = await fetch(req.url, init);\n        }\n        catch (_error) {\n            clearTimeout(timer);\n            if (error) {\n                throw error;\n            }\n            throw _error;\n        }\n        clearTimeout(timer);\n        const headers = {};\n        resp.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n        const respBody = await resp.arrayBuffer();\n        const body = (respBody == null) ? null : new Uint8Array(respBody);\n        return {\n            statusCode: resp.status,\n            statusMessage: resp.statusText,\n            headers, body\n        };\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\nasync function getUrl(req, _signal) {\n    return defaultGetUrl(req, _signal);\n}\n//# sourceMappingURL=geturl-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEO0FBQ3pDO0FBQ1A7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxRQUFRLGtEQUFNLHNFQUFzRSxTQUFTO0FBQzdGLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsU0FBUztBQUNULFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVM7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIscUNBQXFDO0FBQzlCO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwtYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIG1ha2VFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xuICAgICAgICBhc3NlcnQoX3NpZ25hbCA9PSBudWxsIHx8ICFfc2lnbmFsLmNhbmNlbGxlZCwgXCJyZXF1ZXN0IGNhbmNlbGxlZCBiZWZvcmUgc2VuZGluZ1wiLCBcIkNBTkNFTExFRFwiKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIGluZm86IHsgcHJvdG9jb2wgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8ICFyZXEuY3JlZGVudGlhbHMgfHwgcmVxLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiwgXCJpbnNlY3VyZSBhdXRob3JpemVkIGNvbm5lY3Rpb25zIHVuc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlcnJvciA9IG1ha2VFcnJvcihcInJlcXVlc3QgdGltZW91dFwiLCBcIlRJTUVPVVRcIik7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0sIHJlcS50aW1lb3V0KTtcbiAgICAgICAgaWYgKF9zaWduYWwpIHtcbiAgICAgICAgICAgIF9zaWduYWwuYWRkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIik7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKEFycmF5LmZyb20ocmVxKSksXG4gICAgICAgICAgICBib2R5OiByZXEuYm9keSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBfZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICByZXNwLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BCb2R5ID0gYXdhaXQgcmVzcC5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVycywgYm9keVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VXJsO1xufVxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbmNvbnN0IGRlZmF1bHRHZXRVcmwgPSBjcmVhdGVHZXRVcmwoe30pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/geturl-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjLHdDQUF3QyxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQixZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBYyxtQ0FBbUMsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTSxxREFBcUQsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaURBQU8sQ0FBQyxxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL21hdGhzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgbWF0aGVtYXRpYyBvcGVyYXRpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpNYXRoIEhlbHBlcnMgIFthYm91dC1tYXRoc11cbiAqL1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbi8vY29uc3QgQk5fTWF4MjU2ID0gKEJOXzEgPDwgQmlnSW50KDI1NikpIC0gQk5fMTtcbi8vIElFRUUgNzU0IHN1cHBvcnQgNTMtYml0cyBvZiBtYW50aXNzYVxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgZnJvbSBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZiAlJXdpZHRoJSVcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cbiAqXG4gKiAgSWYgdGhlIGhpZ2hlc3QgYml0IGlzIGBgMWBgLCB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgYXNzZXJ0KCh2YWx1ZSA+PiB3aWR0aCkgPT09IEJOXzAsIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImZyb21Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICB9KTtcbiAgICAvLyBUb3AgYml0IHNldDsgdHJlYXQgYXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZSA+PiAod2lkdGggLSBCTl8xKSkge1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuIC0oKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgdG8gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2ZcbiAqICAlJXdpZHRoJSUgYml0cy5cbiAqXG4gKiAgVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBwb3NpdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDw9IGxpbWl0LCBcInRvbyBsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnQodmFsdWUgPCBsaW1pdCwgXCJ0b28gaGlnaFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBNYXNrICUldmFsdWUlJSB3aXRoIGEgYml0bWFzayBvZiAlJWJpdHMlJSBvbmVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFzayhfdmFsdWUsIF9iaXRzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCBiaXRzID0gQmlnSW50KGdldE51bWJlcihfYml0cywgXCJiaXRzXCIpKTtcbiAgICByZXR1cm4gdmFsdWUgJiAoKEJOXzEgPDwgYml0cykgLSBCTl8xKTtcbn1cbi8qKlxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSBCaWdJbnQsIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCaWdJbnQodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjogcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBCaWdOdW1iZXJpc2ggc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJpZ051bWJlcmlzaCB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcbiAqICB2YWx1ZSBhbmQgdGhhdCBpdCBpcyBwb3NpdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpbnQodmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRCaWdJbnQodmFsdWUsIG5hbWUpO1xuICAgIGFzc2VydChyZXN1bHQgPj0gQk5fMCwgXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgb3BlcmF0aW9uOiBcImdldFVpbnRcIiwgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgTmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLypcbiAqIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZ0ludC4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4MFwiO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ICYgMHgwZl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKTtcbn1cbi8qKlxuICogIEdldHMgYSAvL251bWJlci8vIGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgLy9udW1iZXIvLywgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKEJpZ0ludCh2YWx1ZSksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgbnVtZXJpYyBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbnVtZXJpYyB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgbnVtYmVyLiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0TnVtYmVyKHRvQmlnSW50KHZhbHVlKSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIGhleHN0cmluZywgb3B0aW9uYWxseSBwYWRkZWQgdG9cbiAqICAlJXdpZHRoJSUgYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlSGV4KF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChfd2lkdGggPT0gbnVsbCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHZhbHVlIGlzIG9mIGV2ZW4gbGVuZ3RoXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKTtcbiAgICAgICAgYXNzZXJ0KHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYnl0ZXMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGlmICh2YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0hleFN0cmluZ11dIGZvciAlJXZhbHVlJSUgc2FmZSB0byB1c2UgYXMgYSAvL1F1YW50aXR5Ly8uXG4gKlxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xuICogIHRoZSBsaXRlcmFsIHZhbHVlIGAweDBgLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCBmb3IgSlNTT04tUlBDXG4gKiAgbnVtZXJpYyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1F1YW50aXR5KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGhleGxpZnkoaXNCeXRlc0xpa2UodmFsdWUpID8gdmFsdWUgOiB0b0JlQXJyYXkodmFsdWUpKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/maths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nasync function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nfunction defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMENBQTBDO0FBQ3ZGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nfunction decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvQztBQUNpQjtBQUNoQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLElBQUksa0RBQU07QUFDVjtBQUNBLEtBQUs7QUFDTDtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTztBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQU87QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsa0RBQVE7QUFDekI7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3Jvb3QvdW5pdmVyc2FsLWZoZXZtLXNkay9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGFzc2VydChjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICBhc3NlcnQob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-decode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */\nfunction encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\n//# sourceMappingURL=rlp-encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3FDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0RBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcnNANi4xNS4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRCeXRlcyhvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmxwKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChjb25zdCB2IG9mIF9lbmNvZGUob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ID4+IDRdO1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/rlp-encode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\n\n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            }\n            else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (str) === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && ((c2 & 0xfc00) === 0xdc00), \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJzQDYuMTUuMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ3lCO0FBQzlEO0FBQ0EsSUFBSSwwREFBYyx1Q0FBdUMsU0FBUyxFQUFFLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWM7QUFDbEI7QUFDQSxRQUFRLDJEQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyc0A2LjE1LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V0ZjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChzdHIpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nIHZhbHVlXCIsIFwic3RyXCIsIHN0cik7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpIDwgc3RyLmxlbmd0aCAmJiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSwgXCJpbnZhbGlkIHN1cnJvZ2F0ZSBwYWlyXCIsIFwic3RyXCIsIHN0cik7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbjtcbi8vZXhwb3J0IFxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxuICpcbiAqICBXaGVuICUlb25FcnJvciUlIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgY2FsbGVkIG9uIFVURi04XG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Froot%2Funiversal-fhevm-sdk%2Fpackages%2Fnextjs-demo%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Froot%2Funiversal-fhevm-sdk%2Fpackages%2Fnextjs-demo%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4yLjVfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRnJvb3QlMkZ1bml2ZXJzYWwtZmhldm0tc2RrJTJGcGFja2FnZXMlMkZuZXh0anMtZGVtbyUyRnNyYyUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOEpBQW9HIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL3BhY2thZ2VzL25leHRqcy1kZW1vL3NyYy9hcHAvcGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Froot%2Funiversal-fhevm-sdk%2Fpackages%2Fnextjs-demo%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \***********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          },\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        Error(\"react-stack-top-frame\"),\n        createTask(getTaskName(type))\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4yLjVfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxTEFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTUuMi41X3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpLFxuICAgICAgICBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKVxuICAgICAgKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4yLjVfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsNlFBQXNFO0FBQ3hFIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjIuNV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fhevm-sdk-core/dist/index.js":
/*!***************************************!*\
  !*** ../fhevm-sdk-core/dist/index.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFHEVM: () => (/* binding */ createFHEVM)\n/* harmony export */ });\n// packages/fhevm-sdk-core/src/index.ts\nasync function createFHEVM(config) {\n    console.log(\"🧠 Initializing FHEVM SDK with config:\", config);\n    // 模拟异步初始化（可以未来接实际 RPC）\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"✅ FHEVM SDK initialized\");\n    // 返回带有加密与解密功能的对象\n    return {\n        encryptUint32 (value) {\n            // 模拟加密逻辑\n            const encryptedValue = \"enc_\".concat(value, \"_\").concat(Math.random().toString(36).substring(2, 8));\n            const proof = \"proof_\".concat(Date.now());\n            return {\n                encryptedValue,\n                proof\n            };\n        },\n        decryptUint32 (encryptedValue, proof) {\n            console.log(\"🔓 decrypt called:\", encryptedValue, proof);\n            try {\n                const parts = encryptedValue.split(\"_\");\n                return Number(parts[1]) || 0;\n            } catch (err) {\n                console.error(\"解密失败:\", err);\n                return 0;\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9maGV2bS1zZGstY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx1Q0FBdUM7QUFDaEMsZUFBZUEsWUFBWUMsTUFBTTtJQUNwQ0MsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ0Y7SUFDdEQsdUJBQXVCO0lBQ3ZCLE1BQU0sSUFBSUcsUUFBUSxDQUFDQyxVQUFZQyxXQUFXRCxTQUFTO0lBQ25ESCxRQUFRQyxHQUFHLENBQUM7SUFDWixpQkFBaUI7SUFDakIsT0FBTztRQUNISSxlQUFjQyxLQUFLO1lBQ2YsU0FBUztZQUNULE1BQU1DLGlCQUFpQixPQUFnQkMsT0FBVEYsT0FBTSxLQUE4QyxPQUEzQ0UsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUc7WUFDL0UsTUFBTUMsUUFBUSxTQUFvQixPQUFYQyxLQUFLQyxHQUFHO1lBQy9CLE9BQU87Z0JBQUVQO2dCQUFnQks7WUFBTTtRQUNuQztRQUNBRyxlQUFjUixjQUFjLEVBQUVLLEtBQUs7WUFDL0JaLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JNLGdCQUFnQks7WUFDbEQsSUFBSTtnQkFDQSxNQUFNSSxRQUFRVCxlQUFlVSxLQUFLLENBQUM7Z0JBQ25DLE9BQU9DLE9BQU9GLEtBQUssQ0FBQyxFQUFFLEtBQUs7WUFDL0IsRUFDQSxPQUFPRyxLQUFLO2dCQUNSbkIsUUFBUW9CLEtBQUssQ0FBQyxTQUFTRDtnQkFDdkIsT0FBTztZQUNYO1FBQ0o7SUFDSjtBQUNKIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL3BhY2thZ2VzL2ZoZXZtLXNkay1jb3JlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvZmhldm0tc2RrLWNvcmUvc3JjL2luZGV4LnRzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRkhFVk0oY29uZmlnKSB7XG4gICAgY29uc29sZS5sb2coXCLwn6egIEluaXRpYWxpemluZyBGSEVWTSBTREsgd2l0aCBjb25maWc6XCIsIGNvbmZpZyk7XG4gICAgLy8g5qih5ouf5byC5q2l5Yid5aeL5YyW77yI5Y+v5Lul5pyq5p2l5o6l5a6e6ZmFIFJQQ++8iVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgIGNvbnNvbGUubG9nKFwi4pyFIEZIRVZNIFNESyBpbml0aWFsaXplZFwiKTtcbiAgICAvLyDov5Tlm57luKbmnInliqDlr4bkuI7op6Plr4blip/og73nmoTlr7nosaFcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0VWludDMyKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyDmqKHmi5/liqDlr4bpgLvovpFcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZFZhbHVlID0gYGVuY18ke3ZhbHVlfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KX1gO1xuICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBgcHJvb2ZfJHtEYXRlLm5vdygpfWA7XG4gICAgICAgICAgICByZXR1cm4geyBlbmNyeXB0ZWRWYWx1ZSwgcHJvb2YgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdFVpbnQzMihlbmNyeXB0ZWRWYWx1ZSwgcHJvb2YpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UkyBkZWNyeXB0IGNhbGxlZDpcIiwgZW5jcnlwdGVkVmFsdWUsIHByb29mKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBlbmNyeXB0ZWRWYWx1ZS5zcGxpdChcIl9cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihwYXJ0c1sxXSkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi6Kej5a+G5aSx6LSlOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRkhFVk0iLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZW5jcnlwdFVpbnQzMiIsInZhbHVlIiwiZW5jcnlwdGVkVmFsdWUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJwcm9vZiIsIkRhdGUiLCJub3ciLCJkZWNyeXB0VWludDMyIiwicGFydHMiLCJzcGxpdCIsIk51bWJlciIsImVyciIsImVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fhevm-sdk-core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fhevm-sdk-react/dist/FHEVMProvider.js":
/*!************************************************!*\
  !*** ../fhevm-sdk-react/dist/FHEVMProvider.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FHEVMContext: () => (/* binding */ FHEVMContext),\n/* harmony export */   FHEVMProvider: () => (/* binding */ FHEVMProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useFHEVM: () => (/* binding */ useFHEVM)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fhevm_sdk_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fhevm/sdk-core */ \"(app-pages-browser)/../fhevm-sdk-core/dist/index.js\");\n/* harmony import */ var _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/detect-provider */ \"(app-pages-browser)/../../node_modules/.pnpm/@metamask+detect-provider@2.0.0/node_modules/@metamask/detect-provider/dist/index.js\");\n/* harmony import */ var _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_metamask_detect_provider__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ FHEVMContext,FHEVMProvider,useFHEVM,default auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst FHEVMContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * 🚀 Provider：初始化 FHEVM SDK 并注入 Context\n */ function FHEVMProvider(param) {\n    let { children } = param;\n    _s();\n    const [fhevm, setFhevm] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [account, setAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [chainId, setChainId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(11155111); // 默认 Sepolia\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FHEVMProvider.useEffect\": ()=>{\n            async function init() {\n                try {\n                    console.log(\"🔍 检查钱包中...\");\n                    const provider = await _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_2___default()();\n                    if (!provider) {\n                        alert(\"❌ 未检测到钱包插件，请安装 MetaMask！\");\n                        return;\n                    }\n                    console.log(\"🔗 正在请求连接钱包...\");\n                    const accounts = await provider.request({\n                        method: \"eth_requestAccounts\"\n                    });\n                    const network = await provider.request({\n                        method: \"eth_chainId\"\n                    });\n                    const chainNum = parseInt(network, 16);\n                    console.log(\"✅ 钱包已连接:\", accounts[0]);\n                    console.log(\"🌐 当前网络:\", chainNum);\n                    setAccount(accounts[0]);\n                    setChainId(chainNum);\n                    console.log(\"🚀 初始化 FHEVM SDK...\");\n                    const instance = await (0,_fhevm_sdk_core__WEBPACK_IMPORTED_MODULE_3__.createFHEVM)({\n                        chainId: chainNum,\n                        rpcUrl: \"https://rpc.sepolia.org\",\n                        contractAddress: \"0x9F8069282814a1177C1f6b8D7d8f7cC11A663554\"\n                    });\n                    console.log(\"✅ FHEVM SDK 初始化成功\");\n                    setFhevm(instance);\n                } catch (err) {\n                    console.error(\"❌ FHEVMProvider 初始化失败:\", err);\n                }\n            }\n            init();\n        }\n    }[\"FHEVMProvider.useEffect\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FHEVMContext.Provider, {\n        value: {\n            fhevm,\n            account,\n            chainId\n        },\n        children: children\n    });\n}\n_s(FHEVMProvider, \"TwU71cdpKdHcwV7aOQwsg0wVqb4=\");\n_c = FHEVMProvider;\n/**\n * ⚡ Hook：提供 SDK 实例、账户与链信息\n */ function useFHEVM() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(FHEVMContext);\n    if (!context) {\n        throw new Error(\"useFHEVM must be used within a FHEVMProvider\");\n    }\n    return context;\n}\n_s1(useFHEVM, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FHEVMProvider);\nvar _c;\n$RefreshReg$(_c, \"FHEVMProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9maGV2bS1zZGstcmVhY3QvZGlzdC9GSEVWTVByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ2dEO0FBQ3VCO0FBQ3pCO0FBQ2lCO0FBQ3hELE1BQU1RLDZCQUFlTixvREFBYUEsQ0FBQyxNQUFNO0FBQ2hEOztDQUVDLEdBQ00sU0FBU08sY0FBYyxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQzFCLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUiwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNLENBQUNTLFNBQVNDLFdBQVcsR0FBR1YsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDVyxTQUFTQyxXQUFXLEdBQUdaLCtDQUFRQSxDQUFDLFdBQVcsYUFBYTtJQUMvREMsZ0RBQVNBO21DQUFDO1lBQ04sZUFBZVk7Z0JBQ1gsSUFBSTtvQkFDQUMsUUFBUUMsR0FBRyxDQUFDO29CQUNaLE1BQU1DLFdBQVcsTUFBTWIsZ0VBQXNCQTtvQkFDN0MsSUFBSSxDQUFDYSxVQUFVO3dCQUNYQyxNQUFNO3dCQUNOO29CQUNKO29CQUNBSCxRQUFRQyxHQUFHLENBQUM7b0JBQ1osTUFBTUcsV0FBVyxNQUFNRixTQUFTRyxPQUFPLENBQUM7d0JBQUVDLFFBQVE7b0JBQXNCO29CQUN4RSxNQUFNQyxVQUFVLE1BQU1MLFNBQVNHLE9BQU8sQ0FBQzt3QkFBRUMsUUFBUTtvQkFBYztvQkFDL0QsTUFBTUUsV0FBV0MsU0FBU0YsU0FBUztvQkFDbkNQLFFBQVFDLEdBQUcsQ0FBQyxZQUFZRyxRQUFRLENBQUMsRUFBRTtvQkFDbkNKLFFBQVFDLEdBQUcsQ0FBQyxZQUFZTztvQkFDeEJaLFdBQVdRLFFBQVEsQ0FBQyxFQUFFO29CQUN0Qk4sV0FBV1U7b0JBQ1hSLFFBQVFDLEdBQUcsQ0FBQztvQkFDWixNQUFNUyxXQUFXLE1BQU10Qiw0REFBV0EsQ0FBQzt3QkFDL0JTLFNBQVNXO3dCQUNURyxRQUFRO3dCQUNSQyxpQkFBaUI7b0JBQ3JCO29CQUNBWixRQUFRQyxHQUFHLENBQUM7b0JBQ1pQLFNBQVNnQjtnQkFDYixFQUNBLE9BQU9HLEtBQUs7b0JBQ1JiLFFBQVFjLEtBQUssQ0FBQywwQkFBMEJEO2dCQUM1QztZQUNKO1lBQ0FkO1FBQ0o7a0NBQUcsRUFBRTtJQUNMLE9BQVFoQixzREFBSUEsQ0FBQ08sYUFBYXlCLFFBQVEsRUFBRTtRQUFFQyxPQUFPO1lBQUV2QjtZQUFPRTtZQUFTRTtRQUFRO1FBQUdMLFVBQVVBO0lBQVM7QUFDakc7R0FyQ2dCRDtLQUFBQTtBQXNDaEI7O0NBRUMsR0FDTSxTQUFTMEI7O0lBQ1osTUFBTUMsVUFBVWpDLGlEQUFVQSxDQUFDSztJQUMzQixJQUFJLENBQUM0QixTQUFTO1FBQ1YsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0Q7QUFDWDtJQU5nQkQ7QUFPaEIsaUVBQWUxQixhQUFhQSxFQUFDIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL3BhY2thZ2VzL2ZoZXZtLXNkay1yZWFjdC9kaXN0L0ZIRVZNUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlRkhFVk0gfSBmcm9tIFwiQGZoZXZtL3Nkay1jb3JlXCI7XG5pbXBvcnQgZGV0ZWN0RXRoZXJldW1Qcm92aWRlciBmcm9tIFwiQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlclwiO1xuZXhwb3J0IGNvbnN0IEZIRVZNQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIPCfmoAgUHJvdmlkZXLvvJrliJ3lp4vljJYgRkhFVk0gU0RLIOW5tuazqOWFpSBDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGSEVWTVByb3ZpZGVyKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IFtmaGV2bSwgc2V0Rmhldm1dID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2FjY291bnQsIHNldEFjY291bnRdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2NoYWluSWQsIHNldENoYWluSWRdID0gdXNlU3RhdGUoMTExNTUxMTEpOyAvLyDpu5jorqQgU2Vwb2xpYVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSDmo4Dmn6XpkrHljIXkuK0uLi5cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIuKdjCDmnKrmo4DmtYvliLDpkrHljIXmj5Lku7bvvIzor7flronoo4UgTWV0YU1hc2vvvIFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SXIOato+WcqOivt+axgui/nuaOpemSseWMhS4uLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5OdW0gPSBwYXJzZUludChuZXR3b3JrLCAxNik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUg6ZKx5YyF5bey6L+e5o6lOlwiLCBhY2NvdW50c1swXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn4yQIOW9k+WJjee9kee7nDpcIiwgY2hhaW5OdW0pO1xuICAgICAgICAgICAgICAgIHNldEFjY291bnQoYWNjb3VudHNbMF0pO1xuICAgICAgICAgICAgICAgIHNldENoYWluSWQoY2hhaW5OdW0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+agCDliJ3lp4vljJYgRkhFVk0gU0RLLi4uXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgY3JlYXRlRkhFVk0oe1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbk51bSxcbiAgICAgICAgICAgICAgICAgICAgcnBjVXJsOiBcImh0dHBzOi8vcnBjLnNlcG9saWEub3JnXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogXCIweDlGODA2OTI4MjgxNGExMTc3QzFmNmI4RDdkOGY3Y0MxMUE2NjM1NTRcIiwgLy8g4pyFIOecn+WunuWQiOe6plxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIEZIRVZNIFNESyDliJ3lp4vljJbmiJDlip9cIik7XG4gICAgICAgICAgICAgICAgc2V0Rmhldm0oaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRkhFVk1Qcm92aWRlciDliJ3lp4vljJblpLHotKU6XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdCgpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKF9qc3goRkhFVk1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGZoZXZtLCBhY2NvdW50LCBjaGFpbklkIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIOKaoSBIb29r77ya5o+Q5L6bIFNESyDlrp7kvovjgIHotKbmiLfkuI7pk77kv6Hmga9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZIRVZNKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEZIRVZNQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZUZIRVZNIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBGSEVWTVByb3ZpZGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmV4cG9ydCBkZWZhdWx0IEZIRVZNUHJvdmlkZXI7XG4iXSwibmFtZXMiOlsianN4IiwiX2pzeCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVGSEVWTSIsImRldGVjdEV0aGVyZXVtUHJvdmlkZXIiLCJGSEVWTUNvbnRleHQiLCJGSEVWTVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJmaGV2bSIsInNldEZoZXZtIiwiYWNjb3VudCIsInNldEFjY291bnQiLCJjaGFpbklkIiwic2V0Q2hhaW5JZCIsImluaXQiLCJjb25zb2xlIiwibG9nIiwicHJvdmlkZXIiLCJhbGVydCIsImFjY291bnRzIiwicmVxdWVzdCIsIm1ldGhvZCIsIm5ldHdvcmsiLCJjaGFpbk51bSIsInBhcnNlSW50IiwiaW5zdGFuY2UiLCJycGNVcmwiLCJjb250cmFjdEFkZHJlc3MiLCJlcnIiLCJlcnJvciIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VGSEVWTSIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fhevm-sdk-react/dist/FHEVMProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fhevm-sdk-react/dist/index.js":
/*!****************************************!*\
  !*** ../fhevm-sdk-react/dist/index.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FHEVMContext: () => (/* reexport safe */ _FHEVMProvider__WEBPACK_IMPORTED_MODULE_0__.FHEVMContext),\n/* harmony export */   FHEVMProvider: () => (/* reexport safe */ _FHEVMProvider__WEBPACK_IMPORTED_MODULE_0__.FHEVMProvider),\n/* harmony export */   useFHEVM: () => (/* reexport safe */ _FHEVMProvider__WEBPACK_IMPORTED_MODULE_0__.useFHEVM)\n/* harmony export */ });\n/* harmony import */ var _FHEVMProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FHEVMProvider */ \"(app-pages-browser)/../fhevm-sdk-react/dist/FHEVMProvider.js\");\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9maGV2bS1zZGstcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ2UiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvcGFja2FnZXMvZmhldm0tc2RrLXJlYWN0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vRkhFVk1Qcm92aWRlclwiO1xuZXhwb3J0IHsgRkhFVk1Db250ZXh0IH0gZnJvbSBcIi4vRkhFVk1Qcm92aWRlclwiO1xuIl0sIm5hbWVzIjpbIkZIRVZNQ29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fhevm-sdk-react/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Page)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Home__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Home */ \"(app-pages-browser)/./src/components/Home.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n/**\n * 页面入口\n * ✅ 确保 Home 在 Providers 包裹的上下文中执行\n */ function Page() {\n    console.log(\"📄 Page mounted (client)\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Home__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/app/page.tsx\",\n        lineNumber: 11,\n        columnNumber: 10\n    }, this);\n}\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQzBCO0FBQ1k7QUFFdEM7OztDQUdDLEdBQ2MsU0FBU0U7SUFDdEJDLFFBQVFDLEdBQUcsQ0FBQztJQUNaLHFCQUFPLDhEQUFDSCx3REFBSUE7Ozs7O0FBQ2Q7S0FId0JDIiwic291cmNlcyI6WyIvcm9vdC91bml2ZXJzYWwtZmhldm0tc2RrL3BhY2thZ2VzL25leHRqcy1kZW1vL3NyYy9hcHAvcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgSG9tZSBmcm9tIFwiLi4vY29tcG9uZW50cy9Ib21lXCI7XG5cbi8qKlxuICog6aG16Z2i5YWl5Y+jXG4gKiDinIUg56Gu5L+dIEhvbWUg5ZyoIFByb3ZpZGVycyDljIXoo7nnmoTkuIrkuIvmlofkuK3miafooYxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSgpIHtcbiAgY29uc29sZS5sb2coXCLwn5OEIFBhZ2UgbW91bnRlZCAoY2xpZW50KVwiKTtcbiAgcmV0dXJuIDxIb21lIC8+O1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiSG9tZSIsIlBhZ2UiLCJjb25zb2xlIiwibG9nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Home.tsx":
/*!*********************************!*\
  !*** ./src/components/Home.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fhevm_sdk_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fhevm/sdk-react */ \"(app-pages-browser)/../fhevm-sdk-react/dist/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst Home = ()=>{\n    _s();\n    // ======== 状态变量 ========\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [provider, setProvider] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [amount, setAmount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [encryptedAmount, setEncryptedAmount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [sdkReady, setSdkReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // ======== SDK 实例 ========\n    const fhevm = (0,_fhevm_sdk_react__WEBPACK_IMPORTED_MODULE_2__.useFHEVM)();\n    // ======== 初始化检查 ========\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (fhevm) {\n                console.log(\"✅ FHEVM SDK 已初始化:\", fhevm);\n                console.dir(fhevm);\n                console.log(\"🔑 可用的键:\", Object.keys(fhevm));\n                setSdkReady(true);\n            } else {\n                console.warn(\"⚠️ FHEVM SDK 尚未初始化\");\n            }\n        }\n    }[\"Home.useEffect\"], [\n        fhevm\n    ]);\n    // ======== 钱包连接 ========\n    const connectWallet = async ()=>{\n        if (typeof window.ethereum === \"undefined\") {\n            alert(\"请先安装 MetaMask 或其他以太坊钱包扩展！\");\n            return;\n        }\n        try {\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.BrowserProvider(window.ethereum);\n            await provider.send(\"eth_requestAccounts\", []);\n            const signer = await provider.getSigner();\n            const address = await signer.getAddress();\n            setProvider(provider);\n            setWalletAddress(address);\n            console.log(\"🦊 钱包已连接:\", address);\n        } catch (err) {\n            console.error(\"❌ 钱包连接失败:\", err);\n        }\n    };\n    // ======== 加密金额 ========\n    const handleEncrypt = ()=>{\n        if (!sdkReady) return alert(\"FHEVM SDK 尚未准备好，请稍等！\");\n        if (!amount || amount <= 0) return alert(\"请输入一个有效的数字\");\n        try {\n            var _fhevm_fhevm, _fhevm_fhevm_encryptor, _fhevm_fhevm1;\n            // 👇 自动检测正确的加密函数位置\n            const encryptFn = (fhevm === null || fhevm === void 0 ? void 0 : (_fhevm_fhevm = fhevm.fhevm) === null || _fhevm_fhevm === void 0 ? void 0 : _fhevm_fhevm.encryptUint32) || (fhevm === null || fhevm === void 0 ? void 0 : (_fhevm_fhevm1 = fhevm.fhevm) === null || _fhevm_fhevm1 === void 0 ? void 0 : (_fhevm_fhevm_encryptor = _fhevm_fhevm1.encryptor) === null || _fhevm_fhevm_encryptor === void 0 ? void 0 : _fhevm_fhevm_encryptor.encryptUint32) || (fhevm === null || fhevm === void 0 ? void 0 : fhevm.encryptUint32);\n            if (!encryptFn) {\n                console.error(\"❌ 未找到 encryptUint32 方法，fhevm 结构如下:\", fhevm);\n                alert(\"SDK 中未找到 encryptUint32 方法，请查看控制台日志！\");\n                return;\n            }\n            const { encryptedValue, proof } = encryptFn(amount);\n            console.log(\"🔐 加密结果:\", encryptedValue);\n            console.log(\"🧾 加密证明:\", proof);\n            setEncryptedAmount({\n                encryptedValue,\n                proof\n            });\n            alert(\"✅ 加密成功！\");\n        } catch (err) {\n            console.error(\"加密失败:\", err);\n            alert(\"❌ 加密失败，请检查控制台日志。\");\n        }\n    };\n    // ======== 解密金额 ========\n    const handleDecrypt = ()=>{\n        if (!sdkReady) return alert(\"FHEVM SDK 尚未准备好！\");\n        if (!encryptedAmount) return alert(\"请先执行加密操作！\");\n        try {\n            var _fhevm_fhevm, _fhevm_fhevm_decryptor, _fhevm_fhevm1;\n            const decryptFn = (fhevm === null || fhevm === void 0 ? void 0 : (_fhevm_fhevm = fhevm.fhevm) === null || _fhevm_fhevm === void 0 ? void 0 : _fhevm_fhevm.decryptUint32) || (fhevm === null || fhevm === void 0 ? void 0 : (_fhevm_fhevm1 = fhevm.fhevm) === null || _fhevm_fhevm1 === void 0 ? void 0 : (_fhevm_fhevm_decryptor = _fhevm_fhevm1.decryptor) === null || _fhevm_fhevm_decryptor === void 0 ? void 0 : _fhevm_fhevm_decryptor.decryptUint32) || (fhevm === null || fhevm === void 0 ? void 0 : fhevm.decryptUint32);\n            if (!decryptFn) {\n                console.error(\"❌ 未找到 decryptUint32 方法，fhevm 结构如下:\", fhevm);\n                alert(\"SDK 中未找到 decryptUint32 方法，请查看控制台日志！\");\n                return;\n            }\n            const decrypted = decryptFn(encryptedAmount.encryptedValue, encryptedAmount.proof);\n            console.log(\"🔓 解密结果:\", decrypted);\n            alert(\"解密结果: \".concat(decrypted));\n        } catch (err) {\n            console.error(\"解密失败:\", err);\n            alert(\"❌ 解密失败，请检查日志。\");\n        }\n    };\n    // ======== 与合约交互 ========\n    const handleSendToContract = async ()=>{\n        if (!provider || !walletAddress) return alert(\"请先连接钱包！\");\n        if (!sdkReady || !encryptedAmount) return alert(\"SDK 未准备好或未加密数据！\");\n        try {\n            const signer = await provider.getSigner();\n            const contractAddress = \"0x964656ad7aE6D2b502F4467B358aC8C070dBc5Bd\"; // ← 你的 FHEVM 合约地址\n            const abi = [\n                \"function storeEncryptedValue(bytes encryptedValue, bytes proof) public\"\n            ];\n            // 👇 将 SDK 内部字符串序列化为 Bytes\n            const encryptedBytes = ethers__WEBPACK_IMPORTED_MODULE_4__.toUtf8Bytes(encryptedAmount.encryptedValue);\n            const proofBytes = ethers__WEBPACK_IMPORTED_MODULE_4__.toUtf8Bytes(encryptedAmount.proof);\n            const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.Contract(contractAddress, abi, signer);\n            console.log(\"📡 正在发送交易...\");\n            const tx = await contract.storeEncryptedValue(encryptedBytes, proofBytes);\n            await tx.wait();\n            console.log(\"✅ 交易完成:\", tx.hash);\n            alert(\"✅ 已将加密数据发送到合约！\\nTx: \".concat(tx.hash));\n        } catch (err) {\n            console.error(\"❌ 发送失败:\", err);\n            alert(\"❌ 与合约交互失败，请检查控制台日志。\");\n        }\n    };\n    // ======== 前端 UI ========\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            padding: \"2rem\",\n            fontFamily: \"sans-serif\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                children: \"\\uD83D\\uDD10 FHEVM Private Transfer Demo\"\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 140,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: [\n                    \"SDK 状态:\",\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        style: {\n                            color: sdkReady ? \"green\" : \"red\"\n                        },\n                        children: sdkReady ? \"已初始化 ✅\" : \"未就绪 ❌\"\n                    }, void 0, false, {\n                        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                        lineNumber: 145,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 143,\n                columnNumber: 7\n            }, undefined),\n            !walletAddress ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: connectWallet,\n                style: {\n                    padding: \"0.5rem 1rem\",\n                    background: \"#f6851b\",\n                    border: \"none\",\n                    color: \"white\",\n                    borderRadius: \"8px\",\n                    cursor: \"pointer\"\n                },\n                children: \"\\uD83E\\uDD8A 连接钱包\"\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 152,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: [\n                    \"已连接钱包：\",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                        children: walletAddress\n                    }, void 0, false, {\n                        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                        lineNumber: 167,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 166,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {\n                style: {\n                    margin: \"20px 0\"\n                }\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 171,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"number\",\n                value: amount,\n                onChange: (e)=>setAmount(Number(e.target.value)),\n                placeholder: \"输入要加密的金额\",\n                style: {\n                    padding: \"0.5rem\",\n                    marginRight: \"1rem\",\n                    width: \"180px\"\n                }\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 174,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: handleEncrypt,\n                children: \"加密\"\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 181,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: handleDecrypt,\n                style: {\n                    marginLeft: \"10px\"\n                },\n                children: \"解密\"\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 182,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {\n                style: {\n                    margin: \"20px 0\"\n                }\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 186,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: handleSendToContract,\n                style: {\n                    padding: \"0.5rem 1rem\",\n                    background: \"#0070f3\",\n                    color: \"white\",\n                    border: \"none\",\n                    borderRadius: \"8px\",\n                    cursor: \"pointer\"\n                },\n                children: \"\\uD83D\\uDE80 将加密数据发送到合约\"\n            }, void 0, false, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 189,\n                columnNumber: 7\n            }, undefined),\n            encryptedAmount && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: \"20px\",\n                    background: \"#f0f0f0\",\n                    padding: \"1rem\",\n                    borderRadius: \"8px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"\\uD83D\\uDCE6 加密结果\"\n                    }, void 0, false, {\n                        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                        lineNumber: 213,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"Encrypted:\"\n                            }, void 0, false, {\n                                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                                lineNumber: 215,\n                                columnNumber: 13\n                            }, undefined),\n                            \" \",\n                            encryptedAmount.encryptedValue\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"Proof:\"\n                            }, void 0, false, {\n                                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                                lineNumber: 218,\n                                columnNumber: 13\n                            }, undefined),\n                            \" \",\n                            encryptedAmount.proof\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                        lineNumber: 217,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n                lineNumber: 205,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/root/universal-fhevm-sdk/packages/nextjs-demo/src/components/Home.tsx\",\n        lineNumber: 139,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Home, \"Zuv5Ia3+0EihPAdFKWkvzhATpSE=\", false, function() {\n    return [\n        _fhevm_sdk_react__WEBPACK_IMPORTED_MODULE_2__.useFHEVM\n    ];\n});\n_c = Home;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hvbWUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFDNEM7QUFDQTtBQUNaO0FBRWhDLE1BQU1JLE9BQU87O0lBQ1gseUJBQXlCO0lBQ3pCLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdOLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUNPLFVBQVVDLFlBQVksR0FBR1IsK0NBQVFBLENBQWdDO0lBQ3hFLE1BQU0sQ0FBQ1MsUUFBUUMsVUFBVSxHQUFHViwrQ0FBUUEsQ0FBUztJQUM3QyxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFNO0lBQzVELE1BQU0sQ0FBQ2EsVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUV6QywyQkFBMkI7SUFDM0IsTUFBTWUsUUFBUWIsMERBQVFBO0lBRXRCLDBCQUEwQjtJQUMxQkQsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSWMsT0FBTztnQkFDVEMsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQkY7Z0JBQ2pDQyxRQUFRRSxHQUFHLENBQUNIO2dCQUNaQyxRQUFRQyxHQUFHLENBQUMsWUFBWUUsT0FBT0MsSUFBSSxDQUFDTDtnQkFDcENELFlBQVk7WUFDZCxPQUFPO2dCQUNMRSxRQUFRSyxJQUFJLENBQUM7WUFDZjtRQUNGO3lCQUFHO1FBQUNOO0tBQU07SUFFVix5QkFBeUI7SUFDekIsTUFBTU8sZ0JBQWdCO1FBQ3BCLElBQUksT0FBT0MsT0FBT0MsUUFBUSxLQUFLLGFBQWE7WUFDMUNDLE1BQU07WUFDTjtRQUNGO1FBRUEsSUFBSTtZQUNGLE1BQU1sQixXQUFXLElBQUlKLG1EQUFzQixDQUFDb0IsT0FBT0MsUUFBUTtZQUMzRCxNQUFNakIsU0FBU29CLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtZQUM3QyxNQUFNQyxTQUFTLE1BQU1yQixTQUFTc0IsU0FBUztZQUN2QyxNQUFNQyxVQUFVLE1BQU1GLE9BQU9HLFVBQVU7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bEI7Z0JBQU9DLFNBQVNoQzswQkFBZTs7Ozs7OzBCQUNoQyw4REFBQytCO2dCQUFPQyxTQUFTMUI7Z0JBQWVrQixPQUFPO29CQUFFMEIsWUFBWTtnQkFBTzswQkFBRzs7Ozs7OzBCQUkvRCw4REFBQ1o7Z0JBQUdkLE9BQU87b0JBQUVlLFFBQVE7Z0JBQVM7Ozs7OzswQkFHOUIsOERBQUNSO2dCQUNDQyxTQUFTckI7Z0JBQ1RhLE9BQU87b0JBQ0xDLFNBQVM7b0JBQ1RRLFlBQVk7b0JBQ1pILE9BQU87b0JBQ1BJLFFBQVE7b0JBQ1JDLGNBQWM7b0JBQ2RDLFFBQVE7Z0JBQ1Y7MEJBQ0Q7Ozs7OztZQUtBM0QsaUNBQ0MsOERBQUM4QztnQkFDQ0MsT0FBTztvQkFDTDJCLFdBQVc7b0JBQ1hsQixZQUFZO29CQUNaUixTQUFTO29CQUNUVSxjQUFjO2dCQUNoQjs7a0NBRUEsOERBQUNpQjtrQ0FBRzs7Ozs7O2tDQUNKLDhEQUFDeEI7OzBDQUNDLDhEQUFDQzswQ0FBTzs7Ozs7OzRCQUFtQjs0QkFBRXBELGdCQUFnQjJCLGNBQWM7Ozs7Ozs7a0NBRTdELDhEQUFDd0I7OzBDQUNDLDhEQUFDQzswQ0FBTzs7Ozs7OzRCQUFlOzRCQUFFcEQsZ0JBQWdCNEIsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU0xRDtHQTFOTW5DOztRQVNVRixzREFBUUE7OztLQVRsQkU7QUE0Tk4saUVBQWVBLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIi9yb290L3VuaXZlcnNhbC1maGV2bS1zZGsvcGFja2FnZXMvbmV4dGpzLWRlbW8vc3JjL2NvbXBvbmVudHMvSG9tZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VGSEVWTSB9IGZyb20gXCJAZmhldm0vc2RrLXJlYWN0XCI7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tIFwiZXRoZXJzXCI7XG5cbmNvbnN0IEhvbWUgPSAoKSA9PiB7XG4gIC8vID09PT09PT09IOeKtuaAgeWPmOmHjyA9PT09PT09PVxuICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Byb3ZpZGVyLCBzZXRQcm92aWRlcl0gPSB1c2VTdGF0ZTxldGhlcnMuQnJvd3NlclByb3ZpZGVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFthbW91bnQsIHNldEFtb3VudF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbZW5jcnlwdGVkQW1vdW50LCBzZXRFbmNyeXB0ZWRBbW91bnRdID0gdXNlU3RhdGU8YW55PihudWxsKTtcbiAgY29uc3QgW3Nka1JlYWR5LCBzZXRTZGtSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gPT09PT09PT0gU0RLIOWunuS+iyA9PT09PT09PVxuICBjb25zdCBmaGV2bSA9IHVzZUZIRVZNKCk7XG5cbiAgLy8gPT09PT09PT0g5Yid5aeL5YyW5qOA5p+lID09PT09PT09XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZoZXZtKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBGSEVWTSBTREsg5bey5Yid5aeL5YyWOlwiLCBmaGV2bSk7XG4gICAgICBjb25zb2xlLmRpcihmaGV2bSk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflJEg5Y+v55So55qE6ZSuOlwiLCBPYmplY3Qua2V5cyhmaGV2bSkpO1xuICAgICAgc2V0U2RrUmVhZHkodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBGSEVWTSBTREsg5bCa5pyq5Yid5aeL5YyWXCIpO1xuICAgIH1cbiAgfSwgW2ZoZXZtXSk7XG5cbiAgLy8gPT09PT09PT0g6ZKx5YyF6L+e5o6lID09PT09PT09XG4gIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZXRoZXJldW0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGFsZXJ0KFwi6K+35YWI5a6J6KOFIE1ldGFNYXNrIOaIluWFtuS7luS7peWkquWdiumSseWMheaJqeWxle+8gVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcblxuICAgICAgc2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgc2V0V2FsbGV0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+miiDpkrHljIXlt7Lov57mjqU6XCIsIGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCDpkrHljIXov57mjqXlpLHotKU6XCIsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8vID09PT09PT09IOWKoOWvhumHkeminSA9PT09PT09PVxuICBjb25zdCBoYW5kbGVFbmNyeXB0ID0gKCkgPT4ge1xuICAgIGlmICghc2RrUmVhZHkpIHJldHVybiBhbGVydChcIkZIRVZNIFNESyDlsJrmnKrlh4blpIflpb3vvIzor7fnqI3nrYnvvIFcIik7XG4gICAgaWYgKCFhbW91bnQgfHwgYW1vdW50IDw9IDApIHJldHVybiBhbGVydChcIuivt+i+k+WFpeS4gOS4quacieaViOeahOaVsOWtl1wiKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyDwn5GHIOiHquWKqOajgOa1i+ato+ehrueahOWKoOWvhuWHveaVsOS9jee9rlxuICAgICAgY29uc3QgZW5jcnlwdEZuID1cbiAgICAgICAgZmhldm0/LmZoZXZtPy5lbmNyeXB0VWludDMyIHx8XG4gICAgICAgIGZoZXZtPy5maGV2bT8uZW5jcnlwdG9yPy5lbmNyeXB0VWludDMyIHx8XG4gICAgICAgIGZoZXZtPy5lbmNyeXB0VWludDMyO1xuXG4gICAgICBpZiAoIWVuY3J5cHRGbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIOacquaJvuWIsCBlbmNyeXB0VWludDMyIOaWueazle+8jGZoZXZtIOe7k+aehOWmguS4izpcIiwgZmhldm0pO1xuICAgICAgICBhbGVydChcIlNESyDkuK3mnKrmib7liLAgZW5jcnlwdFVpbnQzMiDmlrnms5XvvIzor7fmn6XnnIvmjqfliLblj7Dml6Xlv5fvvIFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlbmNyeXB0ZWRWYWx1ZSwgcHJvb2YgfSA9IGVuY3J5cHRGbihhbW91bnQpO1xuICAgICAgY29uc29sZS5sb2coXCLwn5SQIOWKoOWvhue7k+aenDpcIiwgZW5jcnlwdGVkVmFsdWUpO1xuICAgICAgY29uc29sZS5sb2coXCLwn6e+IOWKoOWvhuivgeaYjjpcIiwgcHJvb2YpO1xuICAgICAgc2V0RW5jcnlwdGVkQW1vdW50KHsgZW5jcnlwdGVkVmFsdWUsIHByb29mIH0pO1xuICAgICAgYWxlcnQoXCLinIUg5Yqg5a+G5oiQ5Yqf77yBXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuWKoOWvhuWksei0pTpcIiwgZXJyKTtcbiAgICAgIGFsZXJ0KFwi4p2MIOWKoOWvhuWksei0pe+8jOivt+ajgOafpeaOp+WItuWPsOaXpeW/l+OAglwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gPT09PT09PT0g6Kej5a+G6YeR6aKdID09PT09PT09XG4gIGNvbnN0IGhhbmRsZURlY3J5cHQgPSAoKSA9PiB7XG4gICAgaWYgKCFzZGtSZWFkeSkgcmV0dXJuIGFsZXJ0KFwiRkhFVk0gU0RLIOWwmuacquWHhuWkh+Wlve+8gVwiKTtcbiAgICBpZiAoIWVuY3J5cHRlZEFtb3VudCkgcmV0dXJuIGFsZXJ0KFwi6K+35YWI5omn6KGM5Yqg5a+G5pON5L2c77yBXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRGbiA9XG4gICAgICAgIGZoZXZtPy5maGV2bT8uZGVjcnlwdFVpbnQzMiB8fFxuICAgICAgICBmaGV2bT8uZmhldm0/LmRlY3J5cHRvcj8uZGVjcnlwdFVpbnQzMiB8fFxuICAgICAgICBmaGV2bT8uZGVjcnlwdFVpbnQzMjtcblxuICAgICAgaWYgKCFkZWNyeXB0Rm4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCDmnKrmib7liLAgZGVjcnlwdFVpbnQzMiDmlrnms5XvvIxmaGV2bSDnu5PmnoTlpoLkuIs6XCIsIGZoZXZtKTtcbiAgICAgICAgYWxlcnQoXCJTREsg5Lit5pyq5om+5YiwIGRlY3J5cHRVaW50MzIg5pa55rOV77yM6K+35p+l55yL5o6n5Yi25Y+w5pel5b+X77yBXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGRlY3J5cHRGbihcbiAgICAgICAgZW5jcnlwdGVkQW1vdW50LmVuY3J5cHRlZFZhbHVlLFxuICAgICAgICBlbmNyeXB0ZWRBbW91bnQucHJvb2ZcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflJMg6Kej5a+G57uT5p6cOlwiLCBkZWNyeXB0ZWQpO1xuICAgICAgYWxlcnQoYOino+Wvhue7k+aenDogJHtkZWNyeXB0ZWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi6Kej5a+G5aSx6LSlOlwiLCBlcnIpO1xuICAgICAgYWxlcnQoXCLinYwg6Kej5a+G5aSx6LSl77yM6K+35qOA5p+l5pel5b+X44CCXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyA9PT09PT09PSDkuI7lkIjnuqbkuqTkupIgPT09PT09PT1cbiAgY29uc3QgaGFuZGxlU2VuZFRvQ29udHJhY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFwcm92aWRlciB8fCAhd2FsbGV0QWRkcmVzcykgcmV0dXJuIGFsZXJ0KFwi6K+35YWI6L+e5o6l6ZKx5YyF77yBXCIpO1xuICAgIGlmICghc2RrUmVhZHkgfHwgIWVuY3J5cHRlZEFtb3VudCkgcmV0dXJuIGFsZXJ0KFwiU0RLIOacquWHhuWkh+WlveaIluacquWKoOWvhuaVsOaNru+8gVwiKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFwiMHg5NjQ2NTZhZDdhRTZEMmI1MDJGNDQ2N0IzNThhQzhDMDcwZEJjNUJkXCI7IC8vIOKGkCDkvaDnmoQgRkhFVk0g5ZCI57qm5Zyw5Z2AXG4gICAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgIFwiZnVuY3Rpb24gc3RvcmVFbmNyeXB0ZWRWYWx1ZShieXRlcyBlbmNyeXB0ZWRWYWx1ZSwgYnl0ZXMgcHJvb2YpIHB1YmxpY1wiLFxuICAgICAgXTtcblxuICAgICAgLy8g8J+RhyDlsIYgU0RLIOWGhemDqOWtl+espuS4suW6j+WIl+WMluS4uiBCeXRlc1xuICAgICAgY29uc3QgZW5jcnlwdGVkQnl0ZXMgPSBldGhlcnMudG9VdGY4Qnl0ZXMoZW5jcnlwdGVkQW1vdW50LmVuY3J5cHRlZFZhbHVlKTtcbiAgICAgIGNvbnN0IHByb29mQnl0ZXMgPSBldGhlcnMudG9VdGY4Qnl0ZXMoZW5jcnlwdGVkQW1vdW50LnByb29mKTtcblxuICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCBzaWduZXIpO1xuICAgICAgY29uc29sZS5sb2coXCLwn5OhIOato+WcqOWPkemAgeS6pOaYky4uLlwiKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3RvcmVFbmNyeXB0ZWRWYWx1ZShlbmNyeXB0ZWRCeXRlcywgcHJvb2ZCeXRlcyk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIOS6pOaYk+WujOaIkDpcIiwgdHguaGFzaCk7XG4gICAgICBhbGVydChg4pyFIOW3suWwhuWKoOWvhuaVsOaNruWPkemAgeWIsOWQiOe6pu+8gVxcblR4OiAke3R4Lmhhc2h9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIOWPkemAgeWksei0pTpcIiwgZXJyKTtcbiAgICAgIGFsZXJ0KFwi4p2MIOS4juWQiOe6puS6pOS6kuWksei0pe+8jOivt+ajgOafpeaOp+WItuWPsOaXpeW/l+OAglwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gPT09PT09PT0g5YmN56uvIFVJID09PT09PT09XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiBcIjJyZW1cIiwgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIgfX0+XG4gICAgICA8aDE+8J+UkCBGSEVWTSBQcml2YXRlIFRyYW5zZmVyIERlbW88L2gxPlxuXG4gICAgICB7LyogU0RLIOeKtuaAgSAqL31cbiAgICAgIDxwPlxuICAgICAgICBTREsg54q25oCBOntcIiBcIn1cbiAgICAgICAgPHN0cm9uZyBzdHlsZT17eyBjb2xvcjogc2RrUmVhZHkgPyBcImdyZWVuXCIgOiBcInJlZFwiIH19PlxuICAgICAgICAgIHtzZGtSZWFkeSA/IFwi5bey5Yid5aeL5YyWIOKchVwiIDogXCLmnKrlsLHnu6og4p2MXCJ9XG4gICAgICAgIDwvc3Ryb25nPlxuICAgICAgPC9wPlxuXG4gICAgICB7Lyog6ZKx5YyF54q25oCBICovfVxuICAgICAgeyF3YWxsZXRBZGRyZXNzID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgb25DbGljaz17Y29ubmVjdFdhbGxldH1cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgcGFkZGluZzogXCIwLjVyZW0gMXJlbVwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjZjY4NTFiXCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI4cHhcIixcbiAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIPCfpoog6L+e5o6l6ZKx5YyFXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKSA6IChcbiAgICAgICAgPHA+XG4gICAgICAgICAg5bey6L+e5o6l6ZKx5YyF77yaPGNvZGU+e3dhbGxldEFkZHJlc3N9PC9jb2RlPlxuICAgICAgICA8L3A+XG4gICAgICApfVxuXG4gICAgICA8aHIgc3R5bGU9e3sgbWFyZ2luOiBcIjIwcHggMFwiIH19IC8+XG5cbiAgICAgIHsvKiDliqDlr4bovpPlhaXmoYYgKi99XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgIHZhbHVlPXthbW91bnR9XG4gICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0QW1vdW50KE51bWJlcihlLnRhcmdldC52YWx1ZSkpfVxuICAgICAgICBwbGFjZWhvbGRlcj1cIui+k+WFpeimgeWKoOWvhueahOmHkeminVwiXG4gICAgICAgIHN0eWxlPXt7IHBhZGRpbmc6IFwiMC41cmVtXCIsIG1hcmdpblJpZ2h0OiBcIjFyZW1cIiwgd2lkdGg6IFwiMTgwcHhcIiB9fVxuICAgICAgLz5cbiAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlRW5jcnlwdH0+5Yqg5a+GPC9idXR0b24+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZURlY3J5cHR9IHN0eWxlPXt7IG1hcmdpbkxlZnQ6IFwiMTBweFwiIH19PlxuICAgICAgICDop6Plr4ZcbiAgICAgIDwvYnV0dG9uPlxuXG4gICAgICA8aHIgc3R5bGU9e3sgbWFyZ2luOiBcIjIwcHggMFwiIH19IC8+XG5cbiAgICAgIHsvKiDlj5HpgIHliqDlr4bmlbDmja7liLDpk77kuIogKi99XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZVNlbmRUb0NvbnRyYWN0fVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHBhZGRpbmc6IFwiMC41cmVtIDFyZW1cIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwMDcwZjNcIixcbiAgICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjhweFwiLFxuICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIPCfmoAg5bCG5Yqg5a+G5pWw5o2u5Y+R6YCB5Yiw5ZCI57qmXG4gICAgICA8L2J1dHRvbj5cblxuICAgICAgey8qIOWKoOWvhue7k+aenOaYvuekuiAqL31cbiAgICAgIHtlbmNyeXB0ZWRBbW91bnQgJiYgKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIG1hcmdpblRvcDogXCIyMHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmMGYwZjBcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiMXJlbVwiLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjhweFwiLFxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8aDM+8J+TpiDliqDlr4bnu5Pmnpw8L2gzPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPHN0cm9uZz5FbmNyeXB0ZWQ6PC9zdHJvbmc+IHtlbmNyeXB0ZWRBbW91bnQuZW5jcnlwdGVkVmFsdWV9XG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPHN0cm9uZz5Qcm9vZjo8L3N0cm9uZz4ge2VuY3J5cHRlZEFtb3VudC5wcm9vZn1cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWU7XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VGSEVWTSIsImV0aGVycyIsIkhvbWUiLCJ3YWxsZXRBZGRyZXNzIiwic2V0V2FsbGV0QWRkcmVzcyIsInByb3ZpZGVyIiwic2V0UHJvdmlkZXIiLCJhbW91bnQiLCJzZXRBbW91bnQiLCJlbmNyeXB0ZWRBbW91bnQiLCJzZXRFbmNyeXB0ZWRBbW91bnQiLCJzZGtSZWFkeSIsInNldFNka1JlYWR5IiwiZmhldm0iLCJjb25zb2xlIiwibG9nIiwiZGlyIiwiT2JqZWN0Iiwia2V5cyIsIndhcm4iLCJjb25uZWN0V2FsbGV0Iiwid2luZG93IiwiZXRoZXJldW0iLCJhbGVydCIsIkJyb3dzZXJQcm92aWRlciIsInNlbmQiLCJzaWduZXIiLCJnZXRTaWduZXIiLCJhZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImVyciIsImVycm9yIiwiaGFuZGxlRW5jcnlwdCIsImVuY3J5cHRGbiIsImVuY3J5cHRVaW50MzIiLCJlbmNyeXB0b3IiLCJlbmNyeXB0ZWRWYWx1ZSIsInByb29mIiwiaGFuZGxlRGVjcnlwdCIsImRlY3J5cHRGbiIsImRlY3J5cHRVaW50MzIiLCJkZWNyeXB0b3IiLCJkZWNyeXB0ZWQiLCJoYW5kbGVTZW5kVG9Db250cmFjdCIsImNvbnRyYWN0QWRkcmVzcyIsImFiaSIsImVuY3J5cHRlZEJ5dGVzIiwidG9VdGY4Qnl0ZXMiLCJwcm9vZkJ5dGVzIiwiY29udHJhY3QiLCJDb250cmFjdCIsInR4Iiwic3RvcmVFbmNyeXB0ZWRWYWx1ZSIsIndhaXQiLCJoYXNoIiwiZGl2Iiwic3R5bGUiLCJwYWRkaW5nIiwiZm9udEZhbWlseSIsImgxIiwicCIsInN0cm9uZyIsImNvbG9yIiwiYnV0dG9uIiwib25DbGljayIsImJhY2tncm91bmQiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJjdXJzb3IiLCJjb2RlIiwiaHIiLCJtYXJnaW4iLCJpbnB1dCIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZSIsIk51bWJlciIsInRhcmdldCIsInBsYWNlaG9sZGVyIiwibWFyZ2luUmlnaHQiLCJ3aWR0aCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJoMyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Home.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/../../node_modules/.pnpm/next@15.2.5_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Froot%2Funiversal-fhevm-sdk%2Fpackages%2Fnextjs-demo%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);